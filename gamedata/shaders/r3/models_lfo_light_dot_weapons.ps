#include "common.h"

uniform float4 m_hud_params;
uniform float4 m_affects;

struct v2p
{
    float2 tc0 : TEXCOORD0; // base
    float3 tc1 : TEXCOORD1; // environment
    float4 c0 : COLOR0; // sun.(fog*fog)
    float4 pos2d : SV_Position;
};

float resize(float input, float factor, float offset) { return (input - 0.5f + offset) / factor + 0.5f - offset; }

// https://stackoverflow.com/a/10625698
float random(float2 p)
{
    float2 K1 = float2(23.14069263277926f, 2.665144142690225f);
    return frac(cos(dot(p, K1)) * 12345.6789f);
}

float get_noise(float2 co) { return (frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 0.5; }

float4 main(v2p I) : SV_Target
{
    float factor = screen_res.y / 1480.0;
    factor = factor * (1.0 / (m_hud_params.z / 0.45)) * 0.75;
    float size = 512.0 * factor;

    // Устанавливаем метку по центру экрана
    I.pos2d.xy = I.pos2d.xy - (screen_res.xy - size) / 2.0;

    // Поворачиваем метку под текущий наклон
    I.pos2d.xy /= size;
    float angle = m_hud_params.w;
    float2x2 rot = float2x2(cos(angle), sin(angle), -sin(angle), cos(angle));
    I.pos2d.xy = mul(I.pos2d.xy  - 0.5, rot) + 0.5;
    I.pos2d.xy *= size;

    // Масштабируем
    I.pos2d.x = resize(I.pos2d.x, factor, 0);
    I.pos2d.y = resize(I.pos2d.y, factor, 0);

    float4 final = s_base.Load(I.pos2d.xyz) * m_hud_params.x;

    // Noise
    final.rgb = final.rgb * 0.8;
    float noise = get_noise(I.tc0 * timers.z) * 0.25 * 0.25 * 25;
    final.r += noise;
    final.g += noise;
    final.b += noise;

    // Коллиматоры глючат при выбросе
    float mig = 1.0f - (m_affects.x * 2.f);

    return float4(final.r, final.g, final.b, random(timers.xz) > mig ? 0.f : final.a);
}