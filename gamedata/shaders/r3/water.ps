#include "common.h"

#include "screenspace_water.h"

#ifdef SSLR_ENABLED
Texture2D s_bluenoise;
#endif

// uniform float4 ogsr_game_time; // hour, min, sec, ms
// static const float REFLS_DISABLE_TIME_START = ( 20 * 60 ) + 30; //20:30
// static const float REFLS_DISABLE_TIME_STOP  = ( 4 * 60 ); //04:00

struct vf
{
    float2 tbase : TEXCOORD0; // base
    float4 tnorm0 : TEXCOORD1; // nm0
    float4 position_w : TEXCOORD2; // nm1
    float3 M1 : TEXCOORD3;
    float3 M2 : TEXCOORD4;
    float3 M3 : TEXCOORD5;
    float3 v2point_w : TEXCOORD6;
    float4 tctexgen : TEXCOORD7;
    float4 c0 : COLOR0; // .w - tonemap scale
    float4 c1 : COLOR1;
    float fog : FOG;
    float4 hpos : SV_Position;
};

Texture2D s_nmap;
Texture2D s_leaves;

#if defined(USE_SOFT_WATER) && defined(NEED_SOFT_WATER)
float3 water_intensity;
#endif

#ifdef GBUFFER_OPTIMIZATION
float4 main(vf I, float4 pos2d : SV_Position) : SV_Target
#else
float4 main(vf I) : SV_Target
#endif
{
    float4 base = s_base.Sample(smp_base, I.tbase);

    float3 n0 = s_nmap.Sample(smp_base, I.tnorm0.xy);
    float3 n1 = s_nmap.Sample(smp_base, I.tnorm0.zw);
    float3 Navg = n0 + n1 - 1;

	float2 PosTc = I.tctexgen.xy / I.tctexgen.z;

#ifdef GBUFFER_OPTIMIZATION
	gbuffer_data gbd = gbuffer_load_data(PosTc, pos2d);
#else
	gbuffer_data gbd = gbuffer_load_data(PosTc);
#endif

    float3 _P = gbd.P;
	
    float lmap = pow(saturate(I.c0.x * 4), 25);
	
#ifndef USE_MSAA
	float water_shadows = saturate(s_accumulator.Sample(smp_nofilter, PosTc).r * 2000);
#else
	float water_shadows = saturate(s_accumulator.Load(int3((PosTc) * screen_res.xy, 0), 0).r * 2000);
#endif

#ifdef NEED_SPLASHES
    if (rain_params.x > 0)
    {
        float3 splashes = calc_rain_splashes(I.tbase * 0.5f);
        float clearing_pos = smoothstep(5.h, 20.h, length(_P.xyz));
        float fade = (1.h - saturate(clearing_pos * clearing_pos));
        Navg += splashes * fade * lmap * 1.75f * rain_params.x;
    }
#endif

    float3 Nw = mul(float3x3(I.M1, I.M2, I.M3), Navg);
    Nw = normalize(Nw);

	float _Pz = gbd.P.z;

	// Reflections
	float3 v2point = normalize(I.v2point_w);
	float3 vreflect = reflect(v2point, Nw);
	
	// 3d view space pos reconstruction math using object space
	float3 Pv = float3(I.tctexgen.z * (I.hpos.xy * pos_decompression_params.zw - pos_decompression_params.xy), I.tctexgen.z);
	float3 eyedir = normalize(Pv);
	float3 Nv = normalize(mul(m_V, Nw));

	float fresnel = saturate(dot(vreflect,v2point));
	float power = pow(fresnel, 9);
	float amount = 0.55h + 0.25h * power; // 1=full env, 0=no env

    float3 c_reflection = calc_envmap(vreflect) * amount;
	
	float light = dot(I.c0.rgb, float3(0.33h, 0.33h, 0.33h));
	c_reflection *= light * 2;
	
#ifdef NEED_MOONROAD
    const float sun_light_vibrance = 0.35f;
    float3 sun_light = L_sun_color.rgb;
    sun_light = lerp(sun_light, dot(sun_light, 0.33f), sun_light_vibrance);

    float3 half_vec = normalize(v2point + L_sun_dir_w);
    float specular = pow(abs(dot(half_vec, Nw)), 64.0f);
    c_reflection *= 1.h + specular * 5.0f * sun_light * water_shadows;
#endif

#ifdef SSLR_ENABLED
		float3 ssr_hit_uv = 0.0f;
	
		// Blue Noise & Normal for noise
		float3 NN = normalize(float3(Navg.x * 0.15f, Navg.y * 0.15f, Navg.z));
		float blue_noise = s_bluenoise.Sample(smp_linear, I.tbase * float2(0.05f, 0.05f) + NN).b * 1.5f;
	
		// Border screen fade
		float2 calc_edges = smoothstep(-0.05f, G_SSR_WATER_SCREENFADE, float2(PosTc.x, 1.0f - PosTc.x));
		float edgeFade = calc_edges.x * calc_edges.y;

		// Compute reflection bounce
		float3 wreflect = reflect(eyedir, Nv);

		// Don't trace rays which face the camera. Still worth to avoid the rays mess when you look down.
		//edgeFade *= step(dot(-eyedir, wreflect), 0);
		edgeFade *= smoothstep(0.3f, 0.6f, dot(eye_direction, vreflect));
		
		// Trace a ray
		if (edgeFade > 0.02f)
			ssr_hit_uv = SSFX_ssr_water_ray(Pv, wreflect, blue_noise, 0);
	
		// Get reflection pixel from scene screen
#if defined(USE_MSAA)
		float3 refl_ray = s_last_frame.Load(ssr_hit_uv.xy * screen_res.xy, 0).rgb;
#else
		float3 refl_ray = s_last_frame.Sample(smp_linear, ssr_hit_uv.xy).rgb;
#endif

		// Adjust reflection intensity using ssr_hit_uv.y and edgeFade
		float ray_fade = ssr_hit_uv.y * 5.0f;
		
		// Reflection fog fadeout
		float r_fog = 1.0 - saturate((length(float3(Pv.x,Pv.y,ssr_hit_uv.z)) * fog_params.w + fog_params.x));

		float refl_power = saturate(ray_fade * edgeFade * r_fog * r_fog);
		
		// Fallback to Skybox
		c_reflection = lerp(c_reflection, refl_ray * amount, refl_power);
#endif
	
	base.rgb *= I.c1.xyz * 2;
	
    float3 final = lerp(c_reflection, base.rgb, base.a);

#ifdef NEED_SOFT_WATER
    float alpha = 0.55h + 0.25h * power; // 1=full env, 0=no env
#ifdef USE_SOFT_WATER
    //	Igor: additional depth test
    float waterDepth = _P.z - I.tctexgen.z;

    //	water fog
    const float fog_exp_intens = -4.0h;
    float fog = 1 - exp(fog_exp_intens * waterDepth);
    float3 Fc = float3(0.1h, 0.1h, 0.1h) * water_intensity.r;
    final = lerp(Fc, final, alpha);

    alpha = min(alpha, saturate(waterDepth));

    alpha = max(fog, alpha);

    //	Leaves
    float4 leaves = s_leaves.Sample(smp_base, I.tbase);
    leaves.rgb *= water_intensity.r;
    float calc_cos = -dot(float3(I.M1.z, I.M2.z, I.M3.z), normalize(v2point));
    float calc_depth = saturate(waterDepth * calc_cos);
    float fLeavesFactor = smoothstep(0.025, 0.05, calc_depth);
    fLeavesFactor *= smoothstep(0.1, 0.075, calc_depth);
    final = lerp(final, leaves, leaves.a * fLeavesFactor);
    alpha = lerp(alpha, leaves.a, leaves.a * fLeavesFactor);

#endif //	USE_SOFT_WATER

    //	Fogging
    final = lerp(fog_color, final, I.fog);
    alpha *= I.fog * I.fog;

    return float4(final, alpha);

#else //	NEED_SOFT_WATER

    final = lerp(fog_color, final, I.fog);
    return float4(final, I.fog * I.fog);

#endif //	NEED_SOFT_WATER
}
