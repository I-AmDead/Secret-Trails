-- ' Ключем является группировка персонажа. Значением является таблица, содержашая имена секций предметов.
local item_by_community = {}

-- ' Множители и минимаксы для выпадения вещей в зависимости от уровня
local mul_by_level = {}
local count_by_level = {}

-- ' Предметы, относящиеся к патронам. Их надо спаунить другим методом.
local ammo_sections = {}

local death_ini = ini_file("misc\\ph_box_generic.ltx")

class "ph_item_box"

function ph_item_box:__init(obj)
    self.obj = obj

    local community_list = {"def_box", "small_box_generic", "small_box_ussr", "small_box_nato", "small_box_army",
                            "small_box_science", "big_box_generic", "big_box_dungeons", "big_box_arsenal"}

    for k, v in pairs(community_list) do
        -- ' Необходимо заполнить таблицу
        item_by_community[v] = {}
        if death_ini:section_exist(v) then
            local n = death_ini:line_count(v)
            local id, value = "", ""
            for i = 0, n - 1 do
                result, id, value = death_ini:r_line(v, i, "", "")
                item_by_community[v][id] = 100 * tonumber(value)
            end
        end
    end

    -- ' Множители и минимаксы для выпадения вещей в зависимости от уровня
    local level_name = level.name()

    if not death_ini:section_exist(level_name) then
        level_name = "default"
    end

    local n = death_ini:line_count(level_name)
    local id, value = "", ""
    for i = 0, n - 1 do
        result, id, value = death_ini:r_line(level_name, i, "", "")
        mul_by_level[id] = tonumber(value)
    end

    local item_count_section = "item_count_" .. level.get_game_difficulty()
    local n = death_ini:line_count(item_count_section)
    for i = 0, n - 1 do
        result, id, value = death_ini:r_line(item_count_section, i, "", "")
        -- ' Нужно распарсить value в два значения
        local t = parse_nums(value)
        if t[1] == nil then
            abort("Error on [death_ini] declaration. Section [%s], line [%s]", item_count_section, tostring(id))
        end
        local min = t[1]
        local max = t[2]
        if max == nil then
            max = min
        end

        if mul_by_level[id] == nil then
            mul_by_level[id] = 0
        end

        min = tonumber(min) * mul_by_level[id]
        max = tonumber(max) * mul_by_level[id]

        count_by_level[id] = {
            min = min,
            max = max
        }
    end
    -- ' Предметы, относящиеся к патронам. Их надо спаунить другим методом.
    ammo_sections = {}
    local n = death_ini:line_count("ammo_sections")
    local id, value = "", ""
    for i = 0, n - 1 do
        result, id, value = death_ini:r_line("ammo_sections", i, "", "")
        ammo_sections[id] = true
    end

end

function ph_item_box:spawn_items()
    local spawn_items = {}
    local ini = self.obj:spawn_ini()
    local community = get_string("drop_box", "community", "def_box", ini)
    if r_items(ini, "drop_box", "items") ~= nil then
        local items = r_items(ini, "drop_box", "items")
        for k, v in pairs(items) do
            create_obligatory_items(self.obj, v.section, v.count)
        end
        return
    end

    -- ' Доспавниваем необходимое количество итемов:
    -- ' Необходимо составить список объектов которые могут быть заспавнены для персонажа
    local spawn_items = item_by_community[community]
    -- ' Если комьюнити задана не верно, то ставим дефолт и срем в лог.
    if spawn_items == nil then
        local spawn_items = {}
        local spawn_items = item_by_community["def_box"]
    end

    for k, v in pairs(spawn_items) do
        -- ' По каждому объекту необходимо получить количество
        local number = math.ceil(math.random(count_by_level[k].min, count_by_level[k].max))
        -- ' Необходимо заспавнить нужное количество.
        create_items(self.obj, k, number, v)
    end
end

-- ' Функция спавнит необходимое число предметов
function create_items(obj, section, number, rnd)
    if ammo_sections[section] == true then
        if math.random(100) <= rnd then

            if number > 0 then
                local position = vector():set(0, 0, 0)
                position.x = obj:position().x + math.random(-30, 30) / 100
                position.z = obj:position().z + math.random(-30, 30) / 100
                position.y = obj:position().y + math.random(30, 50) / 100

                se_respawn.create_ammo(section, position, obj:level_vertex_id(), obj:game_vertex_id(), 65535, number)
            end
        end
    else
        for i = 1, number do
            -- ' Проверяем вероятность появить каждый объект в отдельности
            if math.random(100) <= rnd then
                local position = vector():set(0, 0, 0)
                position.x = obj:position().x + math.random(-30, 30) / 100
                position.z = obj:position().z + math.random(-30, 30) / 100
                position.y = obj:position().y + math.random(30, 50) / 100

                alife():create(section, position, obj:level_vertex_id(), obj:game_vertex_id())
            end
        end
    end
end

function parse_names(s)
    local t = {}
    for name in string.gfind(s, "([%w_%-.\\]+)%p*") do
        table.insert(t, name)
    end
    return t
end

function r_items(spawn_ini, section, line)
    if spawn_ini:line_exist(section, line) then
        -- ' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
        local t = parse_names(spawn_ini:r_string(section, line))
        local n = table.getn(t)

        local ret_table = {}
        local k = 1
        while k <= n do
            local item = {}
            item.section = t[k]
            -- Проверяем что это не последняя запись
            if t[k + 1] ~= nil then
                local p = tonumber(t[k + 1])
                -- проверяем что вторым числом задана вероятность, а не другая секция спавну
                if p then
                    -- забиваем число
                    item.count = p
                    k = k + 2
                else
                    -- забиваем дефолт 1
                    item.count = 1
                    k = k + 1
                end
            else
                item.count = 1
                k = k + 1
            end
            table.insert(ret_table, item)
        end
        return ret_table
    end
    return nil
end

function create_obligatory_items(obj, item, count)
    for i = 1, count do
        local position = vector():set(0, 0, 0)
        position.x = obj:position().x + math.random(-30, 30) / 100
        position.z = obj:position().z + math.random(-30, 30) / 100
        position.y = obj:position().y + math.random(30, 50) / 100

        alife():create(item, position, obj:level_vertex_id(), obj:game_vertex_id())
    end
end
