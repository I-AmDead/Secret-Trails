-- ----------------------------------------------------------------------------------------------------
-- Общие функции
-- ----------------------------------------------------------------------------------------------------
function disable_ui_elements(p)
    if p == "all" then
        db.actor:hide_weapon()
        level.disable_input()
        level.hide_indicators()
        ui_minimap_bioradar.hud_hide()
    elseif p == "weapon" then
        db.actor:hide_weapon()
    elseif p == "input" then
        level.disable_input()
    elseif p == "hud" then
        level.hide_indicators()
        ui_minimap_bioradar.hud_hide()
    end
end

function enable_ui_elements(p)
    if p == "all" then
        db.actor:restore_weapon()
        level.enable_input()
        level.show_indicators()
        ui_minimap_bioradar.hud_show()
    elseif p == "weapon" then
        db.actor:restore_weapon()
    elseif p == "input" then
        level.enable_input()
    elseif p == "hud" then
        level.show_indicators()
        ui_minimap_bioradar.hud_show()
    end
end

function disable_ui(actor, npc)
    db.actor:hide_weapon()
    level.disable_input()
    level.hide_indicators()
    ui_minimap_bioradar.hud_hide()
end

function enable_ui(actor, npc)
    level.show_indicators()
    level.enable_input()
    db.actor:restore_weapon()
    ui_minimap_bioradar.hud_show()
end

function run_cam_effector(actor, npc, p)
    if p[1] then
        local loop, num = false, (1000 + math.random(100))

        if p[2] and type(p[2]) == "number" and p[2] > 0 then
            num = p[2]
        end

        if p[3] and p[3] == "true" then
            loop = true
        end

        -- level.add_pp_effector(p[1] .. ".ppe", num, loop)
        level.add_cam_effector("camera_effects\\" .. p[1] .. ".anm", num, loop, "")
    end
end

function stop_cam_effector(actor, npc, p)
    if p[1] and type(p[1]) == "number" and p[1] > 0 then
        level.remove_cam_effector(p[1])
    end
end

function run_postprocess(actor, npc, p)
    if p[1] then
        local loop, num = false, (2000 + math.random(100))

        if p[2] and type(p[2]) == "number" and p[2] > 0 then
            num = p[2]
        end

        if p[3] and p[3] == "true" then
            loop = true
        end

        level.add_pp_effector(p[1] .. ".ppe", num, loop)
    end
end

function stop_postprocess(actor, npc, p)
    if p[1] and type(p[1]) == "number" and p[1] > 0 then
        level.remove_pp_effector(p[1])
    end
end

function run_tutorial(actor, npc, p)
    game.start_tutorial(p[1])
end
function run_tutorial_if_newbie(actor, npc, p)
    if has_alife_info("esc_trader_newbie") then
        game.start_tutorial(p[1])
    end
end

function teleport_actor(actor, npc, p)
    local point = patrol(p[1])
    local look = patrol(p[2])

    db.actor:set_actor_position(point:point(0))
    local dir = look:point(0):sub(point:point(0))
    db.actor:set_actor_direction(-dir:getH())
end

-----------------------------------------------------------------------------
local drop_point, drop_object = 0, 0
local function drop_object_item(item)
    drop_object:drop_item_and_teleport(item, drop_point)
end

function drop_actor_inventory(actor, npc, p)
    if p[1] then
        drop_point = patrol(p[1]):point(0)
        drop_object = actor
        actor:inventory_for_each(drop_object_item)
    end
end

-- FIXME: drop_npc_inventory doesn't work
function drop_npc_inventory(actor, npc, p)
    if p[1] then
        drop_point = patrol(p[1]):point(0)
        drop_object = npc
        npc:inventory_for_each(drop_object_item)
    end
end

function drop_npc_item(actor, npc, p)
    if p[1] then
        local item = npc:object(p[1])
        if item then
            npc:drop_item(item)
        end
    end
end

function drop_npc_items(actor, npc, p)
    local item = 0
    for i, v in pairs(p) do
        item = npc:object(v)
        if item then
            npc:drop_item(item)
        end
    end
end

function give_item(actor, npc, p)
    if p[1] then
        alife():create(p[1], npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
    end
end

function give_items(actor, npc, p)
    local pos, lv_id, gv_id, npc_id = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
    for i, v in pairs(p) do
        alife():create(v, pos, lv_id, gv_id, npc_id)
    end
end

function respawner_spawn(actor, npc, p)
    if p[1] then
        se_respawn.spawn(p[1])
    end
end

function play_particle_on_path(actor, npc, p)
    local name = p[1]
    local path = p[2]
    local point_prob = p[3]
    if name == nil or path == nil then
        return
    end

    if point_prob == nil then
        point_prob = 100
    end

    local path = patrol(path)
    local count = path:count()
    for a = 0, count - 1, 1 do
        local particle = particles_object(name)
        if math.random(100) <= point_prob then
            particle:play_at_pos(path:point(a))
        end
    end
end

-----------------------------------------------------------------------------
function monster_berserk(actor, npc)
    npc:berserk()
end

function activate_bolt(actor, npc)
    db.actor:activate_slot(5)
end

--[[
send_tip(news_id:sender:sender_id)
    1. news_id
    2. sender*
    3. sender_id*
    * - not necessary
--]]
function send_tip(actor, npc, p)
    news_manager.send_tip(actor, p[1], nil, p[2], nil, p[3])
end

--[[
Дать сталкеру небольшой пинок. Например чтоб скинуть его с возвышения.
параметры: actor, npc, p[direction,bone,power,impulse,reverse=false]
    1. direction - если строка, то считается, что это имя пути и в сторону
        первой точки производится толчек. Если же это число, то оно
        рассматривается как story_id персонажа от которого должен поступить хит.
    2. bone - строка. Имя кости, по которой наносится удар.
    3. power - сила удара
    4. impulse - импульс
    5. reverse (true/false) - изменение направления удара. по умолчанию false
--]]
function hit_npc(actor, npc, p)
    local h = hit()
    local rev = p[5] and p[5] == 'true'
    h.draftsman = npc
    h.type = hit.wound
    if type(p[1]) == 'number' then
        local hitter = level_object_by_sid(p[1])
        if not hitter then
            return
        end
        if rev then
            h.draftsman = hitter
            h.direction = hitter:position():sub(npc:position())
        else
            h.direction = npc:position():sub(hitter:position())
        end
    else
        if rev then
            h.draftsman = nil
            h.direction = npc:position():sub(patrol(p[1]):point(0))
        else
            h.direction = patrol(p[1]):point(0):sub(npc:position())
        end
    end
    h:bone(p[2])
    h.power = p[3]
    h.impulse = p[4]
    npc:hit(h)
end

--[[
Дать обьекту, заданному story_id, хит.
параметры: actor, npc, p[sid,bone,power,impulse,hit_src=npc:position()]
    1. sid - story_id обьекта, по которому наносится хит.
    2. bone - строка. Имя кости, по которой наносится удар.
    3. power - сила удара
    4. impulse - импульс
    5. hit_src - если число, то рассматривается как story_id обьекта, со стороны
        которого наносится хит (он же является и инициатором хита), иначе это
        точка (waypoint), из которой по объекту наносится хит.
        Если не задано, то берется позиция обьекта, из которого была вызвана
        данная функция.
--]]
function hit_obj(actor, npc, p)
    local h = hit()
    local obj = level_object_by_sid(p[1])
    local sid = nil

    if not obj then
        --    abort("HIT_OBJ [%s]. Target object does not exist", npc:name())
        return
    end

    h:bone(p[2])
    h.power = p[3]
    h.impulse = p[4]

    if p[5] then
        sid = tonumber(p[5])
        if sid then
            sid = level_object_by_sid(sid)
            if sid then
                h.direction = vector():sub(sid:position(), obj:position())
            end
        end
        if not sid then
            h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
        end
    else
        h.direction = vector():sub(npc:position(), obj:position())
    end

    h.draftsman = sid or npc
    h.type = hit.wound
    obj:hit(h)
end

--[[
Дать сталкеру небольшой пинок после смерти. Аналогично предыдущему, только направление хита теперь
вычисляется через убийцу. Поэтому параметра direction нет.
параметры: actor, npc, p[bone,power,impulse]
FIXME: killer:position() isn't working
--]]
function hit_by_killer(actor, npc, p)
    if not npc then
        return
    end
    local t = db.storage[npc:id()].death
    if t == nil or t.killer == -1 then
        return
    end
    local killer = db.storage[t.killer]
    if killer == nil then
        return
    end
    local p1, p2
    p1 = npc:position()
    p2 = killer:position()
    local h = hit()
    h.draftsman = npc
    h.type = hit.wound
    h.direction = vector():set(p1):sub(p2)
    h.bone = p[1]
    h.power = p[2]
    h.impulse = p[3]
    npc:hit(h)
end

function set_friends(actor, npc, p)
    local npc1
    for i, v in pairs(p) do
        npc1 = level_object_by_sid(v)
        if npc1 and npc1:alive() then
            npc:set_relation(game_object.friend, npc1)
            npc1:set_relation(game_object.friend, npc)
        end
    end
end

function set_enemies(actor, npc, p)
    local npc1
    for i, v in pairs(p) do
        npc1 = level_object_by_sid(v)
        if npc1 and npc1:alive() then
            npc:set_relation(game_object.enemy, npc1)
            npc1:set_relation(game_object.enemy, npc)
        end
    end
end

-- играть звук в голове актёра
function play_snd(actor, npc, p)
    if p[1] then
        local snd_obj = xr_sound.get_safe_sound_object(p[1])
        -- snd_obj:play(actor, p[2] or 0, sound_object.s2d)
        snd_obj:play_no_feedback(actor, sound_object.s2d, p[2] or 0, vector(), 1.0)
    end
end

-- играть звук от указанного объекта
function play_snd_from_obj(actor, npc, p)
    if p[1] and p[2] then
        local snd_obj = xr_sound.get_safe_sound_object(p[2])
        local obj = level_object_by_sid(p[1])
        if obj ~= nil then

            --    snd_obj:play_at_pos(obj, obj:position(), sound_object.s3d)
            snd_obj:play_no_feedback(obj, sound_object.s3d, 0, obj:position(), 1.0)
        end
    end
end

-- играть звук от указанного объекта
function play_snd_now(actor, npc, p)
    xr_sound.set_sound_play(npc, p[1])
end

-- прибавить к указанному счётчику актёра 1
function inc_counter(actor, npc, p)
    if p[1] then
        xr_logic.pstor_store(actor, p[1], xr_logic.pstor_retrieve(actor, p[1], 0) + 1)
    end
end

function dec_counter(actor, npc, p)
    if p[1] then
        xr_logic.pstor_store(actor, p[1], xr_logic.pstor_retrieve(actor, p[1], 0) - 1)
    end
end

-- переключает камеру на монстра или на актёра
function alien_control(actor, npc, p)
    npc:set_alien_control(p[1] == "true")
end

-- слелать актёра врагом персонажам, которые в онлайне под указанным смартом
function set_gulag_enemy_actor(actor, npc, p)
    if p[1] then
        xr_gulag.setGulagEnemy(p[1], actor)
    end
end

-- принудительное обновление смарта. Использовать только в КРАЙНИХ случаях!!!
-- каждое использование согласовывать со мной. Чугай.
function smart_terrain_force_update(actor, npc, p)

    if p[1] then
        local gulag = xr_gulag.get_gulag(p[1])

        if gulag then
            gulag.smrttrn:update()
        end
    end
end

------------------------------------------------------------------------------------------------------------------------

-- постпроцесс и влияние удара в морду
function actor_punch(npc)
    if db.actor:position():distance_to_sqr(npc:position()) > 4 then
        return
    end

    local active_slot = db.actor:active_slot()
    if active_slot ~= 1 and active_slot ~= 2 then
        return
    end

    local active_item = db.actor:active_item()
    if active_item then
        db.actor:drop_item(active_item)
    end

    set_inactivate_input_time(30)
    local snd_obj = xr_sound.get_safe_sound_object([[affects\hit_fist]])
    snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)

    level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")
end

-- Принудительное усыпание игрока на радаре.
function force_actor_sleep(npc)
    db.actor:actor_sleep(24, 0)
end

-- забывание обиды
function clearAbuse(npc)
    xr_abuse.clear_abuse(npc)
end

---Выключение динамической лампочки (hanging_lamp)
function turn_off(actor, npc, p)
    local obj = level_object_by_sid(p[1])

    if not obj then
        abort("TURN_OFF [%s]. Target object does not exist", npc:name())
        return
    end
    obj:get_hanging_lamp():turn_off()
end
function turn_off_object(actor, npc)
    npc:get_hanging_lamp():turn_off()
end

---Включение динамической лампочки (hanging_lamp)
function turn_on(actor, npc, p)
    local obj = level_object_by_sid(p[1])

    if not obj then
        abort("TURN_ON [%s]. Target object does not exist", npc:name())
        return
    end
    obj:get_hanging_lamp():turn_on()
end
function turn_on_object(actor, npc)
    npc:get_hanging_lamp():turn_on()
end


-- ' Escape
function play_snd_from_radio(actor, npc)
    local snd_obj = xr_sound.get_safe_sound_object([[characters_voice\scenario\escape\wolf_to_rangers_1]])
    local obj = npc:object("hand_radio")
    snd_obj:play_no_feedback(obj, sound_object.s3d, 0, obj:position(), 1.0)
end

function gar_mapspot_blockpost(actor, npc)
    level_tasks.add_location(115, "green_location", "gar_dolg_blokpost_leader_name")
end

function actor_friend(actor, npc)
    npc:set_relation(game_object.friend, actor)
end

function actor_neutral(actor, npc)
    npc:set_relation(game_object.neutral, actor)
end

function actor_enemy(actor, npc)
    npc:set_relation(game_object.enemy, actor)
end

function give_all_quests(actor, npc)
    -- bar_dialogs.quests()
end

function give_rostok_quests(actor, npc)
    bar_dialogs.rostok_quests()
end

-- Вызов этой функции отключит обработчик [combat] боя для персонажа.
-- Используется в случаях, когда все необходимые действия, такие как переключение на другую секцию,
-- уже выполнены, и повторно выполнять их во время боя нельзя (а условия секции [combat] проверяются на каждом
-- апдейте, когда персонаж в бою, если, конечно, не отключены вызовом этой функции).
function disable_combat_handler(actor, npc)
    if db.storage[npc:id()].combat then
        db.storage[npc:id()].combat.enabled = false
    end

    if db.storage[npc:id()].mob_combat then
        db.storage[npc:id()].mob_combat.enabled = false
    end
end

-- Вызов этой функции отключит обработчик [combat_ignore] перехвата боя для персонажа.
function disable_combat_ignore_handler(actor, npc)
    if db.storage[npc:id()].combat_ignore then
        db.storage[npc:id()].combat_ignore.enabled = false
    end
end

function log_bp1(actor, npc)
end

function psi_hit_npc(actor, npc, p)
end

function mil_paul_frost_dead(actor, npc)
    local gulag = xr_gulag.get_gulag_by_name("mil_freedom")
    if (gulag) then
        gulag:set_relation(game_object.neutral, actor)
    end
end

function set_freedom_actor_enemy(actor, npc)
    local luk = level_object_by_sid(707)
    this.actor_enemy(actor, luk)
end

function search_gulag_job(actor, npc)
    xr_gulag.resetJob(npc)
end

function esc_hit_from_fox(actor, npc)
    local fox = level_object_by_sid(005)
    if fox == nil then
        return
    end
    local h = hit()
    h.power = 0.01
    h.direction = npc:direction()
    h.draftsman = fox
    h.impulse = 1
    h.type = hit.wound
    npc:hit(h)
end

function bar_actor_enemy_set(actor, npc)
    local dog = level_object_by_sid(509)
    if dog ~= nil then
        dog:set_relation(game_object.enemy, db.actor)
    end
end

local function transfer_object_item(item)
    out_object:transfer_item(item, in_object)
end

function mil_actor_enemy_set(actor, npc)
    local sniper = level_object_by_sid(704)
    if sniper ~= nil then
        sniper:set_relation(game_object.enemy, db.actor)
    end
    -- xr_gulag.setGulagRelation ("mil_freedom", game_object.enemy, db.actor)    
end

function mil_actor_enemy_reset(actor, npc)
    local sniper = level_object_by_sid(704)
    if sniper ~= nil then
        sniper:set_relation(game_object.neutral, db.actor)
    end
    -- xr_gulag.setGulagRelation ("mil_freedom", game_object.neutral, db.actor)    
end

function mil_bomb_explode(actor, npc)
    local source = nil
    local sim = alife()
    if sim then
        local se_obj = sim:story_object(723)
        if se_obj then
            source = level.object_by_id(se_obj.id)
        end
    end

    if source == nil then
        -- 'abort ("Bomb with story id MIL_BOMB not found")
        return
    end

    local h = hit();
    h.power = 1000000;
    h.direction = vector():set(1, 0, 0);
    h.impulse = 1;
    h.draftsman = source;
    h.type = hit.chemical_burn;
    source:hit(h);

    source:explode(0)
end

function sar2_monolith_explode(actor, npc)
    local monolith = level_object_by_sid(1305)
    if monolith == nil then
        abort("Object MONOLITH with SID 1305 not found")
    end
    local h = hit();
    h.power = 1000;
    h.direction = vector():set(1, 0, 0);
    h.impulse = 1;
    h.draftsman = actor;
    h.type = hit.chemical_burn;
    monolith:hit(h);
end

function set_stalker_enemy(sid, draftsman)
    local npc = level_object_by_sid(sid)
    if npc == nil or npc:alive() == false then
        return
    end
    local h = hit()
    h.power = 0
    h.direction = vector():set(1, 0, 0)
    h.impulse = 0
    h.draftsman = draftsman
    h.type = hit.strike
    npc:hit(h)
end

function mil_remove_cook_map_spot(actor, npc)
    level_tasks.remove_location(728, "mil_cook_location")
end

function set_actor_enemy_for_freedom(actor, npc)
    xr_gulag.setGulagEnemy("mil_freedom", actor)
end

-- GARBAGE

function gar_send_dolg_warning()
    if db.actor then
        if xr_gulag.getGulagPopulation("gar_dolg") > 0 then
            news_manager.send_tip(db.actor, "gar_dolg_warning", 0, "dolg")
        end
    end
end

-------------------------------------------------------------------------------------
-- kill
-------------------------------------------------------------------------------------
function killactor(actor, npc)
    npc:set_relation(game_object.enemy, actor)
end

function kill(actor, npc)
    npc:kill(npc)
end

-------------------------------------------------------------------------------------
-- Функции для Агропрома
-------------------------------------------------------------------------------------
function agr_contuz(actor, npc)
    local sound_obj_l = xr_sound.get_safe_sound_object([[affects\psy_blackout_l]])
    local sound_obj_r = xr_sound.get_safe_sound_object([[affects\psy_blackout_r]])

    sound_obj_l:play_no_feedback(actor, sound_object.s2d, 0, vector():set(-1, 0, 1), 1.0)
    sound_obj_r:play_no_feedback(actor, sound_object.s2d, 0, vector():set(1, 0, 1), 1.0)
end

function agr_cam_effect()
    level.add_cam_effector2("camera_effects\\agroprom_doctor_cam.anm", 123, false, "")
end

function agr_weapon(actor, npc)
    local actor = db.actor
    if actor ~= nil then
        actor:activate_slot(2)
    end
end

--------------------------------------------------------- 
-- PRIPYAT
--------------------------------------------------------- 
function pri_drop_rpg_ammo(actor, npc)
    local item = npc:object("ammo_og-7b")
    if item then
        npc:drop_item(item)
    end
end

function pri_give_ammo_og7b(actor, npc)
    alife():create("ammo_og-7b", npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
    alife():create("ammo_og-7b", npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
end

-------------------------------------------------------------------------------------
-- Функции для работы с вертолётами
-------------------------------------------------------------------------------------

function heli_set_enemy_actor(actor, npc)
    local st = db.storage[npc:id()]
    if not st.combat.enemy_id and actor:alive() then
        st.combat.enemy_id = actor:id()

        heli_snd.play_snd(st, heli_snd.snd_see_enemy, 1)
    end
end

function heli_set_enemy(actor, npc, p)
    local st = db.storage[npc:id()]
    local obj = level_object_by_sid(p[1])

    if not st.combat.enemy_id and obj:alive() then
        st.combat.enemy_id = obj:id()

        heli_snd.play_snd(st, heli_snd.snd_see_enemy, 1)
    end
end

function heli_clear_enemy(actor, npc)
    db.storage[npc:id()].combat:forget_enemy()
end

function heli_start_flame(actor, npc)
    bind_heli.heli_start_flame(npc)
end

function heli_die(actor, npc)
    bind_heli.heli_die(npc)
end

-------------------------------------------------------------------------------------
-- Функции для работы с погодными эффектами
-------------------------------------------------------------------------------------
function start_small_reject(actor, npc)
    level.set_weather_fx("fx_blowout_day")
    level.add_pp_effector("vibros_p.ppe", 1974, false)
    this.aes_earthshake(npc)
end

function start_full_reject(actor, npc)
    level.set_weather_fx("fx_blowout_day")
    level.remove_pp_effector(1974)
    level.add_pp_effector("vibros.ppe", 1974, false)
end

function aes_grenade_explode(actor, npc)
    local obj = level_object_by_sid(1101)
    if obj == nil then
        return
    end
    local h = hit();
    h.power = 1000;
    h.direction = vector():set(1, 0, 0);
    h.impulse = 1;
    h.draftsman = obj;
    h.type = hit.chemical_burn;
    obj:hit(h);
end

function aes_kill_actor(actor, npc)
    if actor ~= nil and actor.health > 0 then
        actor:kill(actor)
    end
end

function set_sidorovich_animation(npc)
    local sidor = level_object_by_sid(1118)
    if sidor == nil then
        abort("SIDOROVICH NOT FOUND !!!")
    end
    -- sidor:clear_animations ()
    sidor:play_cycle("wonder", true)
    -- sidor:add_animation ("idle_looped")
end

function aes_zombie_hit1(npc)
    -- local npc = level_object_by_sid (1119)
    -- local force = vector ():set (0, 0, 0.02)
    -- local pshell = npc:get_physics_shell ()

    -- local joint = pshell:get_joint_by_bone_name ("head2")
    -- joint:set_max_force_and_velocity (0.5 + math.random (), 0.1 * -1, 0)
    -- joint:set_max_force_and_velocity (0.5 + math.random(), 0.1 * -1,  2)

    -- local npc = level_object_by_sid (1119)
    -- local force = vector ():set (0, 0, 50)
    -- local pshell = npc:get_physics_shell ()
    -- local element = pshell:get_element_by_bone_name ("foot_right")
    -- element:apply_force (force.x, force.y, force.z)

    -- foot_right, foot_left, left_hand, right_hand

    -- local dir = npc:direction ()
    -- dir.y = 0.0
    -- dir:normalize ()
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1120)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1121)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1122)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1123)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)
end

function aes_zombie_hit2(npc)
    -- local npc = level_object_by_sid (1119)
    -- local force = vector ():set (0, 0, 50)
    -- local pshell = npc:get_physics_shell ()
    -- local element = pshell:get_element_by_bone_name ("foot_right")
    -- element:apply_force (force.x, force.y, force.z)

    -- local npc = level_object_by_sid (1119)
    -- local force = vector ():set (0, 0, 0.02)
    -- local pshell = npc:get_physics_shell ()

    -- local joint = pshell:get_joint_by_bone_name ("head2")
    -- joint:set_max_force_and_velocity (0.5 + math.random (), 0.1 * 1, 0)
    -- joint:set_max_force_and_velocity (0.5 + math.random(), 0.1 * 1,  2)
    -- self.dir_x_axis  = self.dir_x_axis * (-1)
    -- self.dir_z_axis = self.dir_z_axis * (-1)
    -- self.time    = device():time_global() + math.random(800, 1000)
    -- end

    -- local element = pshell:get_element_by_bone_name ("foot_right")
    -- element:apply_force (force.x, force.y, force.z)
    -- local npc = level_object_by_sid (1119)
    -- local dir = npc:direction ()
    -- dir.y = 0.0
    -- dir.x = -dir.x
    -- dir.z = -dir.z
    -- dir:normalize ()
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1120)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir.x = -dir.x
    -- dir.z = -dir.z
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1121)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir.x = -dir.x
    -- dir.z = -dir.z
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1122)
    -- dir = npc:direction ()
    -- dir.y = 0.0
    -- dir.x = -dir.x
    -- dir.z = -dir.z
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)

    -- npc = level_object_by_sid (1123)
    -- dir = npc:direction ()
    -- dir.x = -dir.x
    -- dir.z = -dir.z
    -- dir.y = 0.0
    -- dir:normalize ()   
    -- npc:set_const_force (dir, 2000, 3)
end

-- постпроцесс и влияние удара в морду
function aes_earthshake(npc)
    local snd_obj = xr_sound.get_safe_sound_object([[ambient\earthquake]])
    snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
    level.add_cam_effector("camera_effects\\earthquake.anm", 1974, false, "")
    -- set_postprocess ("scripts\\earthshake.ltx")
end

function vovan_camera_test(npc)
    level.add_cam_effector("camera_effects\\test.anm", "")
end
-------------------------------------------------------------------------------------
-- Функции для Янтаря
----------------------------------------------------------------------------------
function yan_actor_sleep(actor, npc)
    db.actor:set_actor_position(patrol("yan_actor_sleep"):point(0))
    local dir = patrol("yan_actor_sleep"):point(1):sub(patrol("yan_actor_sleep"):point(0))
    db.actor:set_actor_direction(-dir:getH())
end

function yan_actor_sleep_1(actor, npc)
    db.actor:set_actor_position(patrol("yan_actor_sleep_1"):point(0))
    local dir = patrol("yan_actor_sleep_1"):point(1):sub(patrol("yan_actor_sleep_1"):point(0))
    db.actor:set_actor_direction(-dir:getH())
end

function yan_dream_voices(actor, npc)
    local sound_obj_l = xr_sound.get_safe_sound_object([[characters_voice\scenario\yantar\dream_talk_l]])
    local sound_obj_r = xr_sound.get_safe_sound_object([[characters_voice\scenario\yantar\dream_talk_r]])

    sound_obj_l:play_no_feedback(actor, sound_object.s2d, 0, vector():set(-1, 0, 1), 1.0)
    sound_obj_r:play_no_feedback(actor, sound_object.s2d, 0, vector():set(1, 0, 1), 1.0)
end

function yan_gluk(actor, npc)

    local sound_obj_l = xr_sound.get_safe_sound_object([[affects\psy_blackout_l]])
    local sound_obj_r = xr_sound.get_safe_sound_object([[affects\psy_blackout_r]])

    sound_obj_l:play_no_feedback(actor, sound_object.s2d, 0, vector():set(-1, 0, 1), 1.0)
    sound_obj_r:play_no_feedback(actor, sound_object.s2d, 0, vector():set(1, 0, 1), 1.0)
    level.add_cam_effector("camera_effects\\earthquake.anm", 1974, false, "")

end
function x18_gluk(actor, npc)
    level.add_pp_effector("blink.ppe", 234, false)
    local sound_obj_l = xr_sound.get_safe_sound_object([[affects\psy_blackout_l]])
    local sound_obj_r = xr_sound.get_safe_sound_object([[affects\psy_blackout_r]])
    local snd_obj = xr_sound.get_safe_sound_object([[affects\tinnitus3a]])
    snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
    sound_obj_l:play_no_feedback(actor, sound_object.s2d, 0, vector():set(-1, 0, 1), 1.0)
    sound_obj_r:play_no_feedback(actor, sound_object.s2d, 0, vector():set(1, 0, 1), 1.0)
    level.add_cam_effector("camera_effects\\earthquake.anm", 1974, false, "")

end

-----------------------------radar
function rad_sos_spam(actor, npc)
    news_manager.send_tip(actor, "tips_rad_sos_suicide", nil, "stalker", nil, 1004)
end

function monolith_generator_hit(actor, npc)
end

function aes_final_movie(actor, npc)
    game.start_tutorial("mov_refuse_osoznanie")
end

------------------------------------------------------------------------------------
-- Функции для саркофага
------------------------------------------------------------------------------------
function destroy_monolith_generator(actor, npc)
    local source = nil
    local sim = alife()
    if sim then
        local se_obj = sim:story_object(1305)
        if se_obj then
            source = level.object_by_id(se_obj.id)
        end
    end

    if source == nil then
        abort("MONOLITH GENERATOR story id 1305 not found")
        return
    end

    local h = hit();
    h.power = 1000000;
    h.direction = vector():set(1, 0, 0);
    h.impulse = 1;
    h.draftsman = source;
    h.type = hit.chemical_burn;
    source:hit(h);
end

function sar_monolith_miracle(actor, npc)
    -- ' Много денег
    if db.actor:money() >= 50000 then
        game.start_tutorial("mov_desire_2")
        return
    end

    -- ' Хорошая репутация
    if db.actor:character_reputation() >= 1000 then
        game.start_tutorial("mov_desire_1")
        return
    end

    -- ' плохая репутация
    if db.actor:character_reputation() <= -1000 then
        game.start_tutorial("mov_desire_4")
        return
    end

    game.start_tutorial("mov_desire_5")
end

function game_credits(actor, npc)
    db.gameover_credits_started = true
    game.start_tutorial("credits_seq")
end

function game_over(actor, npc)
    if db.gameover_credits_started ~= true then
        return
    end
    cmd("main_menu on")
end

function after_credits(actor, npc)
    if db.gameover_credits_started ~= true then
        return
    end
    cmd("disconnect")
end

function pri_game_over(actor, npc)
    cmd("main_menu on")
end

function esc_init_dialod()
    local trader = level_object_by_sid(003)
    db.actor:run_talk_dialog(trader)
end

function oso_init_dialod()
    -- local oso = level_object_by_sid(1307)
    -- db.actor:run_talk_dialog(oso)
end

function on_tutor_gameover_stop()
    ui_death.death_screen()
end

-- // ускоряет время  - вызов из рестриктора
function SetSpeedTime()
    level.set_time_factor(2000)
end

function make_invulnerable(actor, npc)
    npc:invulnerable(true)
end

function unmake_invulnerable(actor, npc)
    npc:invulnerable(false)
end
