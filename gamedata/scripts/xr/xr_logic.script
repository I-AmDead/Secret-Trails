
----------------------------------------------------------------------------------------------------
-- Script switching logic
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------
--[[

----------------------------------------------------------------------------------------------------
-- ФУНКЦИИ, КОТОРЫЕ РАЗРЕШЕНО ВЫЗЫВАТЬ ИЗ ДРУГИХ СКРИПТОВ
----------------------------------------------------------------------------------------------------
	Активация схем производится с помощью функций:

function gulag_activate(npc, ini, section, gulag_name, death, combat, actor_dialogs, trade, hit)
Предназначение:
	активирует заданную схему, используется схемой гулаг. Тип скрипта определяется автоматически по имени секции.
Здесь:
	npc - персонаж, для которого будет активирована схема
	ini - его customdata
	section - имя секции, которая должна быть активирована
	gulag_name - имя гулага, которое будет добавлено спереди к именам путей
	death, combat, actor_dialogs, trade, hit - имена секций, задающих поведение при смерти и в бою

function assign_storage_and_bind(npc, ini, scheme, section)
Предназначение:
	Вызывает функцию add_to_binder схемы, а также создает (если его еще нет) и возвращает ссылку на storage
	для схемы. Примечание: в storage при этом могут оставаться старые данные, схема должна очистить его
	самостоятельно.

function subscribe_action_for_events(npc, storage, new_action)
Предназначение:
	Регистрирует класс для получения нотификаций о таких событиях как сброс схемы, сохранение и т.д.
	Класс реализует соответствующие функции (reset_scheme() и т.д.), которые будут вызываться из xr_logic
	в нужные моменты.

function pick_section_from_condlist(actor, npc, condlist)
Предназначение:
	Проверяет условия condlist, и если они успешны - ставит указанные infoportions и возвращает текст.
	Если условия не выполняются - возвращает nil.

function try_switch_to_another_section(npc, st, actor)
Предназчанение:
	Используя настройки xr_logic из storage персонажа, пытается переключить его на другую схему, если
	хоть одно из условий переключения сработало. Обычно вызывается из метода update класса персонажа.

function is_active(npc, st)
Предназначение:
	Вызывается из evaluator-а (или в самом начале update у предметов и монстров) для проверки, что данная
	схема сейчас активна (схема определяется по данным в storage).

function cfg_get_switch_conditions(ini, section, npc)
Предназначение:
	Считывает все возможные условия переключения схем.

function parse_condlist(npc, section, field, src)
Предназначение:
	Распарсивает условия вида: {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ... в таблицу.
	Параметры section и field используются только в сообщениях об ошибках. Если строка src считана не из файла,
	а передается в эту функцию гулагом, то нужно задать следующие параметры:
--]] --		section = "[[[gulag_tasks.script]]]"
--		field = "[[[gulag_name=имя_гулага]]]"
--[[
----------------------------------------------------------------------------------------------------
-- ПРИВАТНЫЕ ФУНКЦИИ
----------------------------------------------------------------------------------------------------

function activate_by_section(npc, ini, section, loading)
Предназначение:
	Активирует указанную секцию. Если в данный момент какая-либо секция уже активирована, сообщает об ошибке.

function switch_to_section(npc, st, section)
Предназначение:
	Выполняет переключение с одной секции на другую, если новая секция не nil. Если же она nil, остается
	активной старая секция.

function abort_syntax_error_in_cond(npc, section, field)
Предназначение:
	Сообщает о синтаксической ошибке в условиях переключения схем секции section и поля field, и останавливает
	игру.

function parse_infop(rslt, str)
Предназначение:
	Распарсивает условия вида " +infop1 =func -infop2 " и т.д. (все не перечислены) в таблицу.

function cfg_get_number_and_condlist(ini, section, field, npc)
function cfg_get_string_and_condlist(ini, section, field, npc)
function cfg_get_condlist(ini, section, field, npc)
Предназначение:
	Считывает из customdata различные условия переключения схем.

function add_condition(lst, at, cond)
Предназначение:
	Добавляет условие в список условий переключения схем.

function cfg_get_overrides(ini, section, npc)
Предназначение:
	Считывает настройки для схем общего поведения.

function generic_scheme_overrides(npc)
Предназначение:
	Возвращает ссылку на настройки схем общего поведения, актуальные для работающей в данный момент схемы,
	либо nil, если ни одна из секций не активна, либо настройки не заданы.

--]] 

--[[
-- Предназначение:
--      вызывается при включении набора скриптов через секцию logic у персонажа. Если в секции logic присутствует только
--      поле cfg, использует конфигурационный файл, заданный в этом поле, и возвращает новый ini file.
-- Здесь:
--	npc - персонаж, для которого будет активирована схема
--	ini - его customdata
--	stype - тип скрипта. Поскольку имя секции все еще неизвестно, его нужно задавать явно. Допустимые значения
--	        перечислены в файле modules.script.
--	section - имя секции logic
--	gulag_name - имя гулага, если скрипт включается гулагом, а не биндером
--]] 
function configure_schemes(npc, ini, ini_filename, stype, section_logic, gulag_name)
    -- log3( "xr_logic.configure_schemes: [%s]: ini_filename = [%s], section_logic = [%s], gulag_name = [%s]", npc:name(), tostring(ini_filename), tostring(section_logic), tostring(gulag_name) )
    local npc_id = npc:id()
    local st = db.storage[npc_id]

    if not st then
        db.storage[npc_id] = {}
        st = db.storage[npc_id]
    end

    -- если какая-то схема была до этого активна, деактивировать её
    if st.active_section then
        issue_event(npc, st[st.active_scheme], "deactivate", npc)
    end

    local actual_ini, actual_ini_filename
    if not ini:section_exist(section_logic) then
        if not gulag_name then
            -- Общие схемы должны работать и без logic:
            actual_ini_filename = ini_filename
            actual_ini = ini -- персонаж не обязательно должен иметь секцию logic
        else
            -- Иначе это персонаж Gulag-а и ему не задали работу:
            abort("ERROR: object '%s': unable to find section '%s'", npc:name(), section_logic)
        end
    else
        local filename = get_string(section_logic, "cfg", nil, ini)
        if filename then
            -- Рекурсивно обработать конфигурационный файл, на который ссылается поле cfg
            actual_ini_filename = filename
            actual_ini = ini_file(filename)
            return configure_schemes(npc, actual_ini, actual_ini_filename, stype, section_logic, gulag_name)
            --[[
			if actual_ini:line_count(section_logic) == 0 then
				abort("file '%s' does not exist or is empty, or has no section '%s'",
					filename, section_logic)
			end
			--]]
        else
            actual_ini_filename = ini_filename
            actual_ini = ini
        end
    end

    -- Поскольку в момент активации схемы могли работать ранее установленные общие схемы, нужно их все отключить:
    disable_generic_schemes(npc, stype)
    -- Включаем все общие схемы (раненный, коллбек на попадание и т.д.):
    enable_generic_schemes(actual_ini, npc, stype, section_logic)

    -- Инициализация торговли
    if stype == modules.stype_stalker or npc:clsid() == clsid.script_trader then
        local trade_ini = get_string(section_logic, "trade", "misc\\trade\\trade_generic.ltx", actual_ini)
        trade_manager.trade_init(npc, trade_ini)
    end

    st.active_section = nil
    st.active_scheme = nil
    if gulag_name then
        st.gulag_name = gulag_name
    else
        st.gulag_name = ""
    end
    st.stype = stype
    st.ini = actual_ini
    st.ini_filename = actual_ini_filename
    st.section_logic = section_logic

    return st.ini
end

-- Вызывается биндером с целью определить первую активную схему
function determine_section_to_activate(npc, ini, section_logic, actor)
    if not ini:section_exist(section_logic) then
        return "nil"
    end

    -- Распарсить строку выбора активной секции с учетом команд, заключенных в %%
    local active_section_cond = cfg_get_condlist(ini, section_logic, "active", npc)
    local active_section
    if not active_section_cond then
        return "nil"
    else
        active_section = pick_section_from_condlist(actor, npc, active_section_cond.condlist)
        if not active_section then
            return "nil"
        end
    end
    if active_section and db.storage[npc:id()].stype and db.storage[npc:id()].stype <= 1 and db.storage[npc:id()].stype ~=
        stypes[utils.get_scheme_by_section(active_section)] then
        -- Блокируем активацию схемы для зверушек в человеческих гулагах. Dirty Hack.
        return "nil"
    else
        return active_section
    end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В enable_generic_schemes
------------------------------------------------------------------------------------------------------------
function disable_generic_schemes(npc, stype)
    if stype == modules.stype_stalker then
        xr_combat.disable_scheme(npc, "combat")
        if rx_ai then
            rx_ai.disable_schemes(npc)
        end
        xr_use.disable_scheme(npc, "use")
        xr_hit.disable_scheme(npc, "hit")
        xr_meet.disable_scheme(npc, "actor_dialogs")
        xr_heli_hunter.disable_scheme(npc, "heli_hunter")
        xr_combat_ignore.disable_scheme(npc, "combat_ignore")
    elseif stype == modules.stype_mobile then
        mob_combat.disable_scheme(npc, "mob_combat")
        mob_trade.disable_scheme(npc, "mob_trade")
    elseif stype == modules.stype_item then
        ph_on_hit.disable_scheme(npc, "ph_on_hit")
    elseif stype == modules.stype_heli then
        xr_hit.disable_scheme(npc, "hit")
    end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В disable_generic_schemes
------------------------------------------------------------------------------------------------------------
function enable_generic_schemes(ini, npc, stype, section)
    if stype == modules.stype_stalker then
        if blowout_scheme then
            blowout_scheme.set_hide(npc, ini, "blowout_scheme", section)
        end

        xr_danger.set_danger(npc, ini, "danger", "danger")

        local combat_section = get_string(section, "on_combat", nil, ini)
        xr_combat.set_combat_checker(npc, ini, "combat", combat_section)

        local use_section = get_string(section, "on_use", nil, ini)
        if use_section then
            xr_use.set_use_checker(npc, ini, "use", use_section)
        end

        local info_section = get_string(section, "info", nil, ini)
        if info_section then
            stalker_generic.set_npc_info(npc, ini, "info", info_section)
        end

        local hit_section = get_string(section, "on_hit", nil, ini)
        if hit_section then
            xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
        end

        local actor_dialogs_section = get_string(section, "actor_dialogs", nil, ini)
        if actor_dialogs_section then
            xr_meet.set_actor_dialogs(npc, ini, "actor_dialogs", actor_dialogs_section)
        end

        local wounded_section = get_string(section, "wounded", nil, ini)
        xr_wounded.set_wounded(npc, ini, "wounded", wounded_section)

        xr_abuse.set_abuse(npc, ini, "abuse", section)

        local meet_section = get_string(section, "meet", nil, ini)
        xr_meet.set_meet(npc, ini, "meet", meet_section)

        local death_section = get_string(section, "on_death", nil, ini)
        xr_death.set_death(npc, ini, "death", death_section)

        local heli_hunter_section = get_string(section, "heli_hunter", nil, ini)
        xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", heli_hunter_section)

        local combat_ignore_section = get_string(section, "combat_ignore", nil, ini)
        if combat_ignore_section then
            xr_combat_ignore.set_combat_ignore_checker(npc, ini, "combat_ignore", combat_ignore_section)
        end

        if rx_ai then
            rx_ai.enable_schemes(ini, npc, section)
        end

    elseif stype == modules.stype_mobile then
        local combat_section = get_string(section, "on_combat", nil, ini)
        if combat_section then
            mob_combat.set_scheme(npc, ini, "mob_combat", combat_section)
        end

        local death_section = get_string(section, "on_death", nil, ini)
        mob_death.set_scheme(npc, ini, "mob_death", death_section)

        local trade_section = get_string(section, "on_trade", nil, ini)
        if trade_section then
            mob_trade.set_scheme(npc, ini, "mob_trade", trade_section)
        end

        local hit_section = get_string(section, "on_hit", nil, ini)
        if hit_section then
            xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
        end

        mob_panic.set_scheme(npc, ini, "mob_panic")

    elseif stype == modules.stype_item then
        local hit_section = get_string(section, "on_hit", nil, ini)
        if hit_section then
            ph_on_hit.set_scheme(npc, ini, "ph_on_hit", hit_section)
        end

    elseif stype == modules.stype_heli then
        local hit_section = get_string(section, "on_hit", nil, ini)
        if hit_section then
            xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
        end
    end
end

function activate_by_section(npc, ini, section, loading)
    -- log3("DEBUG: object '%s': activate_by_section: looking for section '%s'", npc:name(), section)

    if loading == nil then
        abort("xr_logic: activate_by_section: loading field is nil, true or false expected")
    end

    local npc_id = npc:id()
    if db.storage[npc_id].active_section then
        abort("xr_logic: activate_by_section: while processing section '%s': character '%s': trying to " ..
                  "activate more than one schemes at once (section '%s' is active)", section, npc:name(),
            db.storage[npc_id].active_section)
    end

    if not loading then
        db.storage[npc_id].activation_time = time_global()
        -- GAMETIME added by Stohe.
        db.storage[npc_id].activation_game_time = game.get_game_time()
    end

    if not section or not ini:section_exist(section) then
        if not ini:section_exist(section) and section ~= "nil" then -- такое может быть если сбросить нпс логику, к примеру вылечить врага.
            log3("~~[%s] section [%s] not found in logic of object [%s]", script_name(), section, npc:name())
        end
        section = "nil"
    end

    if section == "nil" then
        db.storage[npc_id].overrides = nil
        reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
        db.storage[npc_id].active_section = nil
        db.storage[npc_id].active_scheme = nil
        return
    end

    if ini:section_exist(section) then
        local scheme = utils.get_scheme_by_section(section)
        if scheme == nil then
            abort("object '%s': unable to determine scheme name from section name '%s'", npc:name(), section)
        end

        -- schemes[scheme] даст имя файла (модуля), в котором реализована схема
        local filename = schemes[scheme]
        if filename == nil then
            log3("!!xr_logic: scheme %s is not registered in modules.script", scheme)
            return
        end

        -- Загрузить оверрайды:
        db.storage[npc_id].overrides = cfg_get_overrides(ini, section, npc)

        -- Сбросить общие схемы:
        reset_generic_schemes_on_scheme_switch(npc, scheme, section)

        -- _G[] даст указатель на неймспейс (таблицу) этого модуля
        if not _G[filename] then
            abort("xr_logic: can't call %s.set_scheme() - a nil value", filename)
        end
        _G[filename].set_scheme(npc, ini, scheme, section, db.storage[npc_id]["gulag_name"])
        db.storage[npc_id].active_section = section
        db.storage[npc_id].active_scheme = scheme

        if db.storage[npc_id].stype == modules.stype_stalker then
            -- чтобы избежать дальнейшего движения по пути при установке рестрикторов
            utils.send_to_nearest_accessible_vertex(npc, npc:level_vertex_id())

            issue_event(npc, db.storage[npc_id][scheme], "activate_scheme", loading, npc)
        else
            issue_event(npc, db.storage[npc_id][scheme], "reset_scheme", loading, npc)
        end
    end
end

--[[
-- Предназначение:
--	Производит сброс состояния объекта (снимает коллбеки, отключает разговор) непосредственно перед включением
--	новой схемы.
--]]
function reset_generic_schemes_on_scheme_switch(npc, scheme, section)
    local st = db.storage[npc:id()]

    if not st.stype then
        return
    end

    if st.stype == modules.stype_stalker then
        xr_meet.dialog_manager_reset(npc, st.stype)
        xr_meet.reset_meet(npc, scheme, st, section)
        xr_abuse.reset_abuse(npc, scheme, st, section)
        xr_wounded.reset_wounded(npc, scheme, st, section)
        xr_death.reset_death(npc, scheme, st, section)
        xr_danger.reset_danger(npc, scheme, st, section)
        stalker_generic.reset_threshold(npc, scheme, st, section)
        stalker_generic.reset_show_spot(npc, scheme, st, section)

        if rx_ai then
            rx_ai.reset_schemes(npc, scheme, st, section)
        end
    elseif st.stype == modules.stype_mobile then
        xr_meet.dialog_manager_reset(npc, st.stype)
        mob_release(npc)
        if get_clsid(npc) == clsid.bloodsucker_s then
            npc:set_manual_invisibility(scheme ~= "nil")
        end
        mob_panic.reset_panic(npc, scheme, st, section)

    elseif st.stype == modules.stype_item then
        local is_light = npc:is_lamp() or npc:is_projector()
        if not is_light then
            npc:set_callback(callback.use_object, nil)
        end
        npc:set_nonscript_usable(true)
        if get_clsid(npc) == clsid.car then
            -- Другие объекты под скрипт не берутся, поэтому для них не надо сбрасывать
            npc:destroy_car()
            mob_release(npc)
        end
    end
end

function assign_storage_and_bind(npc, ini, scheme, section)
    local npc_id = npc:id()
    local st

    if not db.storage[npc_id][scheme] then
        db.storage[npc_id][scheme] = {}
        st = db.storage[npc_id][scheme]

        st["npc"] = npc

        -- Схема стартует впервые - прибиндить
        _G[schemes[scheme]].add_to_binder(npc, ini, scheme, section, st)
    else
        st = db.storage[npc_id][scheme]
    end

    st["scheme"] = scheme
    st["section"] = section
    st["ini"] = ini

    return st
end

function subscribe_action_for_events(npc, storage, new_action)

    if not storage.actions then
        storage.actions = {}
    end

    storage.actions[new_action] = true
end

function unsubscribe_action_from_events(npc, storage, new_action)
    if not storage.actions then
        storage.actions = {}
    end

    storage.actions[new_action] = nil
end

-- st - storage активной схемы
function issue_event(npc, st, event_fn, ...)
    if not st or not st.actions then
        return
    end
    local activation_count = 0
    local action_ptr, is_active = 0, 0
    for action_ptr, is_active in pairs(st.actions) do
        if is_active and action_ptr[event_fn] then
            action_ptr[event_fn](action_ptr, ...)
            activation_count = activation_count + 1
        end
    end
end

function pick_section_from_condlist(actor, npc, condlist)
    if type(condlist) ~= "table" then
        return nil
    end

    for n, cond in pairs(condlist) do
        local infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены

        for inum, infop in pairs(cond.infop_check) do
            if infop.prob then
                if infop.prob < math.random(100) then
                    infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
                    break
                end
            elseif infop.func then
                -- log2( "_bp: infop.func = %s", infop.fname )
                if infop.func(actor, npc, infop.params) then
                    if not infop.expected then
                        -- инфопоршен есть, но не должен присутствовать
                        infop_conditions_met = false
                        break
                    end
                else
                    if infop.expected then
                        -- инфопоршен есть, но не должен присутствовать
                        infop_conditions_met = false
                        break
                    end
                end
            elseif has_alife_info(infop.name) then
                if not infop.required then
                    infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
                    break
                end
            else
                if infop.required then
                    infop_conditions_met = false -- инфопоршена нет, но он нужен
                    break
                end
            end
        end

        if infop_conditions_met then
            -- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые infoportions:
            for inum, infop in pairs(cond.infop_set) do
                ASSERT(db.actor, "TRYING TO SET INFOS THEN ACTOR IS NIL")
                if infop.func then
                    infop.func(actor, npc, infop.params)
                elseif infop.required then
                    if not has_alife_info(infop.name) then
                        actor:give_info_portion(infop.name)
                    end
                else
                    if has_alife_info(infop.name) then
                        actor:disable_info_portion(infop.name)
                    end
                end
            end
            if cond.section == "never" then
                return nil
            else
                return cond.section
            end
        end
    end

    return nil
end

-- Выполняет переключение на указанную секцию, если задана.
-- Если section == nil, остается работать старая секция.
function switch_to_section(npc, st, section)
    if section == nil or section == "" then
        return false
    end

    local npc_storage = db.storage[npc:id()]
    local active_section = npc_storage.active_section

    if active_section == section then
        return false
    end

    if active_section then
        issue_event(npc, npc_storage[npc_storage.active_scheme], "deactivate", npc)
    end

    npc_storage.active_section = nil
    npc_storage.active_scheme = nil

    activate_by_section(npc, st.ini, section, false)

    return true
end

local sect_tbl = {
    ["on_actor_dist_le"] = function(npc, actor, c)
        return npc:alive() and npc:see(actor) and distance_between(actor, npc) <= c.v1
    end,
    ["on_actor_dist_le_nvis"] = function(npc, actor, c)
        return distance_between(actor, npc) <= c.v1
    end,
    ["on_actor_dist_ge"] = function(npc, actor, c)
        return npc:alive() and npc:see(actor) and distance_between(actor, npc) > c.v1
    end,
    ["on_actor_dist_ge_nvis"] = function(npc, actor, c)
        return distance_between(actor, npc) > c.v1
    end,
    ["on_signal"] = function(npc, actor, c, st)
        return st.signals and st.signals[c.v1]
    end,
    ["on_info"] = function()
        return true
    end,
    ["on_timer"] = function(npc, actor, c)
        local npc_id = npc:id()
        return time_global() >= db.storage[npc_id].activation_time + c.v1
    end,
    ["on_game_timer"] = function(npc, actor, c)
        local npc_id = npc:id()
        return game.get_game_time():diffSec(db.storage[npc_id].activation_game_time) >= c.v1
    end,
    ["on_actor_in_zone"] = function(npc, actor, c)
        return utils.npc_in_zone(actor, db.zone_by_name[c.v1])
    end,
    ["on_actor_not_in_zone"] = function(npc, actor, c)
        return not utils.npc_in_zone(actor, db.zone_by_name[c.v1])
    end,
    ["on_npc_in_zone"] = function(npc, actor, c)
        local npc_id = npc:id()
        return utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
    end,
    ["on_npc_not_in_zone"] = function(npc, actor, c)
        local npc_id = npc:id()
        return not utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
    end,
    ["on_actor_inside"] = function(npc, actor)
        return utils.npc_in_zone(actor, npc)
    end,
    ["on_actor_outside"] = function(npc, actor)
        return not utils.npc_in_zone(actor, npc)
    end
}

function see_actor(npc)
    return npc:alive() and npc:see(db.actor)
end

function try_switch_to_another_section(npc, st, actor)
    if not actor then
        return
    end

    local l = st.logic or
                  abort("try_switch_to_another_section, invalid logic, scheme: [%s] (%s)", st.active_scheme or "none",
            (npc and npc:name()) or "script")

    for _, c in pairs(l) do
        local chk = sect_tbl[c.field]
        if chk then
            if chk(npc, actor, c, st) then
                if switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist)) then
                    return true
                end
            end
        else
            abort("try_switch_to_another_section: invalid condition: [%s] (%s)", c.name, npc:name())
        end
    end

    return false
end

function is_active(npc, st)
    if st.section == nil then
        abort("npc '%s': st.section is nil, active section is '%s'", npc:name(),
            utils.to_str(db.storage[npc:id()].active_section))
    end
    local is_act = (st.section == db.storage[npc:id()].active_section)

    -- Текущая секция активна и не сработало ни одно из условий переключения на другие секции
    return is_act
end

function abort_syntax_error_in_cond(npc, section, field)
    if npc and npc:name() == "x18_poltergeist_door_closer" then return end
    abort("object '%s': section '%s': field '%s': syntax error in switch condition", (npc and npc:name()) or "script", section or "none", field or "none")
end


function parse_func_params(str)
    local lst = {}
    for par in string.gmatch(str, "%s*([^:]+)%s*") do
        table.insert(lst, tonumber(par) or par)
    end
    return lst
end

function parse_func_name(str, is_check)
    local func
    local module, fname = string.match(str, "(.+)[.](.+)")
    if not fname then
        if is_check then
            func = xr_conditions[str]
        else
            func = xr_effects[str]
        end
    else
        if _G[module] and _G[module][fname] then
            func = _G[module][fname]
        end
    end
    ASSERT(func, "function '%s' not found: is_check = %s", str, is_check)
    return func
end

function parse_infop(rslt, str, is_check)
    if str then
        local infop_n = 1
        for s in string.gmatch(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
            local sign = string.sub(s, 1, 1)
            local infop_name = string.sub(s, 2)
            local params = nil
            -- парсим параметры функций
            local at = string.find(infop_name, "%(")
            if at then
                if string.sub(infop_name, -1) ~= ")" then
                    abort("wrong condlist %s", (str or "none"))
                end
                if at < string.len(infop_name) - 1 then
                    params = parse_func_params(string.sub(infop_name, at + 1, -2))
                else
                    params = {}
                end
                infop_name = string.sub(infop_name, 1, at - 1)
            end

            if sign == "+" then
                rslt[infop_n] = {
                    name = infop_name,
                    required = true
                }
            elseif sign == "-" then
                rslt[infop_n] = {
                    name = infop_name,
                    required = false
                }
            elseif sign == "~" then
                rslt[infop_n] = {
                    prob = tonumber(infop_name)
                }
            elseif sign == "=" then
                rslt[infop_n] = {
                    fname = infop_name,
                    func = parse_func_name(infop_name, is_check),
                    expected = true,
                    params = params
                }
            elseif sign == "!" then
                rslt[infop_n] = {
                    fname = infop_name,
                    func = parse_func_name(infop_name, is_check),
                    expected = false,
                    params = params
                }
            else
                abort("XR_LOGIC - ERROR in function parse_infop")
            end
            infop_n = infop_n + 1
        end
    end
end

-- Распарсивает строку src вида:
-- {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ...
-- в таблицу:
-- {
--   1 = { infop_check = { 1 = {"infop1" = true} }, infop_set = { 1 = {"infop2" = false } }, section = "section1" },
--   2 = { infop_check = { 1 = {"infop3" = true}, 2 = {"infop4" = false} }, infop_set = {}, section = "section2" },
-- }
function parse_condlist(npc, section, field, src)
    ASSERT(src, "xr_logic.parse_condlist: 'src' is a nil reference")
    local lst = {}

    -- 1) Разбиваем на разделенные запятыми части:
    local at, to, infop_check_lst, remainings, infop_set_lst, newsect

    local n = 1
    for fld in string.gmatch(src, "%s*([^,]+)%s*") do
        -- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
        lst[n] = {}

        -- Выделяем список infoportions для проверки:
        at, to, infop_check_lst = string.find(fld, "{%s*(.*)%s*}")
        if infop_check_lst then

            -- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
            remainings = string.sub(fld, 1, at - 1) .. string.sub(fld, to + 1)
        else
            -- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
            remainings = fld
        end

        -- Выделяем список infoportions для установки из remainings:
        at, to, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
        if infop_set_lst then
            -- Выделяем оставшуюся часть поля, т.е. имя секции:
            newsect = string.sub(remainings, 1, at - 1) .. string.sub(remainings, to + 1)
        else
            -- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
            newsect = remainings
        end

        -- И сразу trim имя секции:
        at, to, newsect = string.find(newsect, "%s*(.*)%s*")
        if not newsect then
            abort_syntax_error_in_cond(npc, section, field)
        end

        -- Имя секции теперь можно сохранить:
        lst[n].section = newsect

        -- Теперь нужно распарсить infoportions в строке infop_check_lst и
        -- заполнить массив infop_check: { "infop_name" = true/false }.
        -- На входе имеем строку вида "  +infop1  -infop2 +infop3 ... "
        lst[n].infop_check = {}
        parse_infop(lst[n].infop_check, infop_check_lst, true)

        -- То же самое для устанавливаемых infoportions:
        lst[n].infop_set = {}
        parse_infop(lst[n].infop_set, infop_set_lst, false)

        n = n + 1
    end

    return lst
end

function cfg_get_number_and_condlist(ini, section, field, npc)
    local str = get_string(section, field, nil, ini)
    if not str then
        return nil
    end

    local par = utils.parse_params(str)
    if not par[1] or not par[2] then
        abort_syntax_error_in_cond(npc, section, field)
    end
    local t = {}
    t.name = field
    t.v1 = tonumber(par[1])
    t.condlist = parse_condlist(npc, section, field, par[2])

    return t
end

function cfg_get_string_and_condlist(ini, section, field, npc)
    local str = get_string(section, field, nil, ini)
    if not str then
        return nil
    end

    local par = utils.parse_params(str)
    if not par[1] or not par[2] then
        abort_syntax_error_in_cond(npc, section, field)
    end
    local t = {}
    t.name = field
    t.v1 = par[1]
    t.condlist = parse_condlist(npc, section, field, par[2])

    return t
end

function cfg_get_two_strings_and_condlist(ini, section, field, npc)
    local str = get_string(section, field, nil, ini)
    if not str then
        return nil
    end

    local par = utils.parse_params(str)
    if not par[1] or not par[2] or not par[3] then
        abort_syntax_error_in_cond(npc, section, field)
    end
    local t = {}
    t.name = field
    t.v1 = par[1]
    t.v2 = par[2]
    t.condlist = parse_condlist(npc, section, field, par[3])

    return t
end

function cfg_get_condlist(ini, section, field, npc)
    local str = get_string(section, field, nil, ini)
    if not str then
        return nil
    end

    local par = utils.parse_params(str)
    if not par[1] then
        abort_syntax_error_in_cond(npc, section, field)
    end
    local t = {}
    t.name = field
    t.condlist = parse_condlist(npc, section, field, par[1])

    return t
end

function add_condition(lst, at, cond)
    if cond then
        lst[at] = cond
        return at + 1
    end
    return at
end

function cfg_get_switch_conditions(ini, section, npc)
    local l = {}
    local n = 1

    local function add_conditions(func, cond)
        local i = 1
        local c = func(ini, section, cond, npc)
        while c ~= nil do
            c.field = cond
            n = add_condition(l, n, c, npc)
            i = i + 1
            c = func(ini, section, cond .. i, npc)
        end
    end

    add_conditions(cfg_get_number_and_condlist, "on_actor_dist_le")
    add_conditions(cfg_get_number_and_condlist, "on_actor_dist_le_nvis")
    add_conditions(cfg_get_number_and_condlist, "on_actor_dist_ge")
    add_conditions(cfg_get_number_and_condlist, "on_actor_dist_ge_nvis")
    add_conditions(cfg_get_string_and_condlist, "on_signal")
    add_conditions(cfg_get_condlist, "on_info")
    add_conditions(cfg_get_number_and_condlist, "on_timer")
    add_conditions(cfg_get_number_and_condlist, "on_game_timer")
    add_conditions(cfg_get_string_and_condlist, "on_actor_in_zone")
    add_conditions(cfg_get_string_and_condlist, "on_actor_not_in_zone")
    add_conditions(cfg_get_condlist, "on_actor_inside")
    add_conditions(cfg_get_condlist, "on_actor_outside")
    add_conditions(cfg_get_npc_and_zone, "on_npc_in_zone")
    add_conditions(cfg_get_npc_and_zone, "on_npc_not_in_zone")

    return l
end

function cfg_get_overrides(ini, section, npc)
    local l = {}

    local tmp = get_string(section, "heli_hunter", nil, ini)
    if tmp then
        l.heli_hunter = xr_logic.parse_condlist(npc, section, "heli_hunter", tmp)
    end

    l.combat_ignore = cfg_get_condlist(ini, section, "combat_ignore_cond", npc)
    l.combat_ignore_keep_when_attacked = get_bool(section, "combat_ignore_keep_when_attacked", false, ini)
    l.combat_type = cfg_get_condlist(ini, section, "combat_type", npc)
    l.on_combat = cfg_get_condlist(ini, section, "on_combat", npc)
    l.soundgroup = get_string(section, section:find("kamp") and "center_point" or "soundgroup", nil, ini)

    return l
end

function cfg_get_npc_and_zone(ini, section, field, npc)
    local t = cfg_get_two_strings_and_condlist(ini, section, field, npc)
    if t then
        local obj = alife():story_object(tonumber(t.v1) or abort(""))
        if obj then
            t.npc_id = obj.id
        else
            t.npc_id = -1
        end
    end

    return t
end

-- Возвращает ссылку на оверрайды, зарегистрированные в активной на данный момент секции,
-- либо nil, если ни одна из секций не активна, или оверрайдов нет.
function generic_scheme_overrides(npc)
    return db.storage[npc:id()].overrides
end

function mob_release(mob)
    if mob:get_script() then
        mob:script(false, script_name())
    end
end

function mob_capture(mob, reset_actions)
    if reset_actions == nil then
        abort("mob_capture: reset_actions parameter's value is not specified")
    end

    if reset_actions then
        if mob:get_script() then
            mob:script(false, script_name())
        end
        mob:script(true, script_name())
    else
        if not mob:get_script() then
            mob:script(true, script_name())
        end
    end
end

function mob_captured(mob)
    return mob:get_script()
end

function save_logic(obj, packet)
    local npc_id = obj:id()
    local activation_time = db.storage[npc_id].activation_time
    if not activation_time then
        activation_time = 0
    end
    packet:w_s32(activation_time - time_global())
    -- GAMETIME added by Stohe.
    utils.w_CTime(packet, db.storage[npc_id].activation_game_time)
end

function load_logic(obj, reader)
    local npc_id = obj:id()

    db.storage[npc_id].activation_time = reader:r_s32() + time_global()
    -- GAMETIME added by Stohe.
    db.storage[npc_id].activation_game_time = utils.r_CTime(reader)
end

local pstor_number = 0
local pstor_string = 1
local pstor_boolean = 2
local registered_types = {
    ["boolean"] = true,
    ["string"] = true,
    ["number"] = true
}

function pstor_store(obj, varname, val)
    if not obj then
        return
    end
    local npc_id = obj:id()

    if db.storage[npc_id].pstor == nil then
        db.storage[npc_id].pstor = {}
    end
    local tv = type(val)
    if registered_types[tv] then
        db.storage[npc_id].pstor[varname] = val
    end
end

function pstor_retrieve(obj, varname, defval)
    if not obj then
        return defval
    end
    local npc_id = obj:id()

    if db.storage[npc_id].pstor ~= nil then
        local val = db.storage[npc_id].pstor[varname]
        if val ~= nil then
            return val
        end
    end
    if defval ~= nil then
        return defval
    end
    return nil
end

function pstor_save_all(obj, packet)
    local npc_id = obj:id()
    local pstor = db.storage[npc_id].pstor
    if not pstor then
        pstor = {}
        db.storage[npc_id].pstor = pstor
    end

    if obj:is_actor() then
        -- log3("[%s] Saved actor pstor: %s", script_name(), pstor)
        ogse.save_var(script_name() .. ".pstor_actor", pstor, "table")
    else
        local ctr = 0
        for k, v in pairs(pstor) do
            ctr = ctr + 1
        end
        packet:w_u32(ctr)

        for k, v in pairs(pstor) do
            packet:w_stringZ(k)
            local tv = type(v)
            if tv == "number" then
                packet:w_u8(pstor_number)
                packet:w_float(v)
            elseif tv == "string" then
                packet:w_u8(pstor_string)
                packet:w_stringZ(v)
            elseif tv == "boolean" then
                packet:w_u8(pstor_boolean)
                packet:w_bool(v)
            else
                abort("xr_logic: pstor_save_all: not registered type encountered in ",
                    " NPC " .. tostring(obj:name()) .. " varname " .. tostring(k) .. " value " .. tostring(v))
            end
        end
    end
end

function pstor_load_all(obj, reader)
    local npc_id = obj:id()
    local pstor = db.storage[npc_id].pstor
    if not pstor then
        pstor = {}
        db.storage[npc_id].pstor = pstor
    end

    if obj:is_actor() and ogse.var_exists(script_name() .. ".pstor_actor") then
        db.storage[npc_id].pstor = ogse.load_var(script_name() .. ".pstor_actor")
        -- log3("[%s] Loaded actor pstor: %s", script_name(), db.storage[npc_id].pstor)
    else
        if obj:is_actor() then -- Такое может быть при НИ
            return
        end

        local ctr = reader:r_u32()

        if ctr > 20 then
            log3("!![pstor_load_all] Something strange in object [%s]", obj:name())
            ctr = 20
        end

        for i = 1, ctr do
            local varname = reader:r_stringZ()
            local tn = reader:r_u8()
            if tn == pstor_number then
                pstor[varname] = reader:r_float()
            elseif tn == pstor_string then
                pstor[varname] = reader:r_stringZ()
            elseif tn == pstor_boolean then
                pstor[varname] = reader:r_bool()
            else
                pstor[varname] = nil
                -- ("xr_logic: pstor_load_all: not registered type encountered in ", " NPC "..tostring(obj:name()).." varname "..tostring(varname).." value "..tostring(tn))
            end
        end
    end
end

local st_loaded_keys = {
    ["ini_filename"] = "loaded_ini_filename",
    ["section_logic"] = "loaded_section_logic",
    ["active_section"] = "loaded_active_section",
    ["gulag_name"] = "loaded_gulag_name"
}

function get_st_loaded_value(st, k)
    ASSERT(st_loaded_keys[k], "[%s]: '%s' not found in st_loaded_keys", script_name(), tostring(k))
    return st[st_loaded_keys[k]]
end

function get_st_value(st, k)
    return st[k]
end

local save_obj_keys = {"ini_filename", "section_logic", "active_section", "gulag_name"}

function save_obj(obj, packet, loaded)
    local npc_id = obj:id()
    local st = db.storage[npc_id]
    local get_st = loaded and this.get_st_loaded_value or this.get_st_value

    for _, k in ipairs(save_obj_keys) do
        local v = get_st(st, k)
        -- log3( "xr_logic.save_obj: %s = %s", k, v )
        packet:w_stringZ(v or "")
    end
    save_logic(obj, packet)
    if st.active_scheme then
        issue_event(obj, db.storage[npc_id][st.active_scheme], "save")
    end
    pstor_save_all(obj, packet)
end

function load_obj(obj, reader)
    local npc_id = obj:id()
    local st = db.storage[npc_id]
    local ini_filename = reader:r_stringZ()
    if ini_filename == "" then
        ini_filename = nil
    end

    local section_logic = reader:r_stringZ()
    if section_logic == "" then
        section_logic = nil
    end

    local active_section = reader:r_stringZ()

    -- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
    -- При этом реальная active_section станет равной nil.
    if active_section == "" then
        active_section = "nil"
    end

    local gulag_name = reader:r_stringZ()
    if gulag_name == "" then
        gulag_name = nil
    end

    st.loaded_ini_filename = ini_filename
    st.loaded_section_logic = section_logic
    st.loaded_active_section = active_section
    st.loaded_gulag_name = gulag_name

    load_logic(obj, reader)
    pstor_load_all(obj, reader)
end

function get_customdata_or_ini_file(npc, filename)
    local dsh_sect = "dsh.xr_logic.get_customdata_or_ini_file"
    if sys_ini:section_exist(dsh_sect) then
        local npc_sect
        if type(npc.id) == "function" then
            npc_sect = npc:section()
        else
            npc_sect = npc:section_name()
        end
        local ini_fname = get_string(dsh_sect, npc_sect)
        if not ini_fname then
            ini_fname = get_string(dsh_sect, npc:name())
        end
        if ini_fname then
            local new_ini = dsh.cached_ini_file(ini_fname)
            if logic_not_empty(npc, new_ini) then -- !KRodin: если логика вышла в nil, её не используем! Ведь в этом случае персонаж уже может находиться под логикой какого-нибудь гулага.
                return new_ini
            end
        end
    end
    --
    if filename == "<customdata>" then
        return npc:spawn_ini() or dsh.cached_ini_file("scripts\\dummy.ltx")
    elseif string.find(filename, "*") == 1 then -- динамический ltx
        local p = string.find(filename, "*", 2)
        return gulag_tasks.loadLtx(string.sub(filename, 2, p - 1), string.sub(filename, p + 1))
    else
        return dsh.cached_ini_file(filename)
    end
end

function initialize_obj(obj, st, loaded, actor, stype)
    if not loaded then
        local ini_filename = "<customdata>"
        local ini = get_customdata_or_ini_file(obj, ini_filename)
        ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, "logic", nil)
        local sect = xr_logic.determine_section_to_activate(obj, ini, "logic", actor)
        xr_logic.activate_by_section(obj, ini, sect, false)
    else
        local ini_filename = st.loaded_ini_filename
        if ini_filename then
            local ini = get_customdata_or_ini_file(obj, ini_filename)
            if not ini:section_exist(st.loaded_section_logic) and st.loaded_gulag_name then -- Костыль, чтобы не требовалась НИ при изменении логики гулагов
                log3("!![%s.initialize_obj] object [%s] unable to find gulag logic section [%s] Reloading logic...",
                    script_name(), obj:name(), st.loaded_section_logic)
                ogse.reset_npc_logic(obj)
                xr_gulag.resetJob(obj)
                local sobj = alife():object(obj:id())
                ASSERT(sobj, "")
                smart_terrain.unregister_npc(sobj)
                sobj:brain():update()
                return
            else
                ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, st.loaded_section_logic,
                    st.loaded_gulag_name)
                xr_logic.activate_by_section(obj, ini, st.loaded_active_section, true)
            end
        end
    end
end

-- у объекта есть "непустая" логика
function logic_not_empty(npc, ini)
    if ini:section_exist("logic") and ini:line_exist("logic", "cfg") then
        ini = dsh.cached_ini_file(get_string("logic", "cfg", "scripts\\dummy.ltx", ini))
    end
    return determine_section_to_activate(npc, ini, "logic", db.actor) ~= "nil"
end

function save_logic_online(obj)
    local npc_id = obj:id()
    local st = db.storage[npc_id]
    local gulag = xr_gulag.get_npc_gulag(obj)
    local sobj = alife():object(obj:id())
    if sobj and not gulag then
        if sobj.s_storage and sobj.s_storage ~= "_" then
            local npc_data = m_netpk.custom_data(sobj.s_storage)
            npc_data = npc_data:getTable()
            if not npc_data.logic_data then
                npc_data.logic_data = {}
            end
            if st.ini_filename then
                npc_data.logic_data["ini"] = st.ini_filename
            else
                npc_data.logic_data["ini"] = ""
            end
            if st.section_logic then
                npc_data.logic_data["sec"] = st.section_logic
            else
                npc_data.logic_data["sec"] = ""
            end
            if st.active_section then
                npc_data.logic_data["act"] = st.active_section
            else
                npc_data.logic_data["act"] = ""
            end
            local activation_time = st.activation_time
            if not activation_time then
                activation_time = 0
            end
            local cur_tm = time_global()
            activation_time = activation_time - cur_tm
            npc_data.logic_data["act_time"] = activation_time
            local gtime = st.activation_game_time
            local str_gtime = nil
            if gtime then
                str_gtime = pack_time_to_string(gtime)
                if str_gtime then
                    npc_data.logic_data["act_g_time"] = str_gtime
                end
            end
            local data_parsed = m_netpk.custom_data(npc_data)
            sobj.s_storage = data_parsed:getString()
        else
            local npc_data = {}
            npc_data.logic_data = {}
            if st.ini_filename then
                npc_data.logic_data["ini"] = st.ini_filename
            else
                npc_data.logic_data["ini"] = ""
            end
            if st.section_logic then
                npc_data.logic_data["sec"] = st.section_logic
            else
                npc_data.logic_data["sec"] = ""
            end
            if st.active_section then
                npc_data.logic_data["act"] = st.active_section
            else
                npc_data.logic_data["act"] = ""
            end
            local activation_time = st.activation_time
            if not activation_time then
                activation_time = 0
            end
            local cur_tm = time_global()
            activation_time = activation_time - cur_tm
            npc_data.logic_data["act_time"] = tostring(activation_time)
            local gtime = st.activation_game_time
            local str_gtime = nil
            if gtime then
                str_gtime = pack_time_to_string(gtime)
                if str_gtime then
                    npc_data.logic_data["act_g_time"] = str_gtime
                end
            end
            local data_parsed = m_netpk.custom_data(npc_data)
            sobj.s_storage = data_parsed:getString()
        end
    end
end

function load_logic_online(obj)
    local npc_id = obj:id()
    local st = db.storage[npc_id]
    local gulag = xr_gulag.get_npc_gulag(obj)
    local sobj = alife():object(obj:id())
    if sobj and not gulag and sobj.s_storage and sobj.s_storage ~= "_" then
        local npc_data = m_netpk.custom_data(sobj.s_storage)
        npc_data = npc_data:getTable()
        if npc_data.logic_data then
            if npc_data.logic_data["ini"] and npc_data.logic_data["ini"] ~= "" then
                st.ini_filename = npc_data.logic_data["ini"]
            end
            if npc_data.logic_data["sec"] and npc_data.logic_data["sec"] ~= "" then
                st.section_logic = npc_data.logic_data["sec"]
            end
            if npc_data.logic_data["act"] and npc_data.logic_data["act"] ~= "" then
                st.active_section = npc_data.logic_data["act"]
            else
                st.active_section = "nil" -- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
            end
            if npc_data.logic_data["act_time"] and npc_data.logic_data["act_time"] ~= "" then
                local cur_tm = time_global()
                st.activation_time = tonumber(npc_data.logic_data["act_time"]) + cur_tm
            end
            if npc_data.logic_data["act_g_time"] and npc_data.logic_data["act_g_time"] ~= "" then
                local unpack_ctime = unpack_time_from_string(npc_data.logic_data["act_g_time"])
                st.activation_game_time = unpack_ctime
            end
            return true
        end
    end
    return false
end

function has_active_logic(npc)
    local st = db.storage[npc:id()]
    if not st.active_section then
        return false
    end
    ASSERT(st.active_scheme, "[%s]: %s: active_scheme is nil", script_name(), npc:name())
    if st.active_scheme == "sr_idle" then
        local t = st[st.active_scheme]
        if table.getn(t.logic) == 0 then
            return false
        end
    end
    return true
end

function logic_needs_update(npc)
    if not has_active_logic(npc) then
        return false
    end
    local st = db.storage[npc:id()]
    if st.active_scheme == "sr_idle" then
        local t = st[st.active_scheme]
        for _, c in ipairs(t.logic) do
            if not (c.field == "on_actor_inside" or c.field == "on_actor_outside" or
                (c.field == "on_actor_in_zone" and c.v1 == npc:name()) or
                (c.field == "on_actor_not_in_zone" and c.v1 == npc:name()) or
                (c.field == "on_npc_in_zone" and c.v2 == npc:name()) or
                (c.field == "on_npc_not_in_zone" and c.v2 == npc:name())) then
                return true
            end
        end
        return false
    elseif st.active_scheme == "sr_no_weapon" then
        local t = st[st.active_scheme]
        return table.getn(t.logic) > 0
    end
    return true
end
