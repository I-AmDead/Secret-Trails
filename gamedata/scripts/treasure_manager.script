-- -*- mode: lua; coding: windows-1251-dos -*-


local rare_list = {

 novice_section = {
 "wpn_walther_p99",
 "wpn_toz34",
 "ammo_vog-25p",
 "ammo_m209",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "af_ameba_mica",
 "af_soul",
 "af_cristall",
 "af_gold_fish",
 "af_night_star",
 "af_electra_moonlight"
 },

 experienced_section = {
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_og-7b",
 "wpn_ak74_n",
 "wpn_abakan_n",
 "af_fuzz_kolobok",
 "af_rusty_sea-urchin",
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring"
 },

 veteran_section = {
 "af_spirit_1",        
 "af_cry_1",
 "af_babka_1",
 "af_pudd_1",
 "af_dik_1",
 "af_kol_1",
 "af_armor_1",
 "wpn_l85_m1",
 "wpn_m4a1_siber",
 "wpn_groza"
 },

master_section = {
 "wpn_vintorez_isg",
 "wpn_svu",
 "wpn_svds",
 "af_simbion",        
 "wpn_l85_m3",
 "af_spirit_2",         
 "af_cry_2",
 "af_babka_2",
 "af_pudd_2",
 "af_dik_2",
 "af_kol_2",
 "af_armor_2"  
 }
}

local solid_list = {
 novice_section = {
 --ĞÑ€Ñ‚ĞµÑ„Ğ°ĞºÑ‚Ñ‹--
 "af_drops",
 "af_ameba_slime",
 "af_rusty_thorn",
 "af_electra_sparkler",
 "af_blood",
 "af_vyvert",
 "af_medusa",
 --ĞĞ¼Ğ¼ÑƒĞ½Ğ¸Ñ†Ğ¸Ñ--
 "grenade_rgd5",
 "ammo_12x70_buck",     
 "ammo_9x19_fmj",
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_9x18_fmj",
 --ĞÑ€ÑƒĞ¶Ğ¸Ğµ--
 "wpn_addon_silencer",
 "wpn_mp5",
 "wpn_bm16",
 "wpn_fort",
 "wpn_pb",
 "wpn_pm_bas",
 --ĞŸÑ€Ğ¾Ñ‡ĞµĞµ--
 "bread",
 "bandage",
 "kolbasa",
 "medkit",
 "vodka",
 "conserva"
 },

experienced_section = {
--ĞÑ€Ñ‚ĞµÑ„Ğ°ĞºÑ‚Ñ‹--
 "af_cristall_flower",
 "af_gravi",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 --ĞĞ¼Ğ¼ÑƒĞ½Ğ¸Ñ†Ğ¸Ñ--
 "grenade_rgd5",
 "grenade_f1",     
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_5.45x39_fmj",
 "ammo_11.43x23_fmj",
 "ammo_5.56x45_ss190",
 --ĞŸÑƒÑˆĞºĞ¸--
 "pso",
 "wpn_mp5",
 "wpn_ak74u_n1",
 "wpn_ak74u_m1_isg",
 "wpn_walther_p99",
 --ĞŸÑ€Ğ¾Ñ‡ĞµĞµ--
 "mutant_dog_tail",
 "mutant_boar_leg",
 "kolbasa",
 "medkit",
 "antirad",
 "energy_drink",
 "conserva"
 },

 veteran_section = {
 --ĞÑ€Ñ‚ĞµÑ„Ğ°ĞºÑ‚Ñ‹--
 "af_night_star",
 "af_gold_fish",
 "af_soul",
 "af_electra_moonlight",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_cristall",
 --ĞĞ¼Ğ¼ÑƒĞ½Ğ¸Ñ†Ğ¸Ñ--
 "grenade_f1",
 "ammo_vog-25",     
 "ammo_m209",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_9x39_pab9",
 "ammo_5.56x45_ss190",
 "ammo_12x76_zhekan",
 --ĞŸÑƒÑˆĞºĞ¸--
 "susat",
 "wpn_addon_grenade_launcher",
 "wpn_walther_p99",
 "wpn_sig550_siber",
 "wpn_toz34",
 "wpn_abakan_n_m2",
 "wpn_desert_eagle",
 --ĞŸÑ€Ğ¾Ñ‡ĞµĞµ--
 "mutant_psevdodog_tail",
 "mutant_snork_leg",
 "medkit_army",
 "antirad"
 },

 master_section = {
 --ĞÑ€Ñ‚ĞµÑ„Ğ°ĞºÑ‚Ñ‹--
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_fuzz_kolobok",
 --ĞĞ¼Ğ¼ÑƒĞ½Ğ¸Ñ†Ğ¸Ñ--
 "ammo_m209",
 "ammo_vog-25p",     
 "ammo_9x39_ap",
 "ammo_12x76_dart",
 "ammo_7.62x54_7h14",
 "ammo_9x39_sp5",
 "ammo_5.56x45_ap",
 "ammo_7.62x54_7h1",
 --ĞŸÑƒÑˆĞºĞ¸--
 "wpn_addon_grenade_launcher_m203",
 "wpn_colt1911_n",
 "wpn_spas12",
 "wpn_l85_m1",
 "wpn_l85_m1",
 "wpn_groza",
 "wpn_groza_m1",
 --ĞŸÑ€Ğ¾Ñ‡ĞµĞµ--
 "mutant_krovosos_jaw",
 "mutant_burer_hand",
 "medkit_army",
 "medkit_scientic"
 }
}

treasure_type = 2
function attach( sm )
  sm:subscribe({ signal = "on_ph_obj_use", fun = this.on_treasure_use })
  sm:subscribe({ signal = "on_save",       fun = this.save            })
  sm:subscribe({ signal = "on_npc_use",    fun = this.on_npc_use      })
  sm:subscribe({ signal = "on_spawn",      fun = this.on_spawn        })
end


function on_take_from_box( box )
	if box:is_inv_box_empty() then
		get_treasure_manager():treasure_empty( box, box:story_id() )
	end
end

function on_npc_use( obj )
	if obj:alive() then return end
	--
	local sobj = alife():object( obj:id() )
	if not sobj.treasure_processed and not GetShift() then -- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° ÑˆĞ¸Ñ„Ñ‚ ÑĞ´ĞµĞ»Ğ°Ğ½Ğ°, Ñ‡Ñ‚Ğ¾Ğ± Ğ½Ğµ ÑÑ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ğ»Ğ¾ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞµ Ğ¿ĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚ÑŒ Ñ‚Ñ€ÑƒĞ¿.
		get_treasure_manager():use( obj )
		--
		give_money( obj )
		--
		sobj.treasure_processed = true
	end
end

-----------------------------------------------------------------
function give_money(npc)
if npc ~= nil and not string.find(npc:section(),"arena") and npc:character_community()~="arena_enemy" then
local money = npc:money()
if money ~= nil and money ~=0 then
local deadmoney = money

local npc_rank
npc_rank = ranks.get_obj_rank_name(npc)
if npc_rank ~= nil then
if npc_rank == "novice" and deadmoney >=400 then deadmoney=math.random(25,400)
elseif npc_rank == "experienced" and deadmoney >=500 then deadmoney=math.random(50,500)
elseif npc_rank == "veteran" and deadmoney >=600 then deadmoney=math.random(100,600)
elseif npc_rank == "master" and deadmoney >=700 then deadmoney=math.random(200,700)
end
end
local news_texti = "\\n%c[255,255,0,0]Ì¸ğòâûé ñòàëêåğ: %c[default]"..npc:character_name().."\\n%c[255,255,0,0]Îáíàğóæåíî äåíåã: %c[default]"..game.translate_string(tostring(deadmoney).."ğóá.")
db.actor:give_game_news(news_texti, "ui\\ui_iconsTotal", Frect():set(0,0,83,47), 1, 4000)
db.actor:give_money(deadmoney)
game_stats.money_quest_update(deadmoney)
npc:give_money(-money)
game_stats.money_quest_update(-money)
end
end
end
-----------------------------------------------------------------

function on_treasure_use( obj, who )
  if obj:is_inventory_box() and obj:story_id() then
    get_treasure_manager():treasure_empty( obj, obj:story_id() )
  end
end


local given_onetime = {}
function on_spawn()
  local given = ogse.load_var_safe( "treasure_manager.given_onetime" )
  if given then
    for _, sect in ipairs( given ) do
      given_onetime[ sect ] = true
    end
  end
end


function remember_given_onetime( sect )
  given_onetime[ sect ] = true
  local given = {}
  for k, _ in pairs( given_onetime ) do
    table.insert( given, k )
  end
  ogse.save_var(
    "treasure_manager.given_onetime", given, "array_template", { "string" }
  )
end


local treasure_manager
local n_rank


function parse_spawns( line )
  if line == nil then
    return {}
  end

  -- ĞµÑĞ»Ğ¸ default-Ğ¾Ğ² Ğ±Ğ¾Ğ»ÑŒÑˆĞµ, Ñ‡ĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ² ini, Ñ‚Ğ¾ Ğ·Ğ°Ğ±Ğ¸Ñ‚ÑŒ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°ÑÑ‰Ğ¸Ğµ
  -- Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸ĞµĞ¼ Ğ¸Ğ· ini
  local t = se_respawn.parse_names( line )
  local n = table.getn( t )
  local ret_table = {}
  local k = 1

  while k <= n do
    local spawn   = {}
    spawn.section = t[ k ]
    -- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ
    if t[ k + 1 ] ~= nil then
      local p = tonumber( t[ k + 1 ] )
      -- Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ğ²Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ¼ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ° Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ, Ğ° Ğ½Ğµ Ğ´Ñ€ÑƒĞ³Ğ°Ñ
      -- ÑĞµĞºÑ†Ğ¸Ñ ÑĞ¿Ğ°Ğ²Ğ½Ñƒ
      if p then
        -- Ğ·Ğ°Ğ±Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ‡Ğ¸ÑĞ»Ğ¾
        spawn.prob = p
        k = k + 2
      else
        -- Ğ·Ğ°Ğ±Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚ 1
        spawn.prob = 1
        k = k + 1
      end
    else
      spawn.prob = 1
      k = k + 1
    end
    table.insert( ret_table, spawn )
  end

  return ret_table
end


class "CTreasure"
function CTreasure:__init()
  --' Ğ˜Ñ‚ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ÑÑ Ğ¿Ğ¾ Ğ²ÑĞµĞ¼ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼ Ñ„Ñ€Ğ°Ğ·
  ASSERT(
    sys_ini:section_exist( "treasure_manager.list" ),
    "There is no section [list] in treasure_manager.ltx"
  )

  local n = sys_ini:line_count( "treasure_manager.list" )
  local result, id, value = 0, "", ""

  --' Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°
  self.treasure_info = {}
  for i = 0, n - 1 do
    result, id, value = sys_ini:r_line( "treasure_manager.list", i, "", "" )
    local info  = {}
    local id_sect = "treasure_manager." .. id
    info.target = get_u32( id_sect, "target" )
    info.named  = get_bool( id_sect, "named", false )
    info.name   = get_string( id_sect, "name" )
    info.cond   = xr_logic.parse_condlist(
      db.actor_proxy, "treasure_manager", "condlist",
      get_string( id_sect, "condlist", "" )
    )
    --' ĞÑ‚Ğ¼ĞµÑ‚Ğ¸Ğ¼ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº ĞºĞ°Ğº Ğ½Ğ¾Ğ²Ñ‹Ğ¹
    info.active = false
    info.done   = false
    self.treasure_info[ id ] = info
  end

  --' Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ»ĞµĞ³Ñ‡ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ°
  self.treasure_by_target = {}
  local cnt = 0
  for k, v in pairs( self.treasure_info ) do
    self.treasure_by_target[ v.target ] = k
    cnt = cnt + 1
  end
  ASSERT( n == cnt, "wrong num of loaded items: %s ~= %s", n, cnt )
end


-- Ğ®Ğ·Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ñ‚Ğ¾Ñ€Ğ° (Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ²Ñ‹Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº)
function CTreasure:use( npc )
  if npc:character_community() == "zombied" then return end
	
  if npc then
    n_rank = npc:character_rank()
  else
    n_rank = 0
  end

  local rarets 

  -- ĞµÑĞ»Ğ¸ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½ Ñ€ĞµĞ´ĞºĞ¸Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ¾Ğ², Ñ‚Ğ¾ ÑĞ½Ğ¸Ğ·Ğ¸Ğ¼ Ğ¾Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ ĞµĞ³Ğ¾ Ğ²Ñ‹Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ
  if treasure_type == 2 then 
    rarets = 90
  else 
    rarets = 80
  end
	
  if dsh.get_next_random( "treasure_manager.rnd.use", 100 ) < rarets then return end
	
  --' ĞÑƒĞ¶Ğ½Ğ¾ Ñ€Ğ°Ğ½Ğ´Ğ¾Ğ¼Ğ½Ğ¾ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¾Ğ´Ğ¸Ğ½ Ğ¸Ğ· Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ¾Ğ².
  local avail  = {}
  local tr_sum = 0
  for k, v in pairs( self.treasure_info ) do
    if ( not v.done ) and ( not v.active ) then
      local treasure_prob = xr_logic.pick_section_from_condlist(
        db.actor, npc, v.cond
      )
      if treasure_prob == "" or treasure_prob == nil then
        treasure_prob = 0
      end
      treasure_prob = tonumber( treasure_prob )
      if treasure_prob > 0 and not v.active then
        if treasure_prob == 100 then
          self:give_treasure( k )
        else
          table.insert( avail, { k = k, prob = treasure_prob } )
          tr_sum = tr_sum + treasure_prob
        end
      end
    end
  end
  if tr_sum == 0 then return end

  local tr_w = dsh.get_next_random( "treasure_manager.rnd.use", tr_sum )
  for k, v in pairs( avail ) do
    tr_w = tr_w - v.prob
    if tr_w <= 0 then
      --' Ğ’Ñ‹Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº
      self:give_treasure( v.k )
      break
    end
  end
end


--' Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
function CTreasure:check()
  --' ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ¾Ğ²
  for k, v in pairs( self.treasure_info ) do
    --' Ğ’Ñ‹Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº
    self:give_treasure( k )
  end
end

--' Ğ’Ñ‹Ğ´Ğ°Ñ‡Ğ° Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ°
function CTreasure:give_treasure( k, silent, skip_onetime_items )
  local v    = self.treasure_info[ k ]
  local obj = alife():story_object( v.target )
  if obj then
    ASSERT(
      obj:clsid() == clsid.inventory_box,
      "Story object [%s] is not an inventory box", v.target
    )

    if not silent then
      news_manager.send_treasure( v.name )
      --' ĞŸĞ¾Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ
      local text = "%c[255,238,155,23]"
        .. game.translate_string( v.name ) .. "\\n"
        .. "%c[default]" .. game.translate_string(
          get_string( "treasure_manager." .. k, "description", "" )
      )
      level.map_add_object_spot_ser(obj.id, "treasure", text)
    end

    -- Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, ĞºĞ°ĞºĞ¾Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ° Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½
    -- ĞµÑĞ»Ğ¸ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº Ğ½Ğµ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾Ğ¹, Ñ‚Ğ¾ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ğ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ
    if v.named then
      v.items = parse_spawns(
        get_string( "treasure_manager." .. k, "items", "" )
      )
    else
      v.items = self:give_item_list( skip_onetime_items )
    end

    --' Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²ĞµÑ‰Ğ¸
    for kk, vv in pairs( v.items ) do
      local prop = amk_utils.get_item_props( vv.section )
      vv.id = {}
      for i = 1, vv.prob do
        local sect = vv.section
        local sobj = alife():create(
          sect,
          obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id,
          obj.id
        )
        table.insert( vv.id, sobj.id )
      end
    end
		
    --' ĞŸĞ¾Ğ¼ĞµÑ‚Ğ¸Ğ¼ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº ĞºĞ°Ğº Ğ²Ñ‹Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹
    self.treasure_info[ k ].active = true
    self.treasure_info[ k ].done   = true
    -- ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ¼ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº Ğ² Ğ¾Ñ„Ñ„Ğ»Ğ°Ğ¹Ğ½
--[=[
    if level.object_by_id( obj.id ) then
      alife():set_switch_online(  obj.id, false )
      alife():set_switch_offline( obj.id, true  )
      -- ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ Ğ² Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ½Ğ° Ğ²Ñ‹Ğ²Ğ¾Ğ´ Ğ² Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½
      amk.convert_npc_timer( obj.id, 1 ):start()
    end
--]=]
    return v.items
  else
    log2( "TREASURE %s, target doesnt exist", k )
  end
end


--' Ğ¡Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ¾Ñ‚Ğ¼ĞµÑ‚ĞºÑƒ Ñ Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ°
function CTreasure:treasure_empty( box, box_story_id )
  local k = self.treasure_by_target[ box_story_id ]
  if ( not k ) or ( not self.treasure_info[ k ] ) then
    return
  end
  self.treasure_info[ k ].active = false
  -- ĞµÑĞ»Ğ¸ Ñ‚Ğ°Ğ¹Ğ½Ğ¸Ğº Ğ½Ğµ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾Ğ¹, Ñ‚Ğ¾ Ğ¿ĞµÑ€ĞµĞ²ĞµĞ´ĞµĞ½ ĞµĞ³Ğ¾ Ğ² Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ Ğ²Ñ‹Ğ´Ğ°Ñ‡Ğ¸
  if not self.treasure_info[ k ].named then
    self.treasure_info[ k ].done = false
  end
  if box then
    level.map_remove_object_spot(box:id(), "treasure")
  end
  ogse_signals.get_mgr():call( "on_treasure_empty", box, box_story_id )
end


function CTreasure:is_active( sobj )
  local k = self.treasure_by_target[ sobj.m_story_id ]
  if k and self.treasure_info[ k ] then
    return self.treasure_info[ k ].active
  end
  return false
end


-- Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
function CTreasure:save( p )
  local treasures = {}
  local active_cnt, done_cnt = 0, 0
  for k, v in pairs( self.treasure_info ) do
    -- Ğ¿Ğ¸ÑˆĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞ¾Ğ²
    if v.active or v.done then
      table.insert( treasures, { v.target, v.active, v.done } )
      if v.active then active_cnt = active_cnt + 1 end
      if v.done   then done_cnt   = done_cnt   + 1 end
    end
  end
  ogse.save_var(
    "treasure_manager.treasures", treasures, "array_template",
    { "u16", "bool", "bool" }
  )
  log2(
    "[%s]: %s treasures saved (active/done): %s/%s",
    script_name(), table.getn( treasures ), active_cnt, done_cnt
  )
end


-- Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°
function CTreasure:load( p )
  local treasures = ogse.load_var_safe( "treasure_manager.treasures" )
  if not treasures then return end
  local active_cnt, done_cnt = 0, 0
  for _, item in ipairs( treasures ) do
    local id, active, done = unpack( item )
    local k    = self.treasure_by_target[ id ]
    local info = self.treasure_info[ k ]
    info.active = active
    info.done   = done
    if active then active_cnt = active_cnt + 1 end
    if done   then done_cnt   = done_cnt   + 1 end
  end
  log2(
    "[%s]: %s treasures loaded (active/done): %s/%s",
    script_name(), table.getn( treasures ), active_cnt, done_cnt
  )
end


function CTreasure:give_item_list( skip_onetime_items )
  local rank  = 1
  local tabla = {}

  -- ÑÑ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºÑƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ 
  local opt = treasure_type

  -- Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ğ¼ Ñ€Ğ°Ğ½Ğ³ Ğ½ĞµĞ¿Ğ¸ÑÑ
  if n_rank == nil then 
    n_rank = dsh.get_next_random( "treasure_manager.rnd.rank", 1, 12 ) * 100
  end
  if n_rank <= 300 then
    rank = 1
  elseif n_rank <=600 then
    rank = 2
  elseif n_rank <= 900 then
    rank = 3
  else
    rank = 4
  end 

  -- Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ğ¼, Ğ¸Ğ· ĞºĞ°ĞºĞ¾Ğ¹ ÑĞµĞºÑ†Ğ¸Ğ¸ Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ñ‹, Ğ¸ ĞºĞ°ĞºĞ¸Ğµ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾
  local sect
  if  opt == 1 then
    if rank == 1 then
      sect = rare_list.novice_section
    elseif rank == 2 then
      sect = rare_list.experienced_section
    elseif rank == 3 then
      sect = rare_list.veteran_section
    else
      sect = rare_list.master_section
    end
  else
    if rank == 1 then
      sect = rare_list.novice_section
    elseif rank == 2 then
      sect = rare_list.experienced_section
    elseif rank == 3 then
      sect = rare_list.veteran_section
    else
      sect = rare_list.master_section
    end
  end

  local items = {}
  for _, item in ipairs( sect ) do
    if type( item ) == "table" then
      item = item[ math.random( table.getn( item ) ) ]
    end
    if
      ( not skip_onetime_items )
      or get_string( item, "treasure_manager.item_is", "" ) ~= "onetime"
    then
      if not given_onetime[ item ] then
        table.insert( items, item )
      end
    end
  end	 
  
  -- ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ½Ğ°Ğ¸Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¾Ğ² Ğ±ÑƒĞ´ĞµÑ‚ Ğ² Ñ‚Ğ°Ğ¹Ğ½Ğ¸ĞºĞµ
  local rnd_k = "treasure_manager.rnd.item_list." .. rank
  local i = dsh.get_next_random( rnd_k, 1, 4 )

  for j = 1, i do
    local cnt     = 0
    local spawn   = {}
    spawn.section = items[ dsh.get_next_random( rnd_k, table.getn( items ) ) ]
  -- ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° ĞºĞ¾Ğ»-Ğ²Ğ° Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¾Ğ² Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ ÑĞµĞºÑ†Ğ¸Ğ¸  
    local s   = tostring( spawn.section )
    local cls = get_string( s, "class" )
   if ammo_section( s ) then -- Ğ¿Ğ°Ñ‚Ñ€Ğ¾Ğ½Ñ‹
      cnt = dsh.get_next_random( rnd_k, 1, 3 )
    elseif string.find(s, "outfit") ~= nil or string.find(s, "wpn") ~= nil then
      cnt = 1
    elseif string.find(s, "addon") ~= nil or string.find(s, "af") ~= nil or string.find(s, "mutant") ~= nil then
      cnt = dsh.get_next_random( rnd_k, 1, 2 )
    else 
      cnt = dsh.get_next_random( rnd_k, 1, 5 )
    end
    -- ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ñƒ Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğµ
    spawn.prob = cnt
    table.insert( tabla, spawn )
  end

  return tabla
end


function get_treasure_manager()
  if not treasure_manager then
    treasure_manager = CTreasure()
  end
  return treasure_manager
end


function take_item_from_box( box, box_story_id )
  -- log2( "!!! take item from box %s", tostring( box:is_inv_box_empty() ) )
  get_treasure_manager():treasure_empty( box, box_story_id )
end


function save()
  get_treasure_manager():save()
end

function load( p )
  get_treasure_manager():load( p )
end

function clear_treasure_manager()
  treasure_manager = nil
end

function is_active( sobj )
  return get_treasure_manager():is_active( sobj )
end

