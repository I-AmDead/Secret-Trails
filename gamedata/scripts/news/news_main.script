-- -*- mode: lua; coding: windows-1251-dos -*-



local prob           = 0.35
local prob_offline_trade = 0.1
local prob_spawn_monster = 0.2
local prob_spawn_stalker = 0.2
local dist_close     = 100
local dist_seen      = 200
local dist_far       = 200
local dist_heli_seen = 400
local dist_hear_min  = 50
local dist_hear_max  = 400

local timer_stalker_death        = 3  -- Сообщение о смерти сталкера
local timer_corpse               = 60 -- Сообщение о найденом трупе
local timer_spawn                = 45 -- Сообщение о увиденном
local timer_general              = 30 -- Прочее
-- При каком расстоянии между обьектами считать их в одной группе
local distance_close             = 100
local timer_weather              = 60 -- При изменнии погоды
local timer_heli                 = 10 -- При замеченном вертолетике
local timer_next_blow            = 0 -- Тамер до след. выброса
local timer_blow_showed          = 0 -- Последняя показанная новость о Выбросе
-- Как часто новости о Выбросе показывать (игровые минуты)
local timer_blow_freq            = 10 * 60
local timer_heli_showed          = 0 -- Последняя новость про вертолетик
-- Как часто показывать новости про вертолетик (игровые минуты)
local timer_heli_freq            = 10
local timer_weather_showed       = 0 -- Последняя новость о погоде
-- Как часто новости о погоде показывать (игровые минуты)
local timer_weather_freq         = 5 * 60
local timer_daytime_showed       = 0 -- Последняя новость о времени суток
-- Как часто новости о времени суток показывать (игровые минуты)
local timer_daytime_freq         = 5 * 60

local friends_comm = {
  [ "dolg"    ] = true,
  [ "ecolog"  ] = true,
  [ "freedom" ] = true,
  [ "green"   ] = true,
  [ "nebo"    ] = true,
  [ "stalker" ] = true,
}

local ignore_spawn_comm = {
  [ "actor"         ] = true,
  [ "actor_dolg"    ] = true,
  [ "actor_freedom" ] = true,
  [ "arena_enemy"   ] = true,
  [ "boar"          ] = true,
  [ "dog"           ] = true,
  [ "dolg"          ] = true,
  [ "ecolog"        ] = true,
  [ "flesh"         ] = true,
  [ "freedom"       ] = true,
  [ "nebo"          ] = true,
  [ "pseudodog"     ] = true,
  [ "stalker"       ] = true,
  [ "trader"        ] = true,
  [ "tushkano"      ] = true,
}


local _debug = false
if _debug then
  timer_blow_freq               = 30
  timer_weather_freq            = 30
  timer_daytime_freq            = 30
  timer_show_freq               =  1
  prob                          = 1.5
end

local math_atan2   = math.atan2
local table_remove = table.remove
local table_sort   = table.sort
local string_find  = string.find
local string_gsub  = string.gsub

local bInit             = false
local news_stack        = {}
local table_spawned     = {}
local table_spawned_idx = {}
local spammers          = {}


function init()
  if bInit then return end
  news_data.Init()
  timer_blow_showed     = amk.game_minutes() - math.random( timer_blow_freq )
  timer_heli_showed     = amk.game_minutes() - math.random( timer_heli_freq )
  timer_weather_showed  = amk.game_minutes() - math.random( timer_weather_freq )
  timer_daytime_showed  = amk.game_minutes() - math.random( timer_daytime_freq )
  ogse_signals.get_mgr():subscribe({
    signal = "on_update", fun = this.on_update
  })
  bInit = true
end


function on_update()
  ogse_signals.get_mgr():reschedule( 36000 )
  check_news()
end


function dbglog( fmt )
  if _debug then
    log2( "[%s]: %s", script_name(), fmt )
  end
end


function mylog( text )
  dbglog( "==> " .. text)
end


function trace( fmt )
  log2( "[%s]: %s", script_name(), fmt )
end


function do_debug( title, text )
  if _debug then
    local m_title = title or ""
    local m_text  = text  or ""
    do_news( m_text, m_title, nil, 5, "gen_info" )
  end
  mylog( title .. ": " .. text )
end


function on_spawn_group( community, lname, position, count, o_type )
  local m_str
  -- o_type = 1 - НПС
  -- o_type = 2 - монстры
  if o_type == 2 then
    local mon = community
    if mon == "" then return end
    if math.random() < prob_spawn_monster then
      if count == 1 then
        m_str = format_template_spawn(
          lname, position, get_monster_name_by_string( mon, 4 )
        )
      else
        m_str = format_template_spawn_group(
          lname, position, get_monster_name_by_string( mon, 6 ), count
        )
      end
    end
  elseif o_type == 1 then
    if math.random() < prob_spawn_stalker then
      local zz    = community
      local m_who = ""
      if zz and news_data.community_name[ zz ] then
        if zz == "actor" or zz == "trader" or friends_comm[ zz ] then -- это сталкер
          return
        end
        if count == 1 then
          m_who = news_data.community_name[ zz ][ 3 ]
        else
          m_who = news_data.community_name[ zz ][ 4 ]
        end
      end
      if m_who == "" then return end
      if count == 1 then
        m_str = format_template_spawn( lname, position, m_who )
      else
        m_str = format_template_spawn_group( lname, position, m_who, count )
      end
    end
  end
  if m_str then
    local author = ( level.name() == lname )
      and get_nearest_stalker( lname, position, dist_seen, 0 )
      or  get_random_stalker(  lname )
    if author then
      local s_author = get_npc_name( author )
      do_news(
        m_str, s_author, math.random( timer_spawn, timer_spawn * 5 ), 5,
        "gen_info", author.id
      )
    end
  end
end


function on_spawn( obj )
  -- Кто-то где-то появился.
  -- Если монстрики - то кто-то мог видеть.
  -- Или вояки\бандиты...
  if obj then
    add_spawned_object( obj )
  end
end


-- Дали по роже
function on_abuse( obj )
  if not ( obj and obj:alive() ) then return end
  local str = news_data.abuse_templates[
    math.random( table.getn( news_data.abuse_templates ) )
  ]
  local m_name = get_npc_name( obj )
  if not ( m_name and m_name ~= "" ) then
    local name, sname = amk_names_lists.get_strings()
    m_name = name .. " " .. sname
  end
  do_news(
    str, m_name, math.random( timer_spawn, timer_spawn * 5 ), 5, "stalker",
    obj:id()
  )
end


function on_death( victim, killer )
  if not victim then return end
  local m_comm = get_npc_community( victim )
  if friends_comm[ m_comm ] then
    on_stalker_death( victim, killer )
  else
    on_npc_death( victim, killer )
  end
end


function get_killed_by_weapon( victim )
  return ogse_hitfx.get_ammo_sect( victim )
end


-- Погиб сталкер.
-- Собираем инфу о погибшем
-- Собираем инфу о виновнике смерти
-- Готовим сообщение
function on_stalker_death( victim, killer )
  local m_killer     = ""
  local m_killer_str = ""
  local m_name       = get_npc_name( victim )
  local m_victim     = format_death_stalker_corpse( victim )
  local m_level      = get_level_name( get_object_levelname( victim ) )
  if killer then
    if killer:is_monster() then
      m_killer     = format_death_by_monster( killer )
      m_killer_str = get_monster_name( killer, 2 )
    elseif IsAnomaly( killer ) then
      m_killer     = format_death_by_anomaly( killer )
      m_killer_str = get_anomaly_name( killer, 1 )
    elseif
      IsNpcStalker( killer ) or IsNpcOther( killer )
      or killer:is_grenade() or killer:is_explosive()
    then
      local ammo, m_o_weapon = get_killed_by_weapon( victim )
      local m_s_weapon = ""
      if m_o_weapon then
        m_s_weapon = get_weapon_type( m_o_weapon, ammo )
        if     m_s_weapon  < 5 then m_killer_str = "пулевое ранение"
        elseif m_s_weapon == 6 then m_killer_str = "нож"
        elseif m_s_weapon == 8 then m_killer_str = "ожоги"
        elseif m_s_weapon == 7 or m_s_weapon == 5 then
          m_killer_str = "граната"
        end
      else
        log2(
          "[%s]: %s killed by weapon: %s, weapon unknown",
          script_name(), victim:name(), killer:name()
        )
      end
      m_killer = format_death_by_stalker( victim, killer )
    else
      log2(
        "[%s]: %s killed by unknown type: %s",
        script_name(), victim:name(), killer:name()
      )
      m_killer_str = "причина смерти - неизвестна"
      m_killer     = ""
    end
  end
  if ( not m_killer_str ) or m_killer_str == "" then
    m_killer_str = "причина смерти - неизвестна"
    log2(
      "[%s]: %s killed by unknown: %s",
      script_name(), victim:name(),
      ( killer and killer:name() or "nil" )
    )
  end
  local m_string = m_name .. ". " .. m_level .. ", " .. m_killer_str .. "."

  if math.random() < 0.5 then   -- слишком часто приходят смс о смерти
    do_news(
      m_string, "Погиб сталкер:",
      math.random( timer_stalker_death, timer_stalker_death * 3 ),
      5, "death", nil, 1
    )
  end

  if math.random() < prob then
    local name, sname = amk_names_lists.get_strings()
    local s_author    = name.." "..sname
    local m_str       = ""
    local author
    if math.random() < 0.5 then
      if math.random() < 0.5 then
        m_str = m_victim .. " " .. m_killer
      else
        m_str = m_victim
      end
      author = get_nearest_stalker(
        get_object_levelname( victim ), get_object_position( victim ),
        dist_seen, 0
      )
      if author then
        s_author = get_npc_name( author )
      else
        return
      end
    else
      author = get_nearest_stalker(
        get_object_levelname( victim ), get_object_position( victim ),
        dist_hear_max, dist_hear_min
      )
      if author then
        s_author = get_npc_name( author )
      else
        return
      end
      m_str = format_death_hear_sounds( victim, killer )
    end
    if m_str ~= "" then
      do_news(
        m_str, s_author, math.random(timer_corpse*2, timer_corpse *5), 5,
        "gen_info", author.id
      )
    end
  end
end


-- Погиб кто-то, но не сталкер (военный, бандит, наемник...)
-- Посмотреть, попадают ли сюда Долг\Свобода
-- Собираем инфу о погибшем
-- Собираем инфу о виновнике смерти
-- Готовим сообщение
function on_npc_death( victim, killer )
  local m_killer = ""
  local m_victim = format_death_npc_corpse( victim )
  if killer then
    if killer:is_monster() then
      m_killer = format_death_by_monster( killer )
    elseif IsNpcStalker( killer ) then -- Хм, и кто ж его так? Или свои, или ГГ
      m_killer = format_death_by_stalker( victim, killer )
    elseif
      IsNpcOther( killer ) or killer:is_grenade() or killer:is_explosive()
    then
      -- Ага. Или бандиты, или вояки, или киллеры... Вобщем, люди.
      m_killer = format_death_by_stalker( victim, killer )
    elseif IsAnomaly( killer ) then
      m_killer = format_death_by_anomaly( killer )
    else
      log2(
        "[%s]: %s killed by unknown: %s",
        script_name(), victim:name(), killer:name()
      )
    end
  else
    log2( "[%s]: %s killed by unknown", script_name(), victim:name() )
  end
  if math.random() < prob then
    local name, sname = amk_names_lists.get_strings()
    local s_from = ""
    local m_str  = ""
    local aid
    if math.random() < 0.5 then
      if math.random() < 0.5 then
        m_str = m_victim .. " " .. m_killer
      else
        m_str = m_victim
      end
      local author = get_nearest_stalker(
        get_object_levelname( victim ), get_object_position( victim ),
        dist_seen, 0
      )
      if author then
        s_from = get_npc_name( author )
        aid    = author.id
      else
        return
      end
    else
      if
        math.random() < 0.5
        and db.actor:id() ~= killer:id() and IsNpcStalker( killer )
      then
        m_str  = format_template_killer_act( victim )
        s_from = get_npc_name( killer )
      else
        local author = get_nearest_stalker(
          get_object_levelname( victim ), get_object_position( victim ),
          dist_hear_max, dist_hear_min
        )
        if author then
          s_from = get_npc_name( author )
          aid    = author.id
        else
          return
        end
        m_str = format_death_hear_sounds( victim, killer )
      end
    end
    if m_str ~= "" and s_from ~= "" then
      do_news(
        m_str, s_from, math.random( timer_corpse * 2, timer_corpse * 5 ), 5,
        "gen_info", aid
      )
    end
  end
end


function get_obj( id )
  local m_obj
  if id then
    m_obj = level.object_by_id( id )
  end
  return m_obj
end


function get_level_name( level_, index )
  if not index then index = 1 end
  local m_s_level
  if not level_ then
    m_s_level = level.name()
  else
    m_s_level = level_
  end
  local m_tmp_str = ""
  if news_data.level_name[ m_s_level ] then
    if news_data.level_name[ m_s_level ][ index ] then
      m_tmp_str = news_data.level_name[ m_s_level ][ index ]
    end
  end
  return m_tmp_str
end


function get_level_subname()
  return level.name()
end

function get_current_time()
  local m_time = "00:00"
  if level then
    local m_h = level:get_time_hours()
    local m_m = level:get_time_minutes()
    m_time = m_h .. ":" .. m_m
  end
  return m_time
end


local cached_npc_names = {}
function get_npc_name( obj )
  local m_s_name = ""
  if obj then
    if isGameObject( obj ) then
      if obj.character_name then
        m_s_name = obj:character_name()
      end
    else
      local ob = get_obj( obj.id )
      if ob and ob.character_name then
        m_s_name = ob:character_name()
      else
        if cached_npc_names[ obj:name() ] then
          m_s_name = cached_npc_names[ obj:name() ]
        else
          if IsNpcStalker( obj ) then
            local trader = obj:get_trader()
            ASSERT(
              trader, "[%s]: %s: get_trader() == nil",
              script_name(), obj:name()
            )
            m_s_name = trader.character_name
            cached_npc_names[ obj:name() ] = m_s_name
          end
        end
      end
    end
  end
  if not m_s_name then m_s_name = "" end
  return m_s_name
end


function get_npc_community( obj )
  local m_s_c = ""
  if obj then
    if IAmAMonster[ obj:clsid() ] then
      m_s_c = get_monster_name( obj, 1 )
    else
      if obj.character_community then
        m_s_c = obj:character_community()
      elseif obj.community then
        m_s_c = obj:community()
      end
    end
  end
  if not m_s_c then m_s_c = "" end
  return m_s_c
end


function get_object_position( obj )
  local pos
  if obj then
    if type( obj.position ) == "function" then
      pos = obj:position()
    else
      pos = obj.position
    end
  end
  return pos
end


function get_object_name( obj )
  local sect   = isGameObject( obj ) and obj:section() or obj:section_name()
  local s_name = game.translate_string( get_string( sect, "inv_name", "" ) )
  if dsh.is_artefact( sect ) then
    s_name = "артефакт " .. s_name
  end
  if not s_name then s_name = "" end
  return s_name
end


-- "type1" =  --"Пистолет "..m_act:section()
-- "type2" =  --"Винтовка "..m_act:section()
-- "type3" =  --"Автомат "..m_act:section()
-- "type4" =  --"Обрез "..m_act:section()
-- "type5" =  --"Гранатомет "..m_act:section()
-- "type6" =  --"Нож "..m_act:section()
-- "type7" =  --"Граната "..m_act:section()
-- "type8" =  --"Огнемёт "..m_act:section()

function get_weapon_type( weapon, ammo )
  local tp = get_u32( ammo, "news_main.weapon_type" )
  if not tp then
    tp = get_u32( weapon:section(), "news_main.weapon_type", 0 )
  end
  return tp
end


function get_monster_name( obj, index )
  local m_n = ""
  if obj then
    local m_clsid = obj:clsid()
    if not index then index = 1 end
    if IAmAMonster[ m_clsid ] then
      local sect   = obj.section_name and obj:section_name() or obj:section()
      local keys   = { sect, m_clsid }
      local found  = false
      for _, k in pairs( keys ) do
        local m_comm = news_data.monster_classes[ k ]
        if m_comm then
          found = true
          if m_comm[ index ] then
            m_n = m_comm[ index ]
          else
            trace(
              "Unknown monster name for class_id: " .. m_clsid
                .. " index=" .. index .. " section=" .. sect
            )
          end
          break
        end
      end
      if not found then
        trace(
          "Unknown monster class_id: " .. m_clsid .. " for " .. obj:name()
        )
      end
    end
  end
  return m_n
end


function get_monster_name_by_string(str, index)
	local m_comm = ""
	local m_n = ""
	if index == nil then index = 1 end
	if index < 1 then index = 1 end
	if(str) then
		for k, v in pairs(news_data.monster_classes) do
			if (v and #v >= index and v[1] == str) then
				m_n = v[index]
			end
		end
	end
	return m_n
end

function get_npc_rank(obj)
	local m_rank = ""
	if (obj) then
		m_rank = ranks.get_obj_rank_name(obj)
		if (m_rank == nil) then
			m_rank = ""
		end
	end
	return m_rank
end

function get_monster_rank(obj)
	local m_rank = ""
	if (obj) then
		if (obj and IAmAMonster[obj:clsid()]) then
			m_rank = ranks.get_obj_rank_name(obj)
			if (m_rank == nil) then
				m_rank = ""
			end
		end
	end
	return m_rank
end

function get_anomaly_name(obj, index)
	local m_name = ""
	local m_n = ""
	if index == nil then index = 1 end
	if (IsAnomaly(obj)) then
		local m_type = ""		
		if (isGameObject(obj) and obj.section) then
			m_type = obj:section()
		elseif (obj.section_name) then
			m_type = obj:section_name()
		end
		if m_type then
			for k,v in pairs(news_data.anomaly_classes) do
				if string_find(m_type, k) then
					if (v[index] ~= nil) then
						m_n = v[index]
					end
					break
				end
			end
		end
	end
	return m_n
end


function IsNpcOther( obj )
  if obj and IsStalker( obj ) then
    local m_comm = get_npc_community(obj)
    if
      m_comm == "actor" or m_comm == "actor_dolg" or m_comm == "actor_freedom"
      or friends_comm[ m_comm ]
    then
      return false
    end
    return true
  else
    return false
  end
end


function IsNpcStalker( obj )
  if obj and IsStalker( obj ) then
    local m_comm = get_npc_community(obj)
    if
      m_comm == "actor" or m_comm == "actor_dolg" or m_comm == "actor_freedom"
      or friends_comm[ m_comm ]
    then
      if obj.name and obj:name() ~= "agr_ratcatcher" then
        return true
      end
    end
  end
  return false
end


function IsNpcActor(obj)
	if (obj and IAmAStalker[obj:clsid()]) then
		local m_comm  = get_npc_community(obj)
		if (m_comm == "actor" or m_comm == "actor_dolg" or m_comm == "actor_freedom") then
			return true
		end
	end
	return false
end

function IsAnomaly(obj)
	if (obj) then
		local otype = get_clsid(obj)
		if (otype>172 and otype<180) then
			return true
		else		
		end
	end
	return false
end


function do_news( text, from, timeout, showtime, section, author_id, priority )
  if not timeout  then timeout  = 0 end
  if not priority then priority = 0 end
  add_news(
    text, from, 1, timeout, ( showtime or 5 ), section, author_id, priority
  )
end


function add_news( news_text, news_from, news_type, news_timeout, news_showtime, news_section, author_id, priority )
  local newsitem = {
    [ "author_id" ] = tonumber( author_id ),
    [ "created"   ] = amk.game_minutes(),
    [ "eventType" ] = news_type,
    [ "from"      ] = news_from,
    [ "lifetime"  ] = amk.game_minutes() + 25 + news_timeout / 60,
    [ "priority"  ] = priority,
    [ "section"   ] = news_section,
    [ "showtime"  ] = news_showtime,
    [ "text"      ] = news_text,
    [ "timeout"   ] = amk.game_minutes() + news_timeout / 60,
  }
  table.insert( news_stack, newsitem )
end


local time_factor = get_float( "alife", "time_factor" )

function show_news( text, from, timeout, showtime, section, sound )
  if isIsolatedLevel( level.name() ) then return end
  if text == "" then return end
  if from == "" then return end
  local blow = amk.load_variable( "blowout", -1 )
  if blow > -1 and blow < 5 then return end
  if timer_next_blow ~= 0 then
    -- Разница в игровых секундах.
    local diff = ( timer_next_blow - amk.game_minutes() ) * 60
    -- Сколько пройдет игровых минут
    local eventtime = timeout * time_factor
    if eventtime >= diff then return end
  end

  if timeout > 1000 then
    timeout = math.random( timer_general, timer_general * 4 )
  end
  spammers[ from ] = time_global()

  if not (
    ogse_sleep_mgr.is_sleep_active()
  ) then
    amk.send_tip( text, from, timeout, showtime, section, sound )
  end
end


function format_death_by_monster(obj)
	local rnd = math.random
	local m_s = ""
	local m_prefix = ""
	local m_suffix = ""
	local m_class = ""
	local m_postfix = ""
	if (obj) then
	-- monster_prefix + monster_classes + monster_suffix
	-- monster_suffix + monster_classes + monster_prefix
		m_prefix = news_data.monster_prefix[rnd(#news_data.monster_prefix)].." "
		local m_suffid = rnd(#news_data.monster_suffix)
		local m_suff = news_data.monster_suffix[m_suffid]
		if (m_suff) then
			m_suffix = m_suff[rnd(#m_suff)]
			m_class = get_monster_name(obj, m_suffid+1)
			m_postfix = news_data.rate_postfix[rnd(#news_data.rate_postfix)]
		end
		if (rnd() < 0.5) then
			m_s = m_prefix..""..m_suffix..""..m_class.."."..m_postfix
		else
			m_s = m_suffix..""..m_class..". "..m_prefix..""..m_postfix
		end
	end
	return m_s
end

function format_death_by_anomaly(obj)
	local rnd = math.random
	local m_s = ""
	local m_prefix = ""
	local m_suffix = ""
	local m_class = ""
	--local m_postfix = ""
	if (obj) then
	-- anomaly_prefix + anomaly_classes + anomaly_classes[3,4]
		m_prefix = news_data.anomaly_prefix[rnd(#news_data.anomaly_prefix)]
		m_class = get_anomaly_name(obj, 2)
		m_suffix = get_anomaly_name(obj, rnd(3, 4))
		--m_postfix = anomaly_postfix[rnd(#anomaly_postfix)]
		if (rnd() < 0.5) then
			m_s = m_prefix..""..m_class..". "..m_suffix.."." --..m_postfix.."."
		else
			m_s = m_prefix..""..m_class.."." --..m_postfix.."."
		end
	end
	return m_s
end


function format_death_by_stalker( victim, obj )
  local m_s = ""
  if obj then
    local ammo, m_wpn = get_killed_by_weapon( victim )
    if m_wpn then
      local m_weapon = get_weapon_type( m_wpn, ammo )
      if m_weapon > 0 then
        m_s = format_template_weapon( m_weapon )
      end
    end
  end
  return m_s
end


function format_death_stalker_corpse(obj)
	local m_s = ""
	if (obj) then
		m_s = format_template_corpse_stalker(obj)
	end
	return m_s
end

function format_death_npc_corpse(obj)
	local m_s = ""
	if (obj) then
		m_s = format_template_corpse_npc(obj)
	end
	return m_s
end

function format_death_monster_corpse(obj)
	local m_s = ""
	if (obj) then
		m_s = format_template_corpse_monster(obj)
	end
	return m_s
end


function format_death_hear_sounds( victim_, killer_ )
  local m_s      = ""
  local m_hear_a = ""
  local m_hear_z = ""
  if victim_ then
    if killer_ and ( IsNpcStalker( killer_ ) or IsNpcOther( killer_ ) ) then
      -- Если killer == НПС - то стрельбу или взрывы
      local ammo, m_wpn = get_killed_by_weapon( victim_ )
      if m_wpn then
        local m_weapon = get_weapon_type( m_wpn, ammo )
        if m_weapon == 0 then return "" end
        local t = news_data.weapon_classes[ m_weapon ]
        if t then
          if math.random() > t.hear_p then
            -- Ничего не услышали, слишком тихое оружие...
            return ""
          end
          m_hear_a = t.hear_a[ math.random( table.getn( t.hear_a ) ) ]
          m_hear_z = t.hear_z[ math.random( table.getn( t.hear_z ) ) ]
          m_s      = format_template_hear( victim_, m_hear_a, m_hear_z )
        end
      end
    elseif
      killer_ and ( IsAnomaly( killer_ ) or killer_:is_monster() )
    then
      -- Если killer == аномалия и victim ~= монстры - то крики
      m_hear_a = "Слышал ужасные крики"
      m_hear_z = "слышал ужасные крики"
      m_s      = format_template_hear( victim_, m_hear_a, m_hear_z )
    end
  end
  return m_s
end


function format_template_killer_act(obj)
	local rnd = math.random
	local m_s = ""
	if(obj ~= nil) then
		local m_class = ""
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj))
		if (m_level == "") then return "" end
		if IAmAMonster[obj:clsid()] then
			m_class = get_monster_name(obj, 4)
		else
			local m_comm  = get_npc_community(obj)
			if (m_comm and news_data.community_name[m_comm]) then
				m_class = news_data.community_name[m_comm][3]
			end
		end
		local t = {
			["class"] = m_class,
			["level"] = m_level,
			["killed_a"] = news_data.common["killed_a"][rnd(#news_data.common["killed_a"])],
			["killed_z"] = news_data.common["killed_z"][rnd(#news_data.common["killed_z"])],
			["hard_a"] = news_data.common["hard_a"][rnd(#news_data.common["hard_a"])],
			["hard_z"] = news_data.common["hard_z"][rnd(#news_data.common["hard_z"])],
			["meet_a"] = news_data.common["meet_a"][rnd(#news_data.common["meet_a"])],
			["meet_z"] = news_data.common["meet_z"][rnd(#news_data.common["meet_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]			
		}
		local m_string = news_data.killer_act_templates[rnd(#news_data.killer_act_templates)]			
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_heli(obj, template_type)
	local rnd = math.random
	local m_s = ""
	local m_level = ""
	local m_pos
	if (obj ~= nil and template_type and news_data.heli_templates[template_type]) then
		m_pos = get_object_position(obj)
		if (m_pos) then
			m_level = get_point_description(get_object_levelname(obj), m_pos)
			if (m_level == "") then return "" end
		end
		local t = {
			["level"] = m_level, 
			["carefull_a"] = news_data.common["carefull_a"][rnd(#news_data.common["carefull_a"])],
			["carefull_z"] = news_data.common["carefull_z"][rnd(#news_data.common["carefull_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]
		}
		local m_string = news_data.heli_templates[template_type][rnd(#news_data.heli_templates[template_type])]		
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_weapon(weapon_type)
	local rnd = math.random
	local m_s = ""
	if(weapon_type and news_data.weapon_classes[weapon_type] ~= nil and news_data.weapon_classes[weapon_type]["name"]) then
		local t = {
			["weapon_name_2"] = news_data.weapon_classes[weapon_type]["name"][2],
			["weapon_name_3"] = news_data.weapon_classes[weapon_type]["name"][3],
			["weapon_hit_a"] = news_data.weapon_classes[weapon_type]["hit_a"][rnd(#news_data.weapon_classes[weapon_type]["hit_a"])],
			["weapon_hit_z"] = news_data.weapon_classes[weapon_type]["hit_z"][rnd(#news_data.weapon_classes[weapon_type]["hit_z"])],
			["kill_a"] = news_data.common["kill_a"][rnd(#news_data.common["kill_a"])],
			["kill_z"] = news_data.common["kill_z"][rnd(#news_data.common["kill_z"])],
			["sad_a"] = news_data.common["sad_a"][rnd(#news_data.common["sad_a"])],
			["sad_z"] = news_data.common["sad_z"][rnd(#news_data.common["sad_z"])],
			["fun_a"] = news_data.common["fun_a"][rnd(#news_data.common["fun_a"])],
			["fun_z"] = news_data.common["fun_z"][rnd(#news_data.common["fun_z"])],
			["prob_a"] = news_data.common["prob_a"][rnd(#news_data.common["prob_a"])],
			["prob_z"] = news_data.common["prob_z"][rnd(#news_data.common["prob_z"])]
		}
		local m_string = news_data.weapon_templates[rnd(#news_data.weapon_templates)]			
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_corpse_stalker(obj)
	local rnd = math.random
	local m_s = ""
	if(obj ~= nil) then
		local m_name  = get_npc_name(obj)
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj)) 
		if (m_level == "") then return "" end
		local m_rank  = get_npc_rank(obj)
		local m_rank_s = ""
		if (m_rank and news_data.rate_name[m_rank]) then
			m_rank_s = news_data.rate_name[m_rank][rnd(2, #news_data.rate_name[m_rank])]
		end
		local t = {
			["name"] = m_name,
			["level"] = m_level,
			["rate"] = m_rank_s,
			["kill_a"] = news_data.common["kill_a"][rnd(#news_data.common["kill_a"])],
			["kill_z"] = news_data.common["kill_z"][rnd(#news_data.common["kill_z"])],
			["sad_a"] = news_data.common["sad_a"][rnd(#news_data.common["sad_a"])],
			["sad_z"] = news_data.common["sad_z"][rnd(#news_data.common["sad_z"])],
			["fun_a"] = news_data.common["fun_a"][rnd(#news_data.common["fun_a"])],
			["fun_z"] = news_data.common["fun_z"][rnd(#news_data.common["fun_z"])],
			["prob_a"] = news_data.common["prob_a"][rnd(#news_data.common["prob_a"])],
			["prob_z"] = news_data.common["prob_z"][rnd(#news_data.common["prob_z"])],
			["corpse_a"] = news_data.common["corpse_a"][rnd(#news_data.common["corpse_a"])],
			["corpse_z"] = news_data.common["corpse_z"][rnd(#news_data.common["corpse_z"])],
			["seen_a"] = news_data.common["seen_a"][rnd(#news_data.common["seen_a"])],
			["seen_z"] = news_data.common["seen_z"][rnd(#news_data.common["seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]			
		}
		local m_string = news_data.stalker_corpse_templates[rnd(#news_data.stalker_corpse_templates)]
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_corpse_npc(obj)
	local rnd = math.random
	local m_s = ""
	if(obj ~= nil) then
		local m_name  = get_npc_name(obj)
		if (m_name == "") then
			m_name = "недавно в Зоне"
			local m_rank  = get_npc_rank(obj)
			local m_rank_s = ""
			if (m_rank and news_data.rate_name[m_rank]) then
				m_rank_s = news_data.rate_name[m_rank][rnd(2, #news_data.rate_name[m_rank])]
				m_name = m_rank_s
			end					
		end
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj))
		if (m_level == "") then return "" end
		local m_comm  = get_npc_community(obj)
		local m_class = ""
		if (m_comm and news_data.community_name[m_comm]) then
			m_class = news_data.community_name[m_comm][3]
		end
		local t = {
			["name"] = m_name,
			["level"] = m_level,
			["class"] = m_class,
			["kill_a"] = news_data.common["kill_a"][rnd(#news_data.common["kill_a"])],
			["kill_z"] = news_data.common["kill_z"][rnd(#news_data.common["kill_z"])],
			["sad_a"] = news_data.common["sad_a"][rnd(#news_data.common["sad_a"])],
			["sad_z"] = news_data.common["sad_z"][rnd(#news_data.common["sad_z"])],
			["fun_a"] = news_data.common["fun_a"][rnd(#news_data.common["fun_a"])],
			["fun_z"] = news_data.common["fun_z"][rnd(#news_data.common["fun_z"])],
			["prob_a"] = news_data.common["prob_a"][rnd(#news_data.common["prob_a"])],
			["prob_z"] = news_data.common["prob_z"][rnd(#news_data.common["prob_z"])],
			["corpse_a"] = news_data.common["corpse_a"][rnd(#news_data.common["corpse_a"])],
			["corpse_z"] = news_data.common["corpse_z"][rnd(#news_data.common["corpse_z"])],
			["corpse_name_a"] = news_data.common["corpse_name_a"][rnd(#news_data.common["corpse_name_a"])],
			["corpse_name_z"] = news_data.common["corpse_name_z"][rnd(#news_data.common["corpse_name_z"])],
			["seen_a"] = news_data.common["seen_a"][rnd(#news_data.common["seen_a"])],
			["seen_z"] = news_data.common["seen_z"][rnd(#news_data.common["seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]			
		}
		local m_string = news_data.npc_corpse_templates[rnd(#news_data.npc_corpse_templates)]			
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_corpse_monster(obj)
	local rnd = math.random
	local m_s = ""
	if(obj ~= nil) then
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj))
		if (m_level == "") then return "" end		
		local m_name  = get_monster_name(obj, 3)
		local m_name2 = get_monster_name(obj, 4)
		local t = {
			["name"] = m_name,
			["class"] = m_name2,
			["c_corpse"] = m_name,
			["level"] = m_level,
			["kill_a"] = news_data.common["kill_a"][rnd(#news_data.common["kill_a"])],
			["kill_z"] = news_data.common["kill_z"][rnd(#news_data.common["kill_z"])],
			["sad_a"] = news_data.common["sad_a"][rnd(#news_data.common["sad_a"])],
			["sad_z"] = news_data.common["sad_z"][rnd(#news_data.common["sad_z"])],
			["fun_a"] = news_data.common["fun_a"][rnd(#news_data.common["fun_a"])],
			["fun_z"] = news_data.common["fun_z"][rnd(#news_data.common["fun_z"])],
			["prob_a"] = news_data.common["prob_a"][rnd(#news_data.common["prob_a"])],
			["prob_z"] = news_data.common["prob_z"][rnd(#news_data.common["prob_z"])],
			["corpse_a"] = news_data.common["corpse_a"][rnd(#news_data.common["corpse_a"])],
			["corpse_z"] = news_data.common["corpse_z"][rnd(#news_data.common["corpse_z"])],
			["seen_a"] = news_data.common["seen_a"][rnd(#news_data.common["seen_a"])],
			["seen_z"] = news_data.common["seen_z"][rnd(#news_data.common["seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]			
		}
		local m_string = news_data.monster_corpse_templates[rnd(#news_data.monster_corpse_templates)]			
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_hear(obj, hear_a, hear_z)
	local rnd = math.random
	local m_s = ""
	local m_level = ""
	local m_pos
	if (obj) then
		if (isGameObject(obj)) then
			m_pos = obj:position()
		else
			m_pos = obj.position
		end
		if (m_pos) then
			m_level = get_point_description(get_object_levelname(obj), m_pos)
			if (m_level == "") then return "" end			
		end
		local t = {
			["level"] = m_level, 
			["hear_a"] = hear_a,
			["hear_z"] = hear_z,
			["carefull_a"] = news_data.common["carefull_a"][rnd(#news_data.common["carefull_a"])],
			["carefull_z"] = news_data.common["carefull_z"][rnd(#news_data.common["carefull_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]			
		}
		local m_string = news_data.hear_sounds_tempates[rnd(#news_data.hear_sounds_tempates)]		
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_spawn(level_, position, class)
	local rnd = math.random
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end			
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["carefull_a"] = news_data.common["carefull_a"][rnd(#news_data.common["carefull_a"])],
			["carefull_z"] = news_data.common["carefull_z"][rnd(#news_data.common["carefull_z"])],
			["seen_a"] = news_data.common["spawn_seen_a"][rnd(#news_data.common["spawn_seen_a"])],
			["seen_z"] = news_data.common["spawn_seen_z"][rnd(#news_data.common["spawn_seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]
		}
		local m_string = news_data.spawn_templates[rnd(#news_data.spawn_templates)]		
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_spawn_group(level_, position, class, count)
	local rnd = math.random
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class and count) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end			
		local s_count = ""
		if (count == 1) then
			s_count = "одного"
		elseif(count == 2) then
			s_count = "парочку"
		elseif(count == 3) then
			s_count = "несколько"
		elseif(count >= 4 and count < 6) then
			s_count = "группу"
		elseif(count >= 6 and count < 8) then
			s_count = "большую группу"
		else
			--s_count = "большую группу ("..count..")"
			s_count = "кучу"
		end
		
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["count"] = s_count,
			["carefull_a"] = news_data.common["carefull_a"][rnd(#news_data.common["carefull_a"])],
			["carefull_z"] = news_data.common["carefull_z"][rnd(#news_data.common["carefull_z"])],
			["seen_a"] = news_data.common["spawn_seen_a"][rnd(#news_data.common["spawn_seen_a"])],
			["seen_z"] = news_data.common["spawn_seen_z"][rnd(#news_data.common["spawn_seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])]
		}
		local m_string = news_data.spawn_templates_group[rnd(#news_data.spawn_templates_group)]		
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_actor_seen(level_, position, class)
	local rnd = math.random
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end			
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["kill_seen_a"] = news_data.common["kill_seen_a"][rnd(#news_data.common["kill_seen_a"])],
			["kill_seen_z"] = news_data.common["kill_seen_z"][rnd(#news_data.common["kill_seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])],
			["fun_a"] = news_data.common["fun_a"][rnd(#news_data.common["fun_a"])],
			["fun_z"] = news_data.common["fun_z"][rnd(#news_data.common["fun_z"])],
			["killed_a"] = news_data.common["killed_a"][rnd(#news_data.common["killed_a"])],
			["killed_z"] = news_data.common["killed_z"][rnd(#news_data.common["killed_z"])],
			["cool_a"] = news_data.common["cool_a"][rnd(#news_data.common["cool_a"])],
			["cool_z"] = news_data.common["cool_z"][rnd(#news_data.common["cool_z"])]						
		}
		local m_string = ""
		m_string = news_data.actor_seen_public_templates[rnd(#news_data.actor_seen_public_templates)]		
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_actor_seen_group(level_, position, class, count)
	local rnd = math.random
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class and count) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end			
		local s_count = ""
		if (count == 1) then
			s_count = ""
		elseif(count == 2) then
			s_count = "парочку"
		elseif(count == 3) then
			s_count = "несколько"
		elseif(count >= 4 and count < 6) then
			s_count = "группу"
		else
			s_count = "большую группу"
		end
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["count"] = s_count,
			["fun_a"] = news_data.common["fun_a"][rnd(#news_data.common["fun_a"])],
			["fun_z"] = news_data.common["fun_z"][rnd(#news_data.common["fun_z"])],
			["kill_seen_a"] = news_data.common["kill_seen_a"][rnd(#news_data.common["kill_seen_a"])],
			["kill_seen_z"] = news_data.common["kill_seen_z"][rnd(#news_data.common["kill_seen_z"])],
			["when_a"] = news_data.common["when_a"][rnd(#news_data.common["when_a"])],
			["when_z"] = news_data.common["when_z"][rnd(#news_data.common["when_z"])],
			["killed_a"] = news_data.common["killed_a"][rnd(#news_data.common["killed_a"])],
			["killed_z"] = news_data.common["killed_z"][rnd(#news_data.common["killed_z"])],
			["cool_a"] = news_data.common["cool_a"][rnd(#news_data.common["cool_a"])],
			["cool_z"] = news_data.common["cool_z"][rnd(#news_data.common["cool_z"])]						
		}
		local m_string = ""
		m_string = news_data.actor_seen_public_templates_group[rnd(#news_data.actor_seen_public_templates_group)]		
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end


local angle2str = {
	[ "северо-восток" ]	= { 30, 60 },
	[ "север" ]			= { 60, 120 },
	[ "северо-запад" ]	= { 120, 150 },
	[ "запад" ]			= { 150, 210 },
	[ "юго-запад" ]		= { 210, 240 },
	[ "юг" ]			= { 240, 300 },
	[ "юго-восток" ]	= { 300, 330 }
}


function get_point_description( level, point )
	if level == nil or (
		( level == "l10u_bunker"
		or level == "l11_pripyat" 
		or level == "l12_stancia"
		or level == "l12_stancia_2"
		or level == "l12u_control_monolith"
		or level == "l12u_sarcofag" )
		and isRadarDeactivated() == false
	) then
		return ""
	end
	
	local m_tmp_str = ""

	local tbl = news_data.level_name[ level ]
	if tbl and tbl[ 2 ] then
		m_tmp_str = tbl[ 2 ]
	else
		return ""
	end

	local m_points = news_data.base_points[ level ]
	if not ( m_points and point ) then return m_tmp_str end

	local dist = math.huge
	local m_dist = 0
	local m_point, i_point = nil, nil
	for i, value in ipairs( m_points ) do
		m_point = vector():set( unpack( value["p"] ) )
		m_dist = m_point:distance_to_sqr( point ) 
		if m_dist < dist then
			dist = m_dist
			i_point = i
		end
	end

	local t_point = m_points[ i_point ]

	local r = t_point.r0 or 20
	dist = math.sqrt( dist )
	if dist <= r then
		m_tmp_str = m_tmp_str.." "..t_point.text0
	elseif dist < r + 30 then
		m_tmp_str = m_tmp_str.." возле "..t_point.text
	elseif dist < r + 70 then
		m_tmp_str = m_tmp_str.." около "..t_point.text
	else --Говорим, куда (север, юг...)
		m_point = vector():set( unpack( t_point.p ) )
		local dir = point:sub( m_point )
		local angle = math_atan2( dir.z, dir.x ) *57
		if angle < 0 then angle = angle + 360
		elseif angle > 360 then angle = angle - 360 end

		local s_dir = "восток"
		for str, t in pairs( angle2str ) do
			if angle > t[ 1 ] and angle <= t[ 2 ] then
				s_dir = str
				break
			end
		end
		m_tmp_str = m_tmp_str.." к "..s_dir.."у от "..t_point.text
	end

	return m_tmp_str
end


--[=[
function get_point_description(level, point)
	local m_s = ""
	local dist = 10000
	local angle = 0	
	local m_tmp_str = ""
	if (level == "l10u_bunker" or level == "l11_pripyat" or level == "l12_stancia" or level == "l12_stancia_2" or level == "l12u_control_monolith" or level == "l12u_sarcofag") then
		if (isRadarDeactivated() == false) then	return "" end
	end
	if (level and news_data.level_name[level] ~= nil) then
		if (news_data.level_name[level][2] ~= nil) then
			m_tmp_str = news_data.level_name[level][2]..""
		end
	end	
	if (level and news_data.base_points[level] and point) then
		local m_str = ""
		local m_str0 = ""
		local m_point = nil
		local m_dist = 0
		local m_points = news_data.base_points[level]
		local dx = 0
		local dy = 0
		local r0, radians = 20, 0
		for key0, value in pairs(m_points) do
			m_point = vector():set(value["p"][1],value["p"][2],value["p"][3])
			if (m_point) then
				m_dist = m_point:distance_to(point)
				if m_dist < dist then
					dist = m_dist
					m_str = value["text"]
					m_str0 = value["text0"]
					r0 = value.r0 or 20
					dx = point.x - m_point.x
					dy = point.z - m_point.z
					radians = math_atan2(dy, dx)
					if(radians) then
						angle = radians * 57
						if (angle < 0) then
							angle = angle + 360
						end
						if (angle > 360) then
							angle = angle - 360
						end
					end
				end
			end
		end
		if dist <= r0 then
			m_s = m_tmp_str.." "..m_str0
		elseif dist < 50 then
			m_s = m_tmp_str.." возле "..m_str
		elseif dist < 100 then
			m_s = m_tmp_str.." около "..m_str
		else --Говорим, куда (север, юг...)
			if (angle >= 330 or angle <= 30) then -- на востоке
				m_s = m_tmp_str.." к востоку от "..m_str
			elseif (angle >30 and angle <=60) then --северо-восток
				m_s = m_tmp_str.." к северо-востоку от "..m_str
			elseif (angle >60 and angle <=120) then --север
				m_s = m_tmp_str.." к северу от "..m_str
			elseif (angle >120 and angle <=150) then --северо-запад
				m_s = m_tmp_str.." к северо-западу от "..m_str
			elseif (angle >150 and angle <=210) then --запад
				m_s = m_tmp_str.." к западу от "..m_str
			elseif (angle >210 and angle <=240) then --юго-запад
				m_s = m_tmp_str.." к юго-западу от "..m_str
			elseif (angle >240 and angle <= 300) then --юг
				m_s = m_tmp_str.." к югу от "..m_str
			elseif (angle >300 and angle <=330) then --юго-восток
				m_s = m_tmp_str.." к юго-востоку от "..m_str
			else
				m_s = m_tmp_str.." недалеко от "..m_str
			end
		end
	else
		m_s = m_tmp_str
	end
	return m_s
end
--]=]


function get_point_description1(level, point)
	local m_s = ""
	local dist = 10000
	local angle = 0	
	local m_tmp_str = ""
	if (level == "l10u_bunker" or level == "l11_pripyat" or level == "l12_stancia" or level == "l12_stancia_2" or level == "l12u_control_monolith" or level == "l12u_sarcofag") then
		if (isRadarDeactivated() == false) then	return "" end
	end
	if (level and news_data.level_name[level] ~= nil) then
		if (news_data.level_name[level][2] ~= nil) then
			m_tmp_str = news_data.level_name[level][2]..""
		end
	end	
	if (level and news_data.base_points[level] and point) then
		local m_str = ""
		local m_str0 = ""
		local m_point = nil
		local m_dist = 0
		local m_points = news_data.base_points[level]
		local dx = 0
		local dy = 0
		local radians = 0
		for key0, value in pairs(m_points) do
			m_point = vector():set(value["p"][1],value["p"][2],value["p"][3])
			if (m_point) then
				m_dist = m_point:distance_to(point)
				if m_dist < dist then
					dist = m_dist
					m_str = value["text"]
					m_str0 = value["text0"]
					dx = point.x - m_point.x
					dy = point.z - m_point.z
					radians = math_atan2(dy, dx)
					if(radians) then
						angle = radians * 57
						if (angle < 0) then
							angle = angle + 360
						end
						if (angle > 360) then
							angle = angle - 360
						end
					end
				end
			end
		end
		if dist<= 20 then
			m_s = m_tmp_str..""..m_str0
		elseif dist < 50 then
			m_s = m_tmp_str.." возле "..m_str
		elseif dist < 100 then
			m_s = m_tmp_str.." около "..m_str
		else --Говорим, куда (север, юг...)
			if (angle >= 330 or angle <= 30) then -- на востоке
				m_s = m_tmp_str.." к востоку от "..m_str
			elseif (angle >30 and angle <=60) then --северо-восток
				m_s = m_tmp_str.." к северо-востоку от "..m_str
			elseif (angle >60 and angle <=120) then --север
				m_s = m_tmp_str.." к северу от "..m_str
			elseif (angle >120 and angle <=150) then --северо-запад
				m_s = m_tmp_str.." к северо-западу от "..m_str
			elseif (angle >150 and angle <=210) then --запад
				m_s = m_tmp_str.." к западу от "..m_str
			elseif (angle >210 and angle <=240) then --юго-запад
				m_s = m_tmp_str.." к юго-западу от "..m_str
			elseif (angle >240 and angle <= 300) then --юг
				m_s = m_tmp_str.." к югу от "..m_str
			elseif (angle >300 and angle <=330) then --юго-восток
				m_s = m_tmp_str.." к юго-востоку от "..m_str
			else
				m_s = m_tmp_str.." недалеко от "..m_str
			end
		end
	else
		m_s = m_tmp_str
	end
	return m_s
end


function isGameObject( obj )
  return ( obj and type( obj.id ) == "function" )
end


function get_object_levelname( obj )
  return object_level_name( obj )
end


-- выдать те новости, что успели собраться и сгрупироватся.
function check_news()
  for _, v in ipairs( table_spawned ) do
    on_spawn_group( v.community, v.level, v.position, v.count, v.o_type )
  end
  table_spawned     = {}
  table_spawned_idx = {}
  on_news()
  spammers = {}
end


function add_spawned_object( obj )
  if not ( obj and ( IsStalker( obj ) or IsMonster( obj ) ) ) then return end
  local s_comm = get_npc_community( obj )
  if ( s_comm == "" or ignore_spawn_comm[ s_comm ] ) then return end
  local obj_type = 0
  if IsStalker( obj ) then
    obj_type = 1
  elseif IsMonster( obj ) then
    obj_type = 2
  end
  local s_id, gv
  if isGameObject( obj ) then
    s_id, gv = obj:id(), obj:game_vertex_id()
  else
    s_id, gv = obj.id,   obj.m_game_vertex_id
  end
  -- Проверим, не фильтруется ли он по smart_terrain
  local m_obj
  if obj.smart_terrain_id then
    m_obj = obj
  else
    m_obj = alife():object( s_id )
  end
  local lev = object_level_name( obj )
  if
    m_obj
    and m_obj.smart_terrain_id and m_obj:smart_terrain_id() ~= 65535
    and news_data.smart_filters[ s_comm ]
  then
    local sm = alife():object( m_obj:smart_terrain_id() )
    if sm and object_level_name( sm ) == lev then
      local sn = sm:name()
      for _, vs in pairs( news_data.smart_filters[ s_comm ] ) do
        if string.find( sn, vs, 1, true ) then return end
      end
    end
  end
  local k = s_comm .. ":" .. gv
  if table_spawned_idx[ k ] then
    table_spawned_idx[ k ].count = table_spawned_idx[ k ].count + 1
  else
    local t = {
      [ "community" ] = s_comm,
      [ "count"     ] = 1,
      [ "id"        ] = s_id,
      [ "gv"        ] = gv,
      [ "level"     ] = lev,
      [ "o_type"    ] = obj_type,
      [ "position"  ] = get_object_position( obj ),
    }
    table.insert( table_spawned, t )
    table_spawned_idx[ k ] = t
  end
end

function on_weather_change(old_weather, new_weather)
-- clear, pasmurno, rain, groza
	local rnd = math.random
	if (old_weather and new_weather) then
		if (amk.game_minutes() - timer_weather_showed > timer_weather_freq) then	
			local s_weather = old_weather.."_"..new_weather
			local m_h = level:get_time_hours()
			local s_list = nil
			if m_h >= 6 and m_h < 21 then
				s_list = news_data.weather_templates_day
			else
				s_list = news_data.weather_templates_night
			end
			if (s_list and s_list[s_weather]) then
				local s_text = s_list[s_weather][rnd(#s_list[s_weather])]
				if (rnd() < prob) then
					local name, sname = amk_names_lists.get_strings()
					--mylog("on_weather_change ["..s_weather.."] "..s_text)
					show_news(s_text, name.." "..sname, 0, 5, "gen_info")
					timer_weather_showed = amk.game_minutes()
				end
			end
		end
	end
end


function on_daytime()
  -- ночь, рассвет, закат...
  if amk.game_minutes() - timer_daytime_showed > timer_daytime_freq then
    local m_h    = level:get_time_hours()
    local m_m    = level:get_time_minutes()
    local m_t    = m_h * 60 + m_m
    local s_text = ""
    if m_t >= 4 * 60 + 30 and m_t <= 6 * 60 then
      -- 04:30 - 06:00 Рассвет
      if math.random() < prob then
        s_text = news_data.morning_templates[
          math.random( table.getn( news_data.morning_templates ) )
        ]
        local name, sname = amk_names_lists.get_strings()
        show_news( s_text, name .. " " .. sname, 0, 5, "gen_info" )
        timer_daytime_showed = amk.game_minutes()
      end
    elseif m_t >= 20 * 60 + 30 and m_t <= 22 * 60 then
      -- 20:30 - 22:00 Закат
      if math.random() < prob then
        s_text = news_data.evening_templates[
          math.random( table.getn( news_data.evening_templates ) )
        ]
        local name, sname = amk_names_lists.get_strings()
        show_news( s_text, name .. " " .. sname, 0, 5, "gen_info" )
        timer_daytime_showed = amk.game_minutes()
      end
    elseif
      ( m_t >= 23 * 60 and m_t <= 24 * 60 )
      or ( m_t >= 0 * 60 and m_t <= 4 * 60 )
    then
      -- 23:00 - 04:00 Ночь
      if math.random() < prob then
        local tbl = news_data.night_templates[
          math.random( table.getn( news_data.night_templates ) )
        ]
        local texts     = tbl.texts
        local comments  = tbl.comments
        local probl     = tonumber( tbl.prob )
        local base_wait = 0
        if texts then
          local name = "[источник неизвестен]"
          local i    = 0
          for k, v in pairs( texts ) do
            if comments == nil then
              local name_, sname_ = amk_names_lists.get_strings()
              name = name_ .. " " .. sname_
            end
            s_text = v
            show_news( s_text, name, base_wait + k * 2, 5, "uniq" )
            i = i + 1
          end
          if
            probl and comments and news_data.comments_templates[ comments ]
            and math.random() < probl
          then
            s_text = news_data.comments_templates[ comments ][
              math.random( table.getn( news_data.comments_templates[ comments ] ) )
            ]
            local name, sname = amk_names_lists.get_strings()
            show_news(
              s_text, name .. " " .. sname, base_wait + ( i + 1 ) * 3, 5,
              "gen_info"
            )
          end
          timer_daytime_showed = amk.game_minutes()
        end
      end
    end
  end
end


-- где-то веролет дает прикурить (heli_combat:round, heli_combat.heli_combat:search, heli_combat.heli_combat:flyby)
function on_heli_combat(obj)
	local rnd = math.random
	if (obj and amk.game_minutes() - timer_heli_showed > timer_heli_freq) then	
		if (rnd() < 0.5) then -- Не надо слишком часть о вертолетике сообщать
			if (rnd() < prob) then
				local name, sname = amk_names_lists.get_strings()
				local s_author = name.." "..sname
				local m_str = ""
				m_str = format_template_heli(obj, "combat")
				local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
				if (author) then
					s_author = get_npc_name(author)
				else
					return
				end
				do_news(m_str, s_author, rnd(timer_heli, timer_heli * 5), 5, "gen_info", author.id, 1)
				timer_heli_showed = amk.game_minutes()
			end
		end
	end
end

-- видели вертолет
function on_heli_seen(obj)
	local rnd = math.random
	if (obj and amk.game_minutes() - timer_heli_showed > timer_heli_freq) then
		if (rnd() < prob) then
			local name, sname = amk_names_lists.get_strings()
			local s_author = name.." "..sname
			local m_str = ""
			m_str = format_template_heli(obj, "seen")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			do_news(m_str, s_author, rnd(timer_heli, timer_heli * 5), 5, "gen_info", author.id, 1)
			timer_heli_showed = amk.game_minutes()
		end
	end
end

-- подбили вертолет
function on_heli_flame(obj)
	local rnd = math.random
	if (obj and amk.game_minutes() - timer_heli_showed > timer_heli_freq) then	
		if (rnd() < prob) then
			local name, sname = amk_names_lists.get_strings()
			local s_author = name.." "..sname
			local m_str = ""
			m_str = format_template_heli(obj, "flame")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			do_news(m_str, s_author, rnd(timer_heli, timer_heli * 5), 5, "gen_info", author.id, 1)
			timer_heli_showed = amk.game_minutes()
		end
	end
end

-- упал вертолет
function on_heli_die(obj)
	local rnd = math.random
	if (obj and amk.game_minutes() - timer_heli_showed > timer_heli_freq) then	
		if (rnd() < prob) then
			local name, sname = amk_names_lists.get_strings()
			local s_author = name.." "..sname
			local m_str = ""
			m_str = format_template_heli(obj, "die")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end			
			do_news(m_str, s_author, rnd(timer_heli, timer_heli * 5), 5, "gen_info", author.id, 1)
			timer_heli_showed = amk.game_minutes()
		end
	end
end

-- улетел вертолетик
function on_heli_retreat(obj)
	local rnd = math.random
	if (obj and amk.game_minutes() - timer_heli_showed > timer_heli_freq) then	
		if (rnd() < prob) then
			local name, sname = amk_names_lists.get_strings()
			local s_author = name.." "..sname
			local m_str = ""
			m_str = format_template_heli(obj, "retreat")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end			
			do_news(m_str, s_author, rnd(timer_heli, timer_heli * 5), 5, "gen_info", author.id, 1)
			timer_heli_showed = amk.game_minutes()
		end
	end
end


-- Видели монстров. Будем спавнить.
function do_seen_monster()
  local avail = {}
  for k, v in pairs( news_data.do_seen_monster_templates ) do
    local enabled = v.enabled
    if enabled and v.has_info then
      enabled = false
      for _, info in ipairs( parse_names( v.has_info ) ) do
        if db.actor:has_info( info ) then
          enabled = true
          break
        end
      end
    end
    if
      enabled
      and not ogse.load_var_safe( "news_main.do_seen_monster." .. v.lname )
    then
      table.insert( avail, v )
    end
  end
  if table.getn( avail ) == 0 then return end

  local z = avail[ math.random( table.getn( avail ) ) ]
  -- Вытягиваем что надо.
  local spawn = z.spawn
  local b_ok  = false
  for l, m in ipairs( spawn ) do
    local class = m.class
    local count = m.count
    local point = m.point
    local lv    = m.lv
    local gv    = m.gv
    for index = 1, count do
      local x_offset = math.random( 5 )
      local z_offset = math.random( 5 )
      local new_pos  = vector():set( point[ 1 ], point[ 2 ], point[ 3 ] )
      new_pos.x = new_pos.x + x_offset
      new_pos.z = new_pos.z + z_offset
      if not point_is_far( new_pos, lv, gv, dist_far ) then
        -- Слишком близко.
        return
      end
      local obj = dsh.create_free_monster( class, new_pos, lv, gv )
      -- Микроквест
      if
        z.reward
        and z.reward.c_min and z.reward.c_max
        and index == 1 and l == 1
      then
        local ini = obj:spawn_ini()
        ini.readonly = false
        ini:w_float(
          "microquest", "reward_money",
          math.random( z.reward.c_min, z.reward.c_max ) * 1000
        )
        local ritems = ""
        local rank   = get_npc_rank( db.actor )
        local t      = news_data.miniquest_rewards[ rank ]
        for i = 1, math.random( 3 ) do
          local section = t[ math.random( table.getn( t ) ) ]
          if ritems == "" then
            ritems = section
          else
            ritems = ritems .. "," .. section
          end
        end
        ini:w_string( "microquest", "reward_items", ritems )
        obj:save_spawn_ini()
      end
      b_ok = true
    end
  end
  if b_ok then
    ogse.save_var( "news_main.do_seen_monster." .. z.lname, true, "bool" )
  end
end


function on_wound(obj)
	local rnd = math.random
	if (obj and obj.name) then
		if (IsNpcStalker(obj)) then
			if (rnd() < prob) then
				local stype = "single"
				local author_id = obj.id
				if (rnd() < 0.5) then stype = "group" end
				local stext = news_data.wound_templates[stype][rnd(#news_data.wound_templates[stype])]				
				local m_pos = get_object_position(obj)
				local m_level = ""
				if (m_pos) then
					m_level = get_point_description(get_object_levelname(obj), m_pos)
					if (m_level == "") then return end
				end
				local sname = get_npc_name(obj)
				local t = { ["level"] = m_level, ["name"] = sname }
				local m_s = ""
				for key0, value in pairs(t) do
					m_s = string_gsub(stext, "%$"..key0, value)
					stext = m_s
				end
				m_s = stext
				local sfrom = sname
				if (stype == "group") then
					local name, sname = amk_names_lists.get_strings()
					sfrom = name.." "..sname
					local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_seen, 0)
					if (author and get_npc_name(author) ~= "") then
						s_from = get_npc_name(author)
						author_id = author.id
					end
				end
				do_news(m_s, sfrom, rnd(timer_stalker_death, timer_stalker_death * 2), 5, "gen_info", author_id, 1)
				if (isGameObject(obj)) then
					if (_debug) then amk.add_spot_on_map(obj:id(), "red_location", m_s) end
				else
					if (_debug) then amk.add_spot_on_map(obj.id, "red_location", m_s) end
				end
			end
		end
	end
end


local sem_death_komment = {
  "Опять Юра ласты склеил! Добрый знак.",
  "Семецкий кони двинул? Значит, рейд удачный будет!",
  "Что-то Семецкий зачастил... Может, предупреждает?",
  "Та-а-ак. Пойду-ка я в рейд. Авось не зря Семецкий помер опять. Может артефакт найду какой.",
  "А правда, что когда Семецкий помирает - это на удачу и можно артефакт найти?"
}

-- Сообщение о гибели Семецкого
function do_eternal_stalker()
  local m_level  = news_data.levels[
    math.random( table.getn( news_data.levels ) - 5 )
  ]
  local b_indoor = news_data.levels_types[ m_level ]
  if m_level and news_data.level_name[ m_level ] then
    m_level = news_data.level_name[ m_level ][ 1 ]
  end
  local m_name       = "Юрий Семецкий"
  local m_killer_str = ""
  -- Аномалия, монстр или НПС(?).
  if math.random() < 0.4 then
    -- Аномалия
    if b_indoor == 0 then
      m_killer_str = news_data.anomalies[
        math.random( table.getn( news_data.anomalies ) )
      ]
    else
      -- Не все аномалии под землей бывают...
      m_killer_str = news_data.anomalies[
        math.random( table.getn( news_data.anomalies ) - 3 )
      ]
    end
  else
    -- Монстры
    if b_indoor == 0 then
      m_killer_str = news_data.monsters[
        math.random( table.getn( news_data.monsters ) )
      ]
    else
      -- Не все монстры под землей бывают...
      m_killer_str = news_data.monsters[
        math.random( table.getn( news_data.monsters ) - 6 )
      ]
    end
  end
  local m_string = m_name .. ", " .. m_level .. ", " .. m_killer_str .. "."
    amk.send_tip( m_string, "Погиб сталкер:", 0, 30, "death", "rememb" )
  generate_art()
  actor_stats.add_points( "exp", "exp_eternal_stalker", 1, 1 )
  if math.random() < 0.2 then
    local name, sname = amk_names_lists.get_strings()
    local m_string = sem_death_komment[
      math.random( table.getn( sem_death_komment ) )
    ]
    show_news(
      m_string, name .. " " .. sname, math.random( 4, 6 ), 5, "gen_info"
    )
  end
end


function generate_art()
  local sect = amk_anoms.get_random_art_sect()
  if not sect then return end
  local prop = amk_utils.get_item_props( sect )
  if prop.has_af_dyn then
    sect = amk_anoms.make_dyn_art_sect( sect, 5 )
    prop = amk_utils.get_item_props( sect )
  end
  if prop.af_bio_sect then sect = prop.af_bio_sect end
  amk_anoms.configure_restrictions()
  for i = 1, 100 do
    local pos, gv, lv = amk_anoms.calc_new_free_pos()
    if pos then
      local sobj = amk_anoms.spawn_art( sect, pos, gv, lv )
      sobj.custom_data = "[news_main.generate_art]\n"
      return
    elseif pos == false then
      log2(
        "[%s]: can't find position for %s: pos == false", script_name(), sect
      )
    end
  end
  log2( "[%s]: can't find position for %s: for loop", script_name(), sect )
end


function next_blow( timer )
  timer_next_blow = amk.game_minutes() + timer
end


-- новости о времени до выброса
local day_parts = {
  { hour =  4, text = "ночью"          },
  { hour = 12, text = "утром"          },
  { hour = 14, text = "днем"           },
  { hour = 18, text = "после обеда"    },
  { hour = 22, text = "вечером"        },
  { hour = 24, text = "поздно вечером" },
}

function time_to_day_part( t )
  local y, m, d, h = t:get()
  for _, t in ipairs( day_parts ) do
    if h < t.hour then return t.text end
  end
end


function days_between( diff )
  local days = 0
  diff = diff - ( 24 - level:get_time_hours() )
  while diff >= 0 do
    days = days + 1
    diff = diff - 24
  end
  return days
end


function do_blow_news()
  if
    amk.load_variable( "blowout", -1 ) > -1
    and amk.load_variable( "blowout",-1 ) < 5
  then
    return
  end
  local diff, surge_gt = ogse_weather_mgr.get_surge_time()
  diff = math.floor( diff )
  if diff < 1 or diff >= 48 then return end
  local item = news_data.blowout_templates[
    math.random( table.getn( news_data.blowout_templates ) )
  ]
  local alive = tonumber( item.alive )
  if alive and not isAlive( alive ) then return end
  local when
  if     diff < 2 then
    when = "через час-другой"
  elseif diff < 5 then
    when = "через пару часов"
  elseif diff < 8 then
    when = "часов через 6-7"
  else
    local text = time_to_day_part( surge_gt )
    local days = days_between( diff )
    if     days == 0 then
      when = text
    elseif days == 1 then
      local now = time_to_day_part( game.get_game_time() )
      if
        ( text == "ночью" and now ~= "ночью" )
        or (
          text == "утром" and ( now == "вечером" or now == "поздно вечером" )
        )
      then
        when = text
      else
        when = "завтра " .. text
      end
    elseif days == 2 then
      when = "послезавтра " .. text
    else
      ASSERT( false, "[%s]: unexpected days: %s", script_name(), days )
    end
  end
  local stext = string.gsub( item.text, "%$when", when )
  local name, sname = amk_names_lists.get_strings()
  show_news(
    stext, name .. " " .. sname, math.random( 10, timer_general ), 5, "gen_info"
  )
  timer_blow_showed = amk.game_minutes()
end


function news_sort( a, b )
  if a.priority == 1 and b.priority ~= 1 then
    return false
  end
  return a.created < b.created
end


function on_news()
  local filtered = {}
  for _, v in ipairs( news_stack ) do
    if not v.activated then
      if v.lifetime > amk.game_minutes() then
        table.insert( filtered, v )
      end
    end
  end
  if table.getn( filtered ) < table.getn( news_stack ) then
    news_stack = filtered
  end
  -- Отсортируем.
  table.sort( news_stack, news_sort )
  for _, v in ipairs( news_stack ) do
    if v.timeout < amk.game_minutes() then -- Новость актуальна.
      on_avail_news( v )
      break
    end
  end

  if timer_next_blow == 0 then
    local next_time = ogse_weather_mgr.get_surge_time()
    timer_next_blow = amk.game_minutes() + next_time * 60 -- в минутах
  end

  local gtime = amk.game_minutes()
  if gtime - timer_blow_showed > timer_blow_freq then
    do_blow_news()
  end
  if gtime - timer_daytime_showed > timer_daytime_freq then
    on_daytime()
  end
end


function on_avail_news( z )
  local bAlive      = false
  local m_author_id = tonumber( z.author_id )
  if m_author_id then
    local obj = alife():object( m_author_id )
    if obj then
      if IsStalker( obj ) then
        if IsNpcStalker( obj ) then
          if
            obj.alive and obj:alive() and obj.health and obj:health() > 0
          then
            bAlive = true
          end
        end
      end
    end
  else
    bAlive = true
  end
  if bAlive then
    show_news( z.text, z.from, 0, z.showtime, z.section )
  end
  z.activated = amk.game_minutes()
end


function on_offline_trade( npc, item )
  if math.random() < prob_offline_trade then
    local m_from  = get_npc_name( npc )
    local m_str   = news_data.trade_templates[
      math.random( table.getn( news_data.trade_templates ) )
    ]
    local m_level = get_point_description(
      get_object_levelname( npc ), get_object_position( npc )
    )
    if m_level == "" then return end
    local m_title = get_object_name( item )
    local t = { [ "level" ] = m_level, [ "item" ] = m_title }
    for key0, value in pairs( t ) do
      m_str = string.gsub( m_str, "%$" .. key0, value )
    end
    if m_str ~= "" then
      do_news( m_str, m_from, math.random( 150, 3600 ), 5, "trade", npc.id )
    end
  end
end


function create_treasurebox()
  local sobj = alife():create(
    "m_inventory_box",
    db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id()
  )
  sobj = alife():object( sobj.id )
  sobj.custom_data = "[logic]\ncfg = scripts\\treasure_inventory_box.ltx\n"
  sobj:used_ai_locations( false )
end


function on_miniquest_reward( trader )
  if trader and db.actor then
    local money, items = dsh_monster_microquest.get_next_reward()
    dialogs.relocate_money( trader, money, "in" )
    local t = {}
    for _, sect in ipairs( items ) do
      if dsh.is_artefact( sect ) then
        local prop = amk_utils.get_item_props( sect )
        if prop.has_af_dyn then
          sect = amk_anoms.make_dyn_art_sect( sect, 4 )
          prop = amk_utils.get_item_props( sect )
        end
        if prop.af_bio_sect then
          local rnd = dsh.get_next_random(
            "news_main.on_miniquest_reward.af_bio_sect"
          )
          if rnd < 0.9 then sect = prop.af_bio_sect end
        end
      end
      table.insert( t, sect )
    end
    for _, k in ipairs( t ) do
      local items = dialogs.relocate_item_section( trader, k, "in" )
    end
  end
end


function point_is_far(point, lv, gv, distance)
	local sim = alife()
	local actor = db.actor
	local result = true
	if (actor and point and lv and gv and distance and game_graph():valid_vertex_id(gv)) then
		-- на одном ли уровне?
		local map = sim:level_name(game_graph():vertex(gv):level_id())
		if (map and level.name() == map) then
			-- Достаточно ли далеко?
			if (point:distance_to(actor:position()) < distance) then
				result = false
			end
		end
   end
   return result
end


function get_nearest_stalker( map, point, dist_max, dist_min, any_stalker )
  if
    not (
      map and point
      and amk_offline_alife.off_npcs[ map ]
      and table.getn( amk_offline_alife.off_npcs[ map ].stalkers ) > 0
    )
  then
    return
  end
  local min_dist = 1000000
  if ( not dist_max ) or dist_max == 0 then dist_max = dist_seen end
  if not dist_min then dist_min = 0 end
  local stalkers = amk_offline_alife.off_npcs[ map ].stalkers
  local obj
  for _, v in pairs( stalkers ) do
    local stalker = alife():object( v.id )
    -- На одном ли уровне?
    if
      stalker
      and friends_comm[ get_npc_community( stalker ) ]
      and game_graph():valid_vertex_id( stalker.m_game_vertex_id )
      and object_level_name( stalker ) == map
      and stalker:alive() and stalker:health() > 0
      and stalker:get_job_online() ~= false
      and stalker:can_be_spawned()
    then
      if stalker.name and stalker:name() ~= "agr_ratcatcher" then
        -- Достаточно ли далеко?
        local s_dist = stalker.position:distance_to( point )
        if
          s_dist <= dist_max and s_dist >= dist_min and s_dist < min_dist
        then
          -- А не спамил ли он в последнее время?
          if not is_spammer( stalker ) then
            min_dist = s_dist
            obj      = stalker
          end
        end
      end
    end
  end
  return obj
end


function is_spammer( stalker )
  local sn = get_npc_name( stalker )
  return (
    sn ~= "" and spammers[ sn ] and spammers[ sn ] + 10000 > time_global()
  )
end


function get_random_stalker( map )
  if not ( map and amk_offline_alife.off_npcs[ map ] ) then return end
  local stalkers = amk_offline_alife.off_npcs[ map ].stalkers
  t = {}
  for _, v in pairs( stalkers ) do
    table.insert( t, v )
  end
  if table.getn( t ) > 1 then
    dsh.shuffle( t )
    stalkers = t
  end
  for _, v in pairs( stalkers ) do
    local stalker = alife():object( v.id )
    -- На одном ли уровне?
    if
      stalker
      and friends_comm[ get_npc_community( stalker ) ]
      and game_graph():valid_vertex_id( stalker.m_game_vertex_id )
      and object_level_name( stalker ) == map
      and stalker:alive() and stalker:health() > 0
      and stalker:get_job_online() ~= false
      and stalker:can_be_spawned()
    then
      if stalker.name and stalker:name() ~= "agr_ratcatcher" then
        if not is_spammer( stalker ) then
          return stalker
        end
      end
    end
  end
end


function isAlive( story_id )
  local sobj = alife():story_object( story_id )
  if sobj and sobj:alive() then
    return true
  end
  return false
end


function isRadarDeactivated()
	local result = false
	if (has_alife_info("bar_deactivate_radar_done")) then
		result = true
	end
	return result
end

-- Функция отключена, чтобы всегда приходили сообщения о погибших квестовиках и ограбленных нычках
function isIsolatedLevel(level_name)
	local result = false
	return result
end

function on_connect()
	local rnd = math.random
	local text = news_data.connect_templates[rnd(#news_data.connect_templates)]
	if (text) then
		amk.send_tip(text, "Статус соединения:", 0, 15, "uniq")
	end
end

function on_disconnect()
	local rnd = math.random
	local text = news_data.disconnect_templates[rnd(#news_data.disconnect_templates)]
	if (text) then
		amk.send_tip(text, "Статус соединения:", 0, 15, "uniq")
	end
end
