-- -*- mode: lua; coding: windows-1251-dos -*-
--Smart Terrain (–º–µ—Ö–∞–Ω–∏–∑–º, –æ—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞—é—â–∏–π –≤—Å–µ—Ö —Å—Ç–∞–ª–∫–µ—Ä–æ–≤ –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –º–æ–Ω—Å—Ç—Ä–æ–≤ –≤ —Å—Ü–µ–Ω—ã)
--–ß—É–≥–∞–π –ê–ª–µ–∫—Å–∞–Ω–¥—Ä
--!–±–µ–∑ —Å–∏–º—É–ª—è—Ü–∏–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç!
local check_period = 10000

local monster_classes
local disagreed, agreed, agreed_exclusive = 0, 1, 2
local smart_section = "smart_terrains"
local smart_terrains = {}
--[[ —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å–µ—Ä–≤–µ—Ä–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ —Å–º–∞—Ä—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏–º—É–ª—è—Ç–æ—Ä–µ
–§–æ—Ä–º–∞—Ç:
	smart_terrains = {
		level_name = { id=obj, id=obj, ... },
		level_name = { id=obj, id=obj, ... },
		...
	}
]]
exclusives = {}
--[[ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞ 1 –≤ –∫–∞–∂–¥–æ–º se_monster.se_monster:fill_exclusives() –∏ se_stalker.se_stalker:fill_exclusives()
–§–æ—Ä–º–∞—Ç:
	exclusives = {
		smart_name1 = <number of ?available? exclusive positions in smart_name1>,
		smart_name2 = <number of ?available? exclusive positions in smart_name2>,
		...
	}
]]

----------------------------------------------------------------------------------------------------------------------
-- –ö–ª–∞—Å—Å "se_smart_terrain". –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫—É smart terrain –≤ –û–§–õ–ê–ô–ù–ï.
-- –£–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω –æ—Ç —Å–∫—Ä–∏–ø—Ç–æ–≤–æ–π –∑–æ–Ω—ã.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain"(cse_alife_smart_zone)

function se_smart_terrain:__init(section)
    super(section)
    self.registred = false
    self.duration_end = game.CTime() -- —É–±—Ä–∞—Ç—å
    self.idle_end = game.CTime() -- —É–±—Ä–∞—Ç—å
    self.obj_exclusive_tbl = {} --–í —ç—Ç–æ–π —Ç–∞–±–ª–∏—á–∫–µ –±—É–¥–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è, –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–µ–π obj_accepts_smart_terrain, —á—Ç–æ–± –Ω–µ –≤—ã–∑—ã–≤–∞—Ç—å –µ—ë —Ç—Ä–∏ —Ä–∞–∑–∞ –ø–æ–¥—Ä—è–¥
end

-- –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∞—Å—å –≤ –≤—ã—Ä–µ–∑–∞–Ω–Ω–æ–º –æ—Ñ—Ñ–ª–∞–π–Ω–æ–≤–æ–º –∫–æ–º–±–∞—Ç–µ
function se_smart_terrain:detect_probability()
    return 0
end

-- —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
function se_smart_terrain:STATE_Write(packet)
    --	log1( "se_smart_terrain::STATE_Write called!" )
    cse_alife_smart_zone.STATE_Write(self, packet)

    utils.w_CTime( packet, self.duration_end ) -- —É–±—Ä–∞—Ç—å
    utils.w_CTime( packet, self.idle_end ) -- —É–±—Ä–∞—Ç—å

    if self.gulag_working then
        packet:w_bool(true)

        self.gulag:save_common(packet)

        local n = 0

        for id, v in pairs(self.npc_info) do
            n = n + 1
        end

        packet:w_u8(n)

        for id, v in pairs(self.npc_info) do
            packet:w_u16(id)
            packet:w_u8(v.o_group)
            packet:w_u8(v.o_squad)
            packet:w_bool(v.exclusive)
            utils.w_CTime(packet, v.stay_end)

            self.gulag:save_obj(packet, id)
        end

        packet:w_bool(self.population_locked)
    else
        packet:w_bool(false)
    end
end

-- –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
function se_smart_terrain:STATE_Read( packet, size )
    --	log1( "se_smart_terrain::STATE_Read called!" )
    cse_alife_smart_zone.STATE_Read(self, packet, size)

    --	log1( "before read_params" )
    --	self:print()

    self:read_params()

    -- –ø–æ–¥ LevelEditor –Ω–µ –ø—ã—Ç–∞—Ç—å—Å—è —á–∏—Ç–∞—Ç—å –∏–∑ –ø–∞–∫–µ—Ç–∞ –Ω–∏—á–µ–≥–æ
    if editor() then
        return
    end

    self.duration_end = utils.r_CTime( packet ) -- —É–±—Ä–∞—Ç—å
    self.idle_end     = utils.r_CTime( packet ) -- —É–±—Ä–∞—Ç—å
    self.gulag_working = packet:r_bool()

    -- –µ—Å–ª–∏ –µ—Å—Ç—å —Ä–∞–±–æ—Ç–∞—é—â–∏–π –≥—É–ª–∞–≥
    if self.gulag_working then
        self.check_time = time_global()

        self.gulag:load_common(packet)

        local n = packet:r_u8()
        local o_id, o

        --		log3( "npc_info=%s", tostring( n ) )

        for i = 1, n do
            o_id = packet:r_u16()
            self.npc_info[o_id] = {}
            o = self.npc_info[o_id]

            o.o_group = packet:r_u8()
            o.o_squad = packet:r_u8()
            o.exclusive = packet:r_bool()
            o.stay_end = utils.r_CTime(packet)

            self.gulag:load_obj(packet, o_id)
        end

        self.population_locked = packet:r_bool()
    end

    --	log3( "after read [%s]", self:name())
    --	self:print()
end

-- –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å–º–∞—Ä—Ç —Ç–µ—Ä—Ä–µ–π–Ω–∞.
-- –ø–æ—Å–ª–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Å–º–∞—Ä—Ç –ü–û–õ–ù–û–°–¢–¨–Æ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–µ–Ω.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –≤—Å–µ—Ö –º–µ—Å—Ç, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –≤—ã–∑–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ –æ–±—ä–µ–∫—Ç—ã:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()

function se_smart_terrain:initialize_if_needed()
    if not self.initialized then

        self:get_se_objs()

        self:preserve_exclusives()

        self.initialized = true
    end
end

function se_smart_terrain:is_initialized()
    return self.initialized
end

-- –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞—Ç—å –º–µ—Å—Ç–∞ –¥–ª—è —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
-- –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å—Ç—Ä–æ–≥–æ –æ–¥–∏–Ω —Ä–∞–∑ –∫–∞–∫ —á–∞—Å—Ç—å initialize_if_needed
function se_smart_terrain:preserve_exclusives()
    local e = exclusives[self:name()]

    if e then
        -- '	log3( "[smart_terrain %s] exclusives=%d", self:name(), e )

        self.exclusives = e
        -- '	log3("[smart_terrain %s] preserve_exclusives [%s]", self:name(), tostring(self.gulag.capacity_non_exclusive))
        self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e

        exclusives[self:name()] = nil
    else
        self.exclusives = 0
    end
end

-- –ø–æ–ª—É—á–∏—Ç—å —Å–µ—Ä–≤–µ—Ä–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
-- –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å—Ç—Ä–æ–≥–æ –æ–¥–∏–Ω —Ä–∞–∑ –∫–∞–∫ —á–∞—Å—Ç—å initialize_if_needed
function se_smart_terrain:get_se_objs()
    local sim = alife()
    local del = {}
    for id, v in pairs(self.npc_info) do
        local obj = sim:object(id)
        if obj then
            self:fill_npc_info(obj, v)
        else
            log3("!![smart_terrain %s] can't get server object id=%s", self:name(), id)
            table.insert(del, id)
        end
    end
    for _, id in ipairs(del) do
        self.npc_info[id] = nil
        self.gulag:removeObject(id)
    end
end

-- –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ
-- —É –º–æ–Ω—Å—Ç—Ä–æ–≤ –Ω–µ—Ç—É –º–µ—Ç–æ–¥–∞ profile_name()
-- TODO –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –Ω–µ npc_info, –∞ –æ–±—ä–µ–∫—Ç
function se_smart_terrain:fill_npc_info(obj, npc_info)
    if not npc_info then
        npc_info = {}
    end

    npc_info.se_obj = obj

    npc_info.class_id = obj:clsid()
    npc_info.section_name = obj:section_name()
    npc_info.name = obj:name()
    npc_info.story_id = obj.m_story_id
    npc_info.community = self:get_obj_community(obj)
    npc_info.profile_name = obj.profile_name and obj:profile_name()
    npc_info.rank = obj:rank()

    npc_info.group = obj:g_group()
    npc_info.squad = obj:g_squad()
    npc_info.team = obj:g_team()

    if npc_info.profile_name then
        npc_info.is_sniper = string.find(npc_info.profile_name, "sniper") ~= nil
    end
    npc_info.is_sniper_name = string.find(npc_info.name, "sniper") ~= nil

    local t = obj.smart_terrain_conditions
    if t then
        t = t[self:name()]
    end

    npc_info.cond = t
    return npc_info
end

-- –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
-- –∞) –µ—Å–ª–∏ —Å—Ç–∞–ª–∫–µ—Ä: –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É —Å—Ç–∞–ª–∫–µ—Ä–∞ –∏ true
-- –±) –µ—Å–ª–∏ –º–æ–Ω—Å—Ç—Ä:  –≤–∏–¥ –º–æ–Ω—Å—Ç—Ä–∞ –∏ false
-- TODO: –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª
function se_smart_terrain:get_obj_community(obj)
    local cls = obj:clsid()

    if cls == clsid.script_stalker then
        return obj:community(), true
    else
        return monster_classes[cls], false
    end
end

function se_smart_terrain:dsh_override_params()
    local dsh_override_opts = {
        ["capacity"] = {
            ["getter"] = function(...)
                return get_float(...)
            end,
            ["setter"] = function(v)
                self.gparams.capacity = v
            end
        },
        ["communities"] = {
            ["getter"] = function(...)
                return get_string(...)
            end,
            ["setter"] = function(v)
                self.communities = v
            end
        },
        ["cond"] = {
            ["getter"] = function(...)
                return get_string(...)
            end,
            ["setter"] = function(cond, sect)
                self.gparams.cond = xr_logic.parse_condlist(nil, sect, "cond", cond)
            end
        },
        --[==[ --KRodin: —É –º–µ–Ω—è —ç—Ç–æ –ø–æ–∫–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
    [ "stay" ] = {
      [ "getter" ] = function( ... ) return get_numbers( ... ) end,
      [ "setter" ] = function( v )
        self.gparams.stay_min = v[ 1 ]
        if table.getn( v ) > 1 then
          self.gparams.stay_max = v[ 2 ]
        else
          self.gparams.stay_max = v[ 1 ]
        end
      end,
    },
--]==]
        ["type"] = {
            ["getter"] = function(...)
                return get_string(...)
            end,
            ["setter"] = function(v)
                self.gparams.type = v
            end
        },
        ["on_cleanup"] = {
            ["getter"] = function(...)
                return get_string(...)
            end,
            ["setter"] = function(v)
                self.on_cleanup = v
            end
        }
    }
    local sect = "dsh.gulag.override." .. self:name()
    if sys_ini:section_exist(sect) then
        for k, v in pairs(dsh_override_opts) do
            if sys_ini:line_exist(sect, k) then
                local value = v.getter(sect, k)
                v.setter(value, sect)
            end
        end
    end
end

-- –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è.
-- —á—Ç–µ–Ω–∏–µ custom data.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å—Ç—Ä–æ–≥–æ –æ–¥–∏–Ω —Ä–∞–∑ –∫–∞–∫ —á–∞—Å—Ç—å STATE_Read
function se_smart_terrain:read_params()
    local ini = self:spawn_ini()
    local sect = "smart_terrain"

    if not ini:section_exist(sect) then
        sect = "gulag1"

        if not ini:section_exist(sect) then
            log3("!![se_smart_terrain:read_params] [%s] no configuration!", self:name())
            self.disabled = true
            return
        end
    end

    ASSERT(ini:line_exist(sect, "type"), "[smart_terrain %s] type is not specified", self:name())

    local gp = {}

    self.npc_info = {} -- group –∏ squad –¥–ª—è –∫–∞–∂–¥–æ–≥–æ npc
    self.gparams = gp -- –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—É–ª–∞–≥–∞

    gp.type = get_string(sect, "type", nil, ini)
    gp.preset_name = get_string(sect, "preset", nil, ini)
    gp.capacity = get_float(sect, "capacity", 100, ini) -- —ë–º–∫–æ—Å—Ç—å. –∞ –Ω–∞—Å—Ç–æ—è—â–∞—è —ë–º–∫–æ—Å—Ç—å = min(—ç—Ç–∞_—ë–º–∫–æ—Å—Ç—å, —ë–º–∫–æ—Å—Ç—å –≥—É–ª–∞–≥–∞)
    gp.squad = get_float(sect, "squad", nil, ini)
    gp.respawn = get_string(sect, "respawn", nil, ini)
    self.communities = get_string(sect, "communities", nil, ini)
    self.rank_inc_min = get_u32("smart_terrain_rank_change", "min")
    self.rank_inc_max = get_u32("smart_terrain_rank_change", "max")

    local cond_str = get_string(sect, "cond", nil, ini)
    if cond_str then
        gp.cond = xr_logic.parse_condlist(nil, sect, "cond", cond_str)
    end

    local groups_str = get_string(sect, "groups", nil, ini)
    if groups_str then
        gp.groups = parse_nums(groups_str)
    end
    --
    self:dsh_override_params()
    --
    if self.communities then
        local t = parse_names(self.communities)
        for i, v in ipairs(t) do
            if not self.accepted_communities then
                self.accepted_communities = {}
            end
            self.accepted_communities[v] = true
        end
    end

    self.population_locked = false

    self.gulag = xr_gulag.gulag(self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity)

    self.gulag_working = false
end

-- —Ç–∞–±–ª–∏—Ü–∞ level_groups –∑–∞–¥–∞—ë—Ç —á—Ç–æ-—Ç–æ –≤—Ä–æ–¥–µ –∫–∞—Ä—Ç—ã, –≥–¥–µ –ª–æ–∫–∞—Ü–∏–∏ —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ –æ–±–ª–∞—Å—Ç–∏.
-- –ù–µ–ø–∏—Å–∏ –ø–æ–π–¥—É—Ç –≤ —Å–º–∞—Ä—Ç —Å –¥—Ä—É–≥–æ–≥–æ —É—Ä–æ–≤–Ω—è, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ —Å–æ —Å–º–∞—Ä—Ç–æ–º.
-- –í–µ—Ä–æ—è—Ç–Ω–æ, –Ω–∞–¥–æ –≥–ª—è–Ω—É—Ç—å –Ω–∞ –∫–∞—Ä—Ç—É –∏ —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —ç—Ç–∏ –≥—Ä—É–ø–ø—ã –∑–∞–¥–∞–Ω—ã –æ—Å–º—ã—Å–ª–µ–Ω–Ω–æ.
-- –∫–∞–∫ –º–∏–Ω–∏–º—É–º, –≥—Ä—É–ø–ø—ã –¥–æ–ª–∂–Ω—ã –æ–±–µ—Å–ø–µ—á–∏–≤–∞—Ç—å —Å–≤—è–∑–Ω–æ—Å—Ç—å –≥—Ä–∞—Ñ–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ª–æ–∫–∞—Ü–∏–π –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã, –∏ —Ç–∞–∫–∂–µ
-- –Ω–∞–¥–æ —Å–æ–≥–ª–∞—Å–æ–≤—ã–≤–∞—Ç—å –º–µ—Å—Ç–æ —Å–ø–∞–≤–Ω–∞ –Ω–µ–ø–∏—Å–µ–π –∏ –≥—Ä—É–ø–ø—ã, –∏–Ω–∞—á–µ –∑–∞—Å–ø–∞–≤–Ω–µ–Ω–Ω—ã–µ –Ω–µ–ø–∏—Å–∏ –Ω–µ —Å–º–æ–≥—É—Ç 
-- –ø–æ–ø–∞—Å—Ç—å –≤ —Å–≤–æ–π —Å–º–∞—Ä—Ç. 
-- –µ—Å–ª–∏ –ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø—Ä–æ–ø–∏—Å–∞–Ω–∞ –≤ —ç—Ç–æ–π —Ç–∞–±–ª–∏—Ü–µ, —Ç–æ –æ–Ω–∞ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–∞.
local level_groups = {
    l01_escape = "group1",
    l02_garbage = "group1",
    l03_agroprom = "group1",
    l03u_agr_underground = "group1",
    l04_darkvalley = "group1",
    l04u_labx18 = "group1",
    l05_bar = "group1",
    l06_Rostok = "group1",
    l07_military = "group1",
    l08_yantar = "group1",
    l08u_brainlab = "group1",
    l10_radar = "group1",
    l10u_bunker = "group1",
    l11_pripyat = "group1",
    l12_stancia = "group3",
    l12u_sarcofag = "group3",
    l12u_control_monolith = "group3",
    l12_stancia_2 = "group3"
}

function is_same_level_group(l1, l2)
    local g1 = level_groups[l1] or l1
    local g2 = level_groups[l2] or l2
    return g1 == g2
end

--[[
–ü–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –æ–±—ä–µ–∫—Ç –≥—É–ª–∞–≥—É?
1) –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç –Ω–µ —Å–æ–≥–ª–∞—Å–µ–Ω —Å—é–¥–∞ –∏–¥—Ç–∏, —Ç–æ smart terrain –µ–≥–æ –Ω–µ –≤–æ–∑—å–º—ë—Ç
2) –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç —Å–æ–≥–ª–∞—Å–µ–Ω –∏–¥—Ç–∏ –∫—É–¥–∞ —É–≥–æ–¥–Ω–æ, —Ç–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –µ—â—ë –º–µ—Å—Ç–∞, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –æ–Ω –≥—É–ª–∞–≥—É,
   –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –æ–Ω —Ö–æ—Ç—å –Ω–∞ –æ–¥–Ω—É —Ä–∞–±–æ—Ç—É
3) –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç —Å–æ–≥–ª–∞—Å–µ–Ω –∏–¥—Ç–∏ —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ—Ç —Å–º–∞—Ä—Ç, —Ç–æ –ø—Ä–∏–Ω–∏–º–∞–µ–º –¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ—Ç—É –º–µ—Å—Ç–∞ (–æ–Ω –≤—ã—Ç–µ—Å–Ω–∏—Ç –∫–æ–≥–æ-—Ç–æ), –ø—Ä–æ–≤–µ—Ä–∏—Ç—å,
   –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –æ–Ω –≥—É–ª–∞–≥—É, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –æ–Ω —Ö–æ—Ç—å –Ω–∞ –æ–¥–Ω—É —Ä–∞–±–æ—Ç—É
------------
–í—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç - —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã —Ñ—É–Ω–∫–∏–∏ obj_accepts_smart_terrain - —Ç–∏–ø —Å–æ–≥–ª–∞—Å–∏—è –æ–±—ä–µ–∫—Ç–∞ –Ω–∞
–≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ –≤ —ç—Ç–æ—Ç —Å–º–∞—Ä—Ç.
–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ —á–∞—Å—Ç—å enabled
]]
function se_smart_terrain:smart_terrain_accepts_obj(obj, obj_agreement)
    if obj_agreement == disagreed then -- –æ–±—ä–µ–∫—Ç –≤ —ç—Ç–æ—Ç —Å–º–∞—Ä—Ç –∏–¥—Ç–∏ –Ω–µ —Ö–æ—á–µ—Ç
--		log3("[%s] disagreed", obj:name())
        return false
    end
    local sect = obj:section_name()
    if get_bool(sect, "force_no_smart", false) then
        return false
    end
    local is_exclusive = obj_agreement == agreed_exclusive
    -- –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Ö–æ—á–µ—Ç –∏–¥—Ç–∏ —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ—Ç, –∏–ª–∏ –µ—Å–ª–∏ –≥–æ—Ç–æ–≤ –±–µ–∑ —É—Å–ª–æ–≤–∏–π –∏ –ø—Ä–∏ —ç—Ç–æ–º –≥—É–ª–∞–≥ –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é
    if is_exclusive or self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive then
        local community, is_stalker = self:get_obj_community(obj)
        --
        --–ï—Å–ª–∏ –≤ –∫–∞—Å—Ç–æ–º–¥–∞—Ç–µ —Å–º–∞—Ä—Ç–∞ –µ—Å—Ç—å –ø–µ—Ä–µ—á–µ–Ω—å –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –≥—Ä—É–ø–ø–∏—Ä–æ–≤–æ–∫ –∏ –Ω–µ–ø–∏—Å—å –Ω–µ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —ç—Ç—É –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É
        if self.accepted_communities and not self.accepted_communities[community] then
            return false
        end
        --
        --–ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —Å–º–∞—Ä—Ç—Ç–µ—Ä—Ä–µ–π–Ω –∏ –ù–ü–° –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –æ–¥–Ω–æ–º –∫–ª–∞—Å—Ç–µ—Ä–µ —É—Ä–æ–≤–Ω–µ–π
        local npc_level_name = game_graph():valid_vertex_id(obj.m_game_vertex_id) and object_level_name(obj) or ""
        if not is_same_level_group(object_level_name(self), npc_level_name) then
            -- log3( "~~[%s] gulag [%s] is not in same level group for [%s] (%s, %s)", script_name(), self.gulag.name, obj:name(), object_level_name(self), npc_level_name )
            return false -- —Å —ç—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è –≤ —ç—Ç–æ—Ç —Å–º–∞—Ä—Ç –∏–¥—Ç–∏ –Ω–µ–ª—å–∑—è
        end
        --
        -- –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É, –∑–∞–¥–∞–Ω–Ω—É—é —Å–∫—Ä–∏–ø—Ç–æ–º –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è (–æ–±—ã—á–Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–∞ –≥—É–ª–∞–≥–∞ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ–ø–∏—Å—è)
        if not xr_gulag.checkNpc(community, is_stalker, self.gparams.type, obj:rank(), obj) then
            return false
        end
        --
        --–ï—Å–ª–∏ –Ω–µ–ø–∏—Å—å –Ω–µ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≤—Ä–∞–∂–¥–µ–±–µ–Ω –ª–∏ –æ–Ω —Ç–µ–º, –∫—Ç–æ —É–∂–µ –µ—Å—Ç—å –≤ —Å–º–∞—Ä—Ç–µ. –ï—Å–ª–∏ –≤—Ä–∞–∂–¥–µ–±–µ–Ω - –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ–º.
        if is_stalker and not is_exclusive then
            if xr_gulag.isGulagEnemy(self.gulag.name, obj) then
                -- log3( "~~[%s] gulag [%s] is enemy for [%s]", script_name(), self.gulag.name, obj:name() )
                return false
            end
        end
        -- –µ—Å–ª–∏ –µ—Å—Ç—å —Ä–∞–±–æ—Ç–∞   
        return self.gulag:is_there_any_suitable_job(self:fill_npc_info(obj), is_exclusive)
    end
    return false -- –µ—Å–ª–∏ –Ω–µ —ç–∫—Å–∫–ª—é–∑–∏–≤ –¥–ª—è —ç—Ç–æ–≥–æ —Å–º–∞—Ä—Ç–∞ –∏ –º–µ—Å—Ç–∞ –Ω–µ—Ç, —Ç–æ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç
end

--[[ –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –≥—É–ª–∞–≥ –æ–±—ä–µ–∫—Ç—É?
—É –æ–±—ä–µ–∫—Ç–∞ –≤ custom data –ø—Ä–æ–ø–∏—Å–∞–Ω—ã —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö smart_terrains:
	<smart_terrain_name1> = <condlist1>
	<smart_terrain_name2> = <condlist2>
	...
--[[ –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –≥—É–ª–∞–≥ –æ–±—ä–µ–∫—Ç—É?
—É –æ–±—ä–µ–∫—Ç–∞ –≤ custom data –ø—Ä–æ–ø–∏—Å–∞–Ω—ã —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö smart_terrains:
	<smart_terrain_name1> = <condlist1>
	<smart_terrain_name2> = <condlist2>
	...
–ï—Å–ª–∏ –¥–ª—è –∫–∞–∫–æ–≥–æ-—Ç–æ smart_terrain —É—Å–ª–æ–≤–∏–µ –≤—ã–ø–æ–ª–Ω–∏–ª–æ—Å—å, –æ–Ω –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–º.
–ï—Å–ª–∏ —É –æ–±—ä–µ–∫—Ç–∞ –ø–æ—è–≤–∏–ª—Å—è —Ö–æ—Ç—å –æ–¥–∏–Ω —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π smart terrain, —Ç–æ –æ–Ω –±—É–¥–µ—Ç —Å–æ–≥–ª–∞—Å–µ–Ω –∏–¥—Ç–∏ —Ç–æ–ª—å–∫–æ –≤ –Ω–µ–≥–æ.
–ï—Å–ª–∏ –Ω–µ –ø–æ—è–≤–∏–ª–æ—Å—å –Ω–∏ –æ–¥–Ω–æ–≥–æ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ–≥–æ, —Ç–æ –æ–Ω —Å–æ–≥–ª–∞—Å–µ–Ω –∏–¥—Ç–∏ –≤ –ª—é–±–æ–π.
–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–Ω–æ –∏–∑ —Ç—Ä—ë—Ö –∑–Ω–∞—á–µ–Ω–∏–π:
disagreed        - –≤ —ç—Ç–æ—Ç –Ω–µ –∏–¥—ë—Ç
agreed_exclusive - –∏–¥—ë—Ç —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ—Ç
agreed           - —Å–æ–≥–ª–∞—Å–µ–Ω –∏–¥—Ç–∏ –≤ —ç—Ç–æ—Ç –Ω–∞ –Ω–µ—ç–∫—Å–ª—é–∑–∏–≤–Ω–æ–π –æ—Å–Ω–æ–≤–µ
]]
function se_smart_terrain:obj_accepts_smart_terrain(obj)
    local conds = obj.smart_terrain_conditions
    if conds then -- –µ—Å–ª–∏ –≤–æ–æ–±—â–µ –µ—Å—Ç—å –∫–∞–∫–∏–µ-—Ç–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –Ω–∞—Å—á—ë—Ç —Å–º–∞—Ä—Ç–æ–≤
        local done = true
        if xr_logic.pick_section_from_condlist(db.actor_proxy, obj, conds["none"]) then
            return disagreed -- —è–≤–Ω–æ –ø—Ä–æ–ø–∏—Å–∞–Ω–æ, —á—Ç–æ –Ω–µ –∏–¥—ë—Ç –Ω–∏ –≤ –∫–∞–∫–æ–π —Å–º–∞—Ä—Ç
        elseif xr_logic.pick_section_from_condlist(db.actor_proxy, obj, conds[self:name()]) then
            return agreed_exclusive -- –∏–¥—ë—Ç —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ—Ç —Å–º–∞—Ä—Ç
        elseif xr_logic.pick_section_from_condlist(db.actor_proxy, obj, conds["any"]) then
            done = false -- —Ä–∞–∑—Ä–µ—à–∏–ª–∏ –∏–¥—Ç–∏ –≤ –ª—é–±–æ–π —Å–º–∞—Ä—Çend
        end
        if done then
            return disagreed -- –≤ —ç—Ç–æ—Ç –Ω–µ –∏–¥—ë—Ç
        end
    end
    -- –∑–¥–µ—Å—å –∏–º–µ–µ–º: —ç–∫—Å–∫–ª—é–∑–∏–≤–æ–≤ –Ω–µ—Ç, —è–≤–Ω–æ–≥–æ –∑–∞–ø—Ä–µ—Ç–∞ —Ç–æ–∂–µ –Ω–µ—Ç
    --
    -- –ï—Å–ª–∏ –æ–±—ä–µ–∫—Ç—É –∑–∞–ø—Ä–µ—â–µ–Ω–æ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –≤ online –∏ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ
    -- —Å–º–∞—Ä—Ç—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã, —Ç–æ –Ω–µ –ø—É—Å–∫–∞–µ–º –µ–≥–æ –Ω–∏–∫—É–¥–∞. –≠—Ç–æ –∏—Å–∫–ª—é—á–∞–µ—Ç
    -- –ø–µ—Ä–µ–±—Ä–æ—Å–∫—É –æ—Ç–∫–ª—é—á–µ–Ω–Ω—ã—Ö –¥–æ (–∏–ª–∏ –ø–æ—Å–ª–µ) –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —Å–æ–±—ã—Ç–∏—è
    -- –ª—é–¥–µ–π –∏ –º—É—Ç–∞–Ω—Ç–æ–≤ –≤ –¥—Ä—É–≥–æ–π –Ω–µ—ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π —Å–º–∞—Ä—Ç.
    --
    --if not obj:can_switch_online() then return disagreed end --—Å—Ç–∞—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
    if obj.spawner and not xr_logic.pick_section_from_condlist(db.actor_proxy, obj, obj.spawner) then
        return disagreed
    end

    return agreed -- –ø—Ä–æ—Å—Ç–æ —Å–æ–≥–ª–∞—Å–µ–Ω –∏–¥—Ç–∏ –≤ —ç—Ç–æ—Ç —Å–º–∞—Ä—Ç –±–µ–∑ –æ–±—è–∑–∞–ª–æ–≤–∫–∏
end

-- –º–æ–∂–µ—Ç –ª–∏ –æ–±—ä–µ–∫—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ smart terrain?
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å–∏–º—É–ª—è—Ç–æ—Ä–æ–º –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∑–∞–¥–∞–Ω–∏—è –¥–ª—è –æ–±—ä–µ–∫—Ç–∞/–≥—Ä—É–ø–ø—ã.
-- –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç - –≥—Ä—É–ø–ø–∞, —Ç–æ –≤–µ—Ä–Ω—ë—Ç true —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –≤ –≥—Ä—É–ø–ø–µ –≤–µ—Ä–Ω—É—Ç true
function se_smart_terrain:enabled(obj)
    -- DEBUG
    if self.disabled then
        return false
    end

    -- –µ—Å–ª–∏ –≤—Å—ë —ç—Ç–æ –¥–µ–ª–∞–µ–º –≤ –ø–µ—Ä–≤—ã–π —Ä–∞–∑
    self:register_if_needed() -- –ø—Ä–æ–∏–Ω–∏—Ç–∏–º ...–≤–æ–æ–±—â–µ-—Ç–æ —ç—Ç–æ –¥–æ–ª–∂–Ω–æ —Å –≥–∞—Ä–∞–Ω—Ç–∏–µ–π –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–º–∞—Ä—Ç–∞ –¥–≤–∏–∂–∫–æ–º,
    self:initialize_if_needed() -- –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π...

    -- –µ—Å–ª–∏ –≥—É–ª–∞–≥ –∞–∫—Ç–∏–≤–µ–Ω (–ø–æ cond_list –∏–∑ –∫–∞—Å—Ç–æ–º–¥–∞—Ç—ã —Å–º–∞—Ä—Ç–∞) –∏ –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
    if self:is_gulag_available() and not self.population_locked then
        local a = self:obj_accepts_smart_terrain(obj) --–µ—Å–ª–∏ —Å–º–∞—Ä—Ç –ø–æ–¥—Ö–æ–¥–∏—Ç –Ω–µ–ø–∏—Å—é
        local b = self:smart_terrain_accepts_obj(obj, a) --–∏ –Ω–µ–ø–∏—Å—å –ø–æ–¥—Ö–æ–¥–∏—Ç —Å–º–∞—Ä—Ç—É
        if b then
            if a == agreed_exclusive then
                self.obj_exclusive_tbl[obj.id] = true --—Å—Ä–∞–∑—É –∑–∞–ø–æ–º–Ω–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç, —á—Ç–æ–± –Ω–µ –≤—ã–∑—ã–≤–∞—Ç—å –æ–¥–Ω—É –∏ —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é —Ç—Ä–∏ —Ä–∞–∑–∞ –ø–æ–¥—Ä—è–¥
            end
            return true
        end
    end
    return false
end

-- –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ä—É –ø–æ–¥—Ö–æ–¥—è—â–µ—Å—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Å–º–∞—Ä—Ç—Ç–µ—Ä–µ–π–Ω—É.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –¥–ª—è –≤—Å–µ—Ö —Å–º–∞—Ä—Ç—Ç–µ—Ä–µ–π–Ω–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤–µ—Ä–Ω—É–ª–∏ true –∏–∑ enabled
-- –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ç–æ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π, –≤ –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂ –≤—Å—ë-—Ç–∞–∫–∏ –ø–æ–π–¥—ë—Ç.
-- –∫—Ä–∏—Ç–µ—Ä–∏–∏:
--   1) –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç —É–∂–µ –±—ã–≤–∞–ª –≤ –¥—Ä—É–≥–∏—Ö —Å–º–∞—Ä—Ç–∞—Ö, —Ç–æ —á–µ–º –±–æ–ª—å—à–µ —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Ä–∞–±–æ—Ç –Ω–∞ —É—Ä–æ–≤–Ω–µ —ç—Ç–æ–≥–æ —Å–º–∞—Ä—Ç–∞, —Ç–µ–º –ª—É—á—à–µ
--   2) –∏–Ω–∞—á–µ –±–ª–∏–∂–µ - –ª—É—á—à–µ
-- –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç—Å—è —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –Ω–µ–ø–∏—Å—è (–Ω–µ —Å–º–∞—Ä—Ç–∞), —Ç.–µ. –∑–¥–µ—Å—å –Ω–µ–ø–∏—Å—å –≤—ã–±–∏—Ä–∞–µ—Ç —Å–µ–±–µ —Å–º–∞—Ä—Ç
-- –¥–ª—è –∫–∞–∫–æ–≥–æ —Å–º–∞—Ä—Ç–∞ —á–∏—Å–ª–æ –±–æ–ª—å—à–µ, —Ç—É–¥–∞ –∏ –ø–æ–π–¥—ë—Ç
function se_smart_terrain:suitable( obj )
    if self.obj_exclusive_tbl[obj.id] then --–ü–æ–≤—ã—Å–∏—Ç—å –ø–æ–¥—Ö–æ–¥—è—â–µ—Å—Ç—å —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ–≥–æ —Å–º–∞—Ä—Ç—Ç–µ—Ä—Ä–µ–π–Ω–∞
        return 100000 --–°—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º, –∑–∞—á–µ–º –µ—â—ë —á—Ç–æ-—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –µ—Å–ª–∏ —ç—Ç–æ –∑–∞–≤–µ–¥–æ–º–æ –±–æ–ª—å—à–µ –≤—Å–µ—Ö
    end
    --
    if obj.level_name ~= self.level_name then
        -- —Å–º–∞—Ä—Ç –Ω–∞ –¥—Ä—É–≥–æ–π –ª–æ–∫–∞—Ü–∏–∏ –±—É–¥–µ—Ç –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–µ–µ —Å–º–∞—Ä—Ç–∞ –Ω–∞ –ª–æ–∫–∞—Ü–∏–∏ –Ω–µ–ø–∏—Å—è.
        -- –ü–æ–ª–∞–≥–∞—é, —ç—Ç–æ –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –±–æ–ª—å—à–µ–π –¥–≤–∏–∂—É—Ö–µ.
        if self.level_name == level.name() then
            -- –ø—É—Å—Ç—å —Å –¥—Ä—É–≥–∏—Ö –ª–æ–∫–∞—Ü–∏–π –ø–µ—Ä–≤—ã–º –¥–µ–ª–æ–º –∏–¥—É—Ç –∫ –∞–∫—Ç–æ—Ä—É
            return math.random(201, 300)
        else
            return math.random(101, 200)
        end
    end

    return math.random(100)
end

------------ –¥–æ–±–∞–≤–∏—Ç—å npc –≤ smart terrain.
-- –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –¥–≤–∏–∂–æ–∫ —Å –ø–æ–º–æ—â—å—é suitable –≤—ã–±—Ä–∞–ª –ø–æ–¥—Ö–æ–¥—è—à–∏–π —Å–º–∞—Ä—Ç, –æ–Ω —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –Ω–µ–ø–∏—Å—è –≤ –Ω—ë–º
-- —Å –ø–æ–º–æ—â—å—é —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏:
-- –µ—Å–ª–∏ –º–µ—Å—Ç–∞ –Ω–µ—Ç—É –∏–ª–∏ –Ω–µ—Ç—É —Å–≤–æ–±–æ–¥–Ω—ã—Ö –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ä–∞–±–æ—Ç, —Ç–æ
-- –≤—ã—Ç–æ–ª–∫–Ω—É—Ç—å –∏–∑ —ç—Ç–æ–≥–æ smart terrain —Å –ø–æ–¥—Ö–æ–¥—è—â–µ–π —Ä–∞–±–æ—Ç—ã –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ø–∞–ª –≤ –Ω–µ–≥–æ –Ω–µ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ.
function se_smart_terrain:register_npc(obj)
    local npc_info = {
        -- —Å—Ç–∞—Ä—ã–µ squad –∏ group
        o_group = obj:g_group(),
        o_squad = obj:g_squad(),
        exclusive = self.obj_exclusive_tbl[obj.id] == true,

        stay_end = game.get_game_time() -- –≤—Ä–µ–º—è –ø—Ä–∏–Ω—è—Ç–∏—è –≤ —Å–º–∞—Ä—Ç
    }
    --
    self.obj_exclusive_tbl[obj.id] = nil --–¥–∞–ª—å—à–µ —ç—Ç–æ —Ö—Ä–∞–Ω–∏—Ç—å –Ω–µ—Ç —Å–º—ã—Å–ª–∞
    --
    self:fill_npc_info(obj, npc_info)
    --
    --–ï—Å–ª–∏ –≥—É–ª–∞–≥ –∞–∫—Ç–∏–≤–µ–Ω, —Ç.–µ. —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–ø–∏—Å–µ–π –∏ –Ω–µ—Ç –Ω–µ—ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã—Ö —Ä–∞–±–æ—Ç
    if self.gulag_working and not self.gulag:is_there_any_suitable_job( npc_info, false ) then
        --log3( "get_population=%d capacity=%d", self.gulag:get_population(), self.gulag.capacity )
        --log3( "is_there_any_suitable_job=%s", tostring(self.gulag:is_there_any_suitable_job(npc_info, false)) )
        --log1( table.tostring(self.npc_info) )
        self:kick_someone_non_exclusive( npc_info ) -- –∫–æ–≥–æ-—Ç–æ –≤—ã–∫–∏–¥—ã–≤–∞–µ–º
    end

    self:update_obj_rank(obj)

    self.npc_info[obj.id] = npc_info

    if not self.gulag_working then -- –µ—Å–ª–∏ —Ç–∞–º –µ—â—ë –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤
        self:create_gulag() -- –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ –≥—É–ª–∞–≥
    end

    self.gulag:addObject(obj.id) -- —Ç–∞–∫–∏ –¥–æ–±–∞–≤–∏–ª–∏ –æ–±—ä–µ–∫—Ç

    self.gulag:update() -- –æ–±–Ω–æ–≤–∏–ª–∏

    --	log3( "[smart_terrain %s] added %s to gulag type=%s", self:name(), obj:name(), self.gparams.type )
end

-- –æ—Ç–ø—É—Å—Ç–∏—Ç—å npc
function se_smart_terrain:unregister_npc(obj)
    ASSERT(self.npc_info[obj.id], "object [%s] not found in [%s]", obj:name(), self:name())

	--' –ï—Å–ª–∏ –∞–Ω—Ä–µ–≥–∏—Å—Ç—Ä–∏–º –º–µ—Ä—Ç–≤–æ–≥–æ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ–≥–æ –ù–ü–°, –Ω—É–∂–Ω–æ —É–º–µ–Ω—å—à–∏—Ç—å —Å—á–µ—Ç—á–∏–∫ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ—Å—Ç–∏
	if obj.smart_terrain_conditions then
        local condlist = obj.smart_terrain_conditions[self:name()]
        if condlist and xr_logic.pick_section_from_condlist(db.actor_proxy, obj, condlist) then
            self.exclusives = self.exclusives - 1 --' —É–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫
            self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive + 1
        end
    end

    local n = self.npc_info[obj.id]

    self.gulag:removeObject(obj.id)

    obj.squad = n.o_squad
    obj.group = n.o_group

    self.npc_info[obj.id] = nil

    obj:clear_smart_terrain()
end

-- —É–≤–µ–ª–∏—á–∏—Ç—å —Ä–∞–Ω–≥ —Å—Ç–∞–ª–∫–µ—Ä–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤ —Å–º–∞—Ä—Ç–µ
function se_smart_terrain:update_obj_rank(obj)
    local community, is_stalker = self:get_obj_community( obj )
    if is_stalker then
        local old_rank = obj:rank()

        obj:set_rank(old_rank + math.random(self.rank_inc_min, self.rank_inc_max))

        --		log3( "[smart_terrain %s] obj=%s rank %d -> %d", self:name(), obj:name(), old_rank, obj:rank() )
    end
end

-- –≤—ã–≥–Ω–∞—Ç—å –∏–∑-–ø–æ–¥ —Å–º–∞—Ä—Ç—Ç–µ—Ä—Ä–µ–π–Ω–∞ –ø–µ—Ä–≤–æ–≥–æ –ø–æ–ø–∞–≤—à–µ–≥–æ—Å—è –Ω–µ—ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞,
-- –∫–æ—Ç–æ—Ä—ã–π –∑–∞–Ω–∏–º–∞–µ—Ç —Ä–∞–±–æ—Ç—É, –ø–æ–¥—Ö–æ–¥—è—â—É—é –Ω–æ–≤–æ–º—É –ø–µ—Ä—Å–æ–Ω–∞–∂—É.
-- TODO –∞ –µ—Å–ª–∏ —è –≤—ã–≥–æ–Ω—é –∫–æ–≥–æ-—Ç–æ, –∞ –µ–≥–æ —Ä–∞–±–æ—Ç–∞ –Ω–µ –ø–æ–¥–æ–π–¥—ë—Ç –ø–æ idle ?
function se_smart_terrain:kick_someone_non_exclusive(new_npc_info)
    for obj_id, npc_info in pairs(self.npc_info) do
        if not npc_info.exclusive and self.gulag:obj1_job_suits_obj2(obj_id, new_npc_info) then
            self:unregister_npc(npc_info.se_obj)
            return
        end
    end

    abort("[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs", self:name())
end

function se_smart_terrain:reset_npc_logic(obj)
    if obj then
        local npc = level.object_by_id(obj.id)
        local npc_id = obj.id
        if npc then
            xr_logic.reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
        end
        if db.storage[npc_id] then
            db.storage[npc_id].overrides = nil
            db.storage[npc_id].active_section = nil
            db.storage[npc_id].active_scheme = nil
        end
    end
end

-- –≤—ã–¥–∞—Ç—å –æ–±—ä–µ–∫—Ç—É –∑–∞–¥–∞–Ω–∏–µ.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –¥–≤–∏–∂–∫–æ–º –ø–æ—Å–ª–µ –≤–∫–ª—é—á–µ–Ω–∏—è –Ω–µ–ø–∏—Å—è –≤ —Å–æ—Å—Ç–∞–≤ —Å–º–∞—Ä—Ç–∞
-- –∑–∞–¥–∞–Ω–∏–µ –≤ –æ—Ñ—Ñ–ª–∞–π–Ω–µ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –ø–æ–ø—Ä–æ—Å—Ç—É —Ç–æ–ø–∞—Ç—å –∫ —Å–º–∞—Ä—Ç—É, –≥–¥–µ –Ω–µ–ø–∏—Å—å 
-- –≤—ã–π–¥–µ—Ç –≤ –æ–Ω–ª–∞–π–Ω –∏ –±—É–¥–µ—Ç –ø–æ–¥—Ö–≤–∞—á–µ–Ω —É–∂–µ –ª–æ–≥–∏–∫–æ–π –≥—É–ª–∞–≥–∞
function se_smart_terrain:task(obj)
    local path_name = self.gulag:get_obj_job_path_name(obj.id)
    if not path_name then
        log1("!!WARNING: NO PATH [" .. obj.id .. "] [" .. obj:name() .. "] [" .. self:name() .. "] PATH [" ..
                 tostring(path_name) .. "]")
        -- log3("[smart_terrain %s] task: obj=%s job_path=nil, CLEARING", self:name(), obj:name() )
        self.gulag:free_obj(obj.id)
        self:unregister_npc(obj) -- '«‡Ú˚˜Í‡ ÔÓÚË‚ ‚˚ÎÂÚ‡.
        self:reset_npc_logic(obj)
        return CALifeSmartTerrainTask("simulation_default_path")
    end

    return CALifeSmartTerrainTask(path_name)
end

-- –º–æ–∂–µ—Ç –ª–∏ –¥–∞–Ω–Ω—ã–π –≥—É–ª–∞–≥ —Å–æ–∑–¥–∞—Ç—å—Å—è –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç?
function se_smart_terrain:is_gulag_available()
    -- –µ—Å–ª–∏ –µ—Å—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –≥—É–ª–∞–≥–∞
    if self.gparams.cond then
        -- —Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö
        local bb = xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.gparams.cond) ~= nil
        return bb
    else -- –µ—Å–ª–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π –Ω–µ—Ç
        return true -- —Ç–æ –∑–Ω–∞—á–∏—Ç –≤—Å–µ–≥–¥–∞ –º–æ–∂–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å
    end
end

-- –≤ –≥—É–ª–∞–≥ –ø–æ—Å—Ç—É–ø–∏–ª –ø–µ—Ä–≤—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂ –∏ –æ–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å
-- –Ω–∞–∑–≤–∞–Ω–∏–µ –≤ —Ü–µ–ª–æ–º –∑–∞–ø—É—Ç—ã–≤–∞–µ—Ç! –≠—Ç–æ –Ω–µ —Å–æ–∑–¥–∞–Ω–∏–µ, –∞ —Å–∫–æ—Ä–µ–µ –∞–∫—Ç–∏–≤–∞—Ü–∏—è –≥—É–ª–∞–≥–∞
function se_smart_terrain:create_gulag()
    self.check_time = time_global()

    self.gulag:initialize()

    self.gulag_working = true
end

-- –≤—Å–µ—Ö –æ—Å–≤–æ–±–æ–¥–∏—Ç—å, —É–±–∏—Ç—å –≥—É–ª–∞–≥,
-- —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –Ω–µ—Ä–∞–±–æ—á–∏–π –≥—É–ª–∞–≥, –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞—Ç—å –≤ –Ω—ë–º –º–µ—Å—Ç–∞ –¥–ª—è —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã—Ö
function se_smart_terrain:remove_gulag(disable)
    -- DEBUG
    self.disabled = disable
    --------

    if not self.gulag_working then
        return
    end

    -- log3( "[smart_terrain %s] removed gulag type=%s", self:name(), self.gparams.type )

    -- –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
    for id, npc_info in pairs(self.npc_info) do
        self:unregister_npc(npc_info.se_obj)
        --–ï—Å–ª–∏ —Å–º–∞—Ä—Ç –∑–∞–∫—Ä—ã–ª—Å—è, —Ç–æ –≤—Å–µ—Ö –ø–æ–¥–æ–ø–µ—á–Ω—ã—Ö –ø–æ–ø—Ä–æ–±—É–µ–º –ø–æ—Å–∫–æ—Ä–µ–µ –ø—Ä–∏—Å—Ç—Ä–æ–∏—Ç—å
        --–ß—Ç–æ –±—ã –Ω–µ —à–ª—è–ª–∏—Å—å –ø–æ –ª–æ–∫–∞—Ü–∏–∏ –ø–æ—á–µ–º –∑—Ä—è –∏ –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ –ø–æ–ª—É—á–∏–ª–∏
        --—Å–≤–æ—é –ª–æ–≥–∏–∫—É, –µ—Å–ª–∏ –Ω–æ–≤—ã–π —Å–º–∞—Ä—Ç –Ω–∞ —ç—Ç–æ–π –∂–µ –ª–æ–∫–∞—Ü–∏–∏, –∫–∞–∫ –≤ —Å–ª—É—á–∞–µ —Å
        --–±–∞–Ω–¥–∏—Ç–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–≥–æ–≤—Ü–∞ —Ä–∞—Å—Å—Ç—Ä–µ–ª–∏–≤–∞—é—Ç.
        npc_info.se_obj:brain():update()
    end

    self.gulag = xr_gulag.gulag(self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity)
    self.gulag:load_jobs()

    self.gulag_working = false

    self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - self.exclusives
end

-- –∑–∞–ø–æ–ª–Ω—è–µ—Ç —Ç–∞–±–ª–∏—Ü—É monster_classes
-- TODO: –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª
function se_smart_terrain:fill_monster_classes()
    if not monster_classes then
        monster_classes = {
            [clsid.bloodsucker_s] = "bloodsucker",
            [clsid.boar_s] = "boar",
            [clsid.burer_s] = "burer",
            [clsid.cat_s] = "cat",
            [clsid.chimera_s] = "chimera",
            [clsid.controller_s] = "controller",
            [clsid.pseudodog_s] = "pseudodog",
            [clsid.psy_dog_s] = "psy_dog",
            [clsid.dog_s] = "dog",
            [clsid.flesh_s] = "flesh",
            [clsid.fracture_s] = "fracture",
            [clsid.poltergeist_s] = "poltergeist",
            [clsid.gigant_s] = "pseudo_gigant",
            [clsid.snork_s] = "snork",
            [clsid.tushkano_s] = "tushkano",
            [clsid.zombie_s] = "zombie"
        }
    end
end

-- —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞ –≤ —Å–∏–º—É–ª—è—Ç–æ—Ä–µ.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –¥–≤–∏–∂–∫–æ–º –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏/—Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞.
function se_smart_terrain:on_register()

    cse_alife_smart_zone.on_register(self)

    --TODO: –ê —á—Ç–æ –±—É–¥–µ—Ç –µ—Å–ª–∏ —ç—Ç–æ —É–¥–∞–ª–∏—Ç—å?
    --KRodin: —ç—Ç–∏ —Å–º–∞—Ä—Ç—ã –∏ —Ç–∞–∫ –∑–∞–∫—Ä—ã–≤–∞—é—Ç—Å—è –ø–æ –∫–æ–Ω–¥–ª–∏—Å—Ç—É cond = {-pri_stadium_scene_start} , —Ç.—á. —ç—Ç–æ—Ç –∫–æ–¥ –Ω–µ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª–∞. –ö–æ—Å—Ç—ã–ª—å –∫–∞–∫–æ–π-—Ç–æ.
    --if has_alife_info("pri_stadium_scene_start") and string.find(self:name(), "pri_wave") then
    --	self:remove_gulag(true)
    --end		

    -- –ø—Ä–æ–∏–Ω–∏—Ç–∏—Ç—å –æ–±—ä–µ–∫—Ç
    self:register_if_needed()
    self:initialize_if_needed()
end

function se_smart_terrain:register_if_needed()
    --' –ï—Å–ª–∏ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–µ–Ω—ã —Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—Ç—å.
    if self.registred then
        return
    end
    self.registred = true

    -- log3( "%s register called", self:name() )
    -- DEBUG
    if self.disabled then
        return
    end

    self:fill_monster_classes()

    local level_name = object_level_name(self)

    if not self.gparams.preset_name then
        self.gparams.preset_name = level_name
    end

    if not smart_terrains[level_name] then
        smart_terrains[level_name] = {}
    end

    smart_terrains[level_name][self.id] = self

    self.gulag:load_jobs()

    if self.gulag_working then
        self.gulag:initialize()
    end
end

-- –¥–µ—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞ –≤ —Å–∏–º—É–ª—è—Ç–æ—Ä–µ.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –¥–≤–∏–∂–∫–æ–º –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º –æ–±—ä–µ–∫—Ç–∞ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ª–∏ –≤–æ–æ–±—â–µ, —Å–º–∞—Ä—Ç—ã –Ω–∏–∫—Ç–æ –Ω–µ —É–¥–∞–ª—è–µ—Ç)
function se_smart_terrain:on_unregister()
    cse_alife_smart_zone.on_unregister( self )

    local lvl_smarts = smart_terrains[object_level_name(self)]

    if lvl_smarts then
        lvl_smarts[self.id] = nil
    end

    db.actor_proxy:deinit() -- ?? –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –∫–∞–∂–¥–æ–≥–æ —Ç–∞–∫–æ–≥–æ –º–µ—Ç–æ–¥–∞
end

-- –≤—ã–∑–≤–∞—Ç—å —Å–ø–∞–≤–Ω–µ—Ä, –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ gulag:beginJob(obj_id)
function se_smart_terrain:call_respawn()
    if self.gparams.respawn then
        se_respawn.spawn(self.gparams.respawn)
    end
end

-- òòòòòòòòòò òòòòòò ò òòòòòòòòòòòò òòòòòòòòòòòòò ò òòòòòòò
-- –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å –ø—Ä–∏–Ω–∏–º–∞–µ–º—ã–º–∏ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞–º–∏ –∏ —Ä–∞–Ω–≥–∞–º–∏
function se_smart_terrain:stat_get_accepted_communities() -- –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è, —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏!!
    local comms = {}

    -- from preset
    local ltx = dsh.cached_ini_file("misc\\" .. self.gparams.type .. ".ltx")
    local preset_name = self.gparams.preset_name

    if ltx and ltx:section_exist(preset_name) then
        local result, field, str
        local n = ltx:line_count(preset_name)

        for i = 0, n - 1 do
            result, field, str = ltx:r_line(preset_name, i)

            if not self.accepted_communities or self.accepted_communities[field] then
                comms[field] = str
            end
        end
    end

    -- from custom data
    if self.accepted_communities then
        for comm, v in pairs(self.accepted_communities) do
            if not comms[comm] then
                comms[comm] = "all"
            end
        end
    end

    -- prepare return
    local s = ""

    for comm, ranks in pairs(comms) do
        s = s .. comm .. "(" .. ranks .. "),"
    end

    return s
end

-- –≤—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–º–∞—Ä—Ç–∞
function se_smart_terrain:stat() -- –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è, —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏!!
    local s = object_level_name(self) .. " " .. self:name()

    local pop = self.gulag:get_population()
    local cap = self.gulag.capacity

    local avail = self:is_gulag_available()

    if avail then
        s = s .. " enabled "
    else
        s = s .. " disabled "
    end

    s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()

    log3(s)
    return avail, pop, cap
end

-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ.
-- –í –æ–Ω–ª–∞–π–Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ binder.
-- –¢–∞–∫–∂–µ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å—Å—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏–∑ xr_effects
-- –ï—Å–ª–∏ –º—É–∂–∏–∫–æ–≤ –≤ –≥—É–ª–∞–≥–µ –±–æ–ª—å—à–µ –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –∏–ª–∏ —É—Å–ª–æ–≤–∏—è —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –≥—É–ª–∞–≥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è, —Ç–æ —É–±—Ä–∞—Ç—å –≥—É–ª–∞–≥.
function se_smart_terrain:update()
    --	log1( "se_smart_terrain::update called!" )
    cse_alife_smart_zone.update(self)

    if not self.gulag_working then
        return
    end

    if self:is_gulag_available() then
        if self.check_time <= time_global() then
            self.check_time = time_global() + check_period

            --' –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –Ω–µ —Å–æ–±—Ä–∞–ª—Å—è –ª–∏ –∫—Ç–æ-—Ç–æ –∫ —ç—Ç–æ–º—É –≤—Ä–µ–º–µ–Ω–∏ —É–∂–µ —É—Ö–æ–¥–∏—Ç—å
            for id, npc_info in pairs(self.npc_info) do
                local sobj = npc_info.se_obj
                if not sobj:alive() then
                    log3("[%s]: %s: %s is dead on update", script_name(), self:name(), sobj:name())
                    self:unregister_npc(sobj)
                elseif npc_info.cond and not xr_logic.pick_section_from_condlist(db.actor_proxy, sobj, npc_info.cond) then
                    -- log3("[smart_terrain %s] leaving %s", self:name(), npc_info.name)
                    self:unregister_npc(sobj)
                    -- –ü—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ —Å–º–∞—Ä—Ç–æ–≤ –ø–æ–ø—Ä–æ–±—É—é —Å—Ä–∞–∑—É –æ–±–Ω–æ–≤–ª—è—Ç—å –º–æ–∑–≥–∏,
                    -- —á—Ç–æ –±—ã –Ω–æ–≤—ã–π —Å–º–∞—Ä—Ç –ø–æ–¥—Ö–≤–∞—Ç–∏–ª –Ω–µ–ø–∏—Å—è, –∫–∞–∫ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–µ–µ, –∏ –¥–∞–ª –µ–º—É –ª–æ–≥–∏–∫—É.
                    sobj:brain():update()
                end
            end

            if self.gulag:get_population() == 0 then
                self:remove_gulag()
            else
                self.gulag:update()
            end
        end
    else
        if self.on_cleanup then
            local f, err = loadstring("return " .. self.on_cleanup .. "( ... )")
            ASSERT(f, err)
            f(self)
        end
        self:remove_gulag()
    end
end

--------------------
-- –Ω–∞–π—Ç–∏ –∏ –ø–æ—á–∏—Å—Ç–∏—Ç—å –≥—É–ª–∞–≥ –æ–±—ä–µ–∫—Ç–∞
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –∫—É—á–∏ –º–µ—Å—Ç. –°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ –¥—É–±–∏—Ä—É–µ—Ç—Å—è –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ
function on_death(obj_id)
    --	log3( "on_death obj_id=%d", obj_id )
    local sim = alife()
    if sim then
        local obj = sim:object(obj_id)
        if obj then
            local smrt_id = obj:smart_terrain_id()
            if 65535 ~= smrt_id then
                local smrt = sim:object(smrt_id)
                if smrt and smrt.gulag then
                    smrt.gulag:clear_dead(obj_id)
                end
            end
        end
    end
end

-----------------------
--' –£–¥–∞–ª—è–µ—Ç –æ–±—ä–µ–∫—Ç –∏–∑ —Å–º–∞—Ä—Ç—Ç–µ—Ä—Ä–µ–π–Ω–æ–≤.
function unregister_npc(npc)
    local sim = alife()

    if sim then
        local obj = sim:object(npc.id)
        local strn_id = obj:smart_terrain_id()

        if strn_id ~= 65535 then
            if sim:object(strn_id) then
                sim:object(strn_id):unregister_npc(obj)
            end
        end
    end
end

--------------------
-- –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Å–µ–∫—Ü–∏—é [smart_terrains]
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –æ–±—ä–µ–∫—Ç–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —Ö–æ–¥–∏—Ç—å –ø–æ–¥ smart terrain
-- –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ se_monster:fill_exclusives() –≤ —Ñ–∞–π–ª–µ se_monster –∏  –∏ se_stalker.se_stalker:fill_exclusives()
--
-- –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ [smart_terrains] –≤ —Ñ–∞–π–ª–µ –ª–æ–≥–∏–∫–∏
-- https://github.com/dsh2dsh/op2ogse/commit/d95b91610c4b346ab7cc08ef17e1c3a7ba9ed9fc
function read_smart_terrain_conditions(self)
    local ini = self.ini
    local sect = smart_section
    local dsh_sect = "dsh.se_stalker." .. self:name() .. ".smart_terrains"
    --
    if sys_ini:section_exist(dsh_sect) then
        ini = sys_ini
        sect = dsh_sect
    else
        if ini then
            if (not ini:section_exist(sect)) and ini:section_exist("logic") then
                local cfg = get_string("logic", "cfg", nil, ini)
                if cfg then
                    -- log3("~~[smart_terrain %s]: Smart section not found in spawn_ini(). Will be used logic file: [%s]", self:name(), cfg)
                    ini = dsh.cached_ini_file(cfg)
                end
            end
        end
    end
    --
    if ini and ini:section_exist(sect) then
        local has_none_true = false
        local conds = {}
        local accepts = false
        local n = ini:line_count(sect)
        if n > 0 then
            for i = 0, n - 1 do
                local result, field, str = ini:r_line(sect, i)
                conds[field] = xr_logic.parse_condlist(self, sect, field, str)
                if field == "none" and str == "true" then
                    has_none_true = true
                end
            end
            -- log3("~~\n[Smart Terrain] Conditions for %s: %s", self:name(), conds)
            return conds, has_none_true
        end
    end
    -- log3("!![smart_terrain %s]: Smart section not found!", self:name())
    return nil
end

function iterate_smart_terrains(f)
    for lname, smarts in pairs(smart_terrains) do
        for id, sobj in pairs(smarts) do
            f(sobj)
        end
    end
end
