local enable_debug = false

local function throttle(func, tg_throttle)
    local tg = 0
    if not tg_throttle or tg_throttle == 0 then
        return function(...)
            local t = time_global()
            if t ~= tg then
                tg = t
                return func(...)
            end
        end
    else
        return function(...)
            local t = time_global()
            if t < tg then return end
            tg = t + tg_throttle
            return func(...)
        end
    end
end

-- Check for material (engine edit required)
function lshift(x, by)
    return x * 2 ^ by
end

function vec_sub(v1,v2)
	return vector():set(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
end

-- Geometry Ray class by Thial, edited by demonized
class "geometry_ray"

--[[
(At least one range parameter should be specified)
ray_range:
    Defines the total range of the ray. If you want to attach the ray to
    a fast moving object it is good to extend the ray so that you can reduce
    the polling rate by using the get function.
contact_range:
    Defines the distance at which the result will report being in contact.
    You can skip it or set it to a value lower than the ray_range to
    still be able to get the intersection position from the result while
    marking the ray as not being in contact yet
distance_offset:
    Defines how much the intersection position is offset.
    You can use both positive and negative values or you can leave it blank.
flags (bit map = values can be added together for combined effect):
    0 : None
    1 : Objects
    2 : Statics
    4 : Shapes
    8 : Obstacles
]]--

function geometry_ray:__init(args)
    local args = args or {}
    if not args.ray_range and not args.contact_range then
        return nil
    end

    self.ray_range = args.ray_range or args.contact_range
    self.contact_range = args.contact_range or args.ray_range
    self.distance_offset = args.distance_offset and args.distance_offset or 0
    self.flags = args.flags and args.flags or rq_target.rqtStatic
    if args.ignore_object then
        self.ignore_object = args.ignore_object
    end
    self.ray = level.get_current_ray_query()
end

function geometry_ray:get(position, direction)   
    if not position or not direction == nil then
        return nil
    end

    local position = vector():set(position)
    local direction = vector():set(direction)

    local res = level.ray_query(position, direction, self.ray_range, self.flags, self.ignore_object)
    local distance = res.result and self.ray.range or self.ray_range
    local result = {}
    result.in_contact = distance <= self.contact_range
    result.position = position:add(direction:mul(distance + self.distance_offset))
    result.distance = distance
    result.raw_distance = self.ray.range
    result.success = res.result
    result.object = self.ray.object
    result.element = self.ray.element
    result.result = self.ray.result

    return result
end

-- Utils
-- Check if values are similar to a precision
function similar(float1, float2, epsilon)
    return math.abs(float1 - float2) <= (epsilon or 0.0001)
end

function vec_similar(vec1, vec2, epsilon)
    return similar(vec1.x, vec2.x, epsilon) and similar(vec1.y, vec2.y, epsilon) and similar(vec1.z, vec2.z, epsilon)
end

-- Linear inter/extrapolation
function lerp(a, b, f)
    if a and b and f then
        return a + f * (b - a)
    else
        return a or b or 0
    end
end

local EPS = 0.0000100
local function fsimilar(value, to, eps)
    return math.abs(value - to) < eps
end

local function generate_orthonormal_basis_normalized(d)
    local dir = vector():set(d):normalize()
    local up = vector():set(0,0,0)
    local right = vector():set(0,0,0)
    local fInvLength
    if (fsimilar(dir.y, 1.0, EPS)) then
        up:set(0, 0, 1)
        fInvLength = 1 / math.sqrt(dir.x * dir.x + dir.y * dir.y)
        right.x = -dir.y * fInvLength
        right.y = dir.x * fInvLength
        right.z = 0
        up.x = -dir.z * right.y
        up.y = dir.z * right.x
        up.z = dir.x * right.y - dir.y * right.x
    else
        up:set(0, 1, 0)
        fInvLength = 1 / math.sqrt(dir.x * dir.x + dir.z * dir.z)
        right.x = dir.z * fInvLength
        right.y = 0
        right.z = -dir.x * fInvLength
        up.x = dir.y * right.z
        up.y = dir.z * right.x - dir.x * right.z
        up.z = -dir.y * right.x
    end
    return dir, up, right
end

-- Get surface normals by Aoldri, edited by demonized
function get_surface_normal(pos, dir, ray_props)
    local get_geometry_ray = geometry_ray({
        ray_range = ray_props and ray_props.ray_range or 1000, 
        flags = ray_props and ray_props.flags or rq_target.rqtBoth,
        ignore_object = db.actor
    })

    -- Get player's camera position and direction in world space
    local pos0 = pos and vector():set(pos) or device().cam_pos
    local angle1 = dir and vector():set(dir) or device().cam_dir

    -- Generate two positions orthogonal to camera direction and each other
    local angle1, pos01, pos02 = generate_orthonormal_basis_normalized(angle1)
    pos01 = pos01:mul(0.01)
    pos02 = pos02:mul(0.01)

    pos01 = pos01:add(pos0)
    pos02 = pos02:add(pos0)

    -- Get positions of intersections of rays around pos0
    local ray = get_geometry_ray
    local res = ray:get(pos0, angle1)
    local pos1 = res.position
    local pos2 = ray:get(pos01, angle1).position
    local pos3 = ray:get(pos02, angle1).position

    if not res.success then
        return
    end

    -- Get vectors from intersection points from pos1
    local vec2 = vec_sub(pos1, pos2)
    local vec3 = vec_sub(pos1, pos3)

    -- Find normal vector of surface by taking cross product of intersection vectors
    local cross = (vector_cross(vec2, vec3)):normalize()   

    -- If the direction and normal vectors heading in similar direction - invert normal
    local deg = angle1:dotproduct(cross)
    if deg > 0 then
        cross:invert()
    end

    cross.x = math.clamp(cross.x, -1, 1)
    cross.y = math.clamp(cross.y, -1, 1)
    cross.z = math.clamp(cross.z, -1, 1)

    return cross
end
