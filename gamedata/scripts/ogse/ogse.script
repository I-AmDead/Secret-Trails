-- -*- mode: lua; coding: windows-1251-dos -*-
-----------------------------------------------------------------------
--- ogse.script
--- Утилитарная база OGSE 0.6.9.3
--- 2007-2008 (c) xStream, DEXXX
--- 2009-2013 (c) OGS Evolution Team
-----------------------------------------------------------------------

local k_timers = 1
game_time_factor = level.get_time_factor()
local npc_spawner={}
local quest_dead_on_arrival = {}
local timers={}
local g_timers={}
local markers={}
local x_objs={}
local timer_trigger=nil

local vertexes_checked = false
local bar_timer = time_global()
local sleep_timer = time_global()
local car_timer = time_global()
local ids_timer = time_global()
local mine_timer = time_global()
local health_time = time_global()
local loot_timer = time_global()
local new_mine_timer = time_global()
local buggy_timer = time_global()
local anom_enum = time_global()
local armor_healing = time_global()
local heal_interval = 200
local watchdog = 0
local watchdog_max = 28
local drug_timer = time_global()
local off_timer = time_global()
local off_timer_1 = time_global()
local timer_trigger_step = 500		-- шаг проверки таймеров (мс)
local main_variable_tbl = nil
local loaded_slot = nil

-- Переменные для типсов
tips_variable = {
	["pda_news"] = ([[device\pda\pda_news]]),
	["pda_tips"] = ([[device\pda\pda_tip]]),
	["pda_task"] = ([[device\pda\pda_objective]]),
	["pda_sos"] = ([[device\pda\pda_sos]]),
}

tips_icons = {
	default  = { 82, 282},
	trader   = { 332, 893},
	dolg     = { 0, 658},
	freedom  = { 0, 658},
	ecolog   = { 498, 0},
	arena    = { 332, 141},
	stalker  = { 0, 658},
	krot     = { 332, 47},
	barman   = { 332, 235},
	wolf	   = { 332, 940},
	o_soznanie = { 498, 893},
	monolith = { 0, 658},
	saharov  = { 332, 470},
	prizrak  = { 0, 658},
	killer   = { 0, 658},
	death    = { 0, 752},
	gen_info	= { 0, 658},
	trade 	= { 0, 0},
	uniq	= { 498, 47}
}

--- Перезапуск логики NPC
function reset_npc_logic(obj)
	if obj then
		local npc_id = obj:id()
		db.storage[npc_id].overrides = nil
		xr_logic.reset_generic_schemes_on_scheme_switch(obj, "nil", "nil")
		db.storage[npc_id].active_section = nil
		db.storage[npc_id].active_scheme = nil
	end
end

-- Получение заданного настройками fov
function get_default_fov()
	return fov_vol
end
-- Получение максимально допустимого настройками fov
function get_max_alarm_fov()
	return max_alarm_fov_vol
end
-- Получение минимально допустимого настройками fov
function get_min_alarm_fov()
	return min_alarm_fov_vol
end

-- Проверка нахождения актора в особой зоне
function actor_in_zone(pos_psy_x,pos_psy_y,size_psy_x,size_psy_y,z1,z2)
local pos = db.actor:position()
local x1 = pos_psy_x
local x2 = pos_psy_y
local y1 = size_psy_x
local y2 = size_psy_y
if (pos.x >= x1 and pos.x <= x2) and (pos.z >= y1 and pos.z <= y2) and (pos.y >= z1) and (pos.y <= z2) then
	return 1
end
return 0
end

-- Проверка нахождения НПС в особой зоне
function npc_in_zone(obj,lev,pos_psy_x,pos_psy_y,size_psy_x,size_psy_y,z1,z2)
local level_name = level.name()
if level_name ~= lev then
	return false
end
local pos = obj:position()
local x1 = pos_psy_x
local x2 = pos_psy_y
local y1 = size_psy_x
local y2 = size_psy_y
if (pos.x >= x1 and pos.x <= x2) and (pos.z >= y1 and pos.z <= y2) and (pos.y >= z1) and (pos.y <= z2) then
	return true
end
return false
end

-- Проверка, является ли объект монстром
function is_monster(object)
local id = get_clsid (object)
if id == clsid.boar_s or
   id == clsid.bloodsucker_s or
   id == clsid.dog_s or
   id == clsid.flesh_s or
   id == clsid.pseudodog_s or
   id == clsid.psy_dog_s or
   id == clsid.burer_s or
   id == clsid.cat_s or
   id == clsid.chimera_s or
   id == clsid.controller_s or
   id == clsid.fracture_s or
   id == clsid.poltergeist_s or
   id == clsid.gigant_s or
   id == clsid.zombie_s or
   id == clsid.tushkano_s or
   id == clsid.snork_s then
	return 1
end
return 0
end

--- Возвращает true если параметром передан квестовый непись
function is_quest_npc(npc)
	local story = INVALID_STORY_ID
	if npc then
		if npc.m_story_id ~= nil then
			story = npc.m_story_id
		else
			story = npc:story_id()
		end
		if story == INVALID_STORY_ID then
			local profile = npc:profile_name()
			local name = npc:name()
			if quest_profiles[profile] or quest_profiles[name] then
				return true
			end
		end
	end
	if story ~= INVALID_STORY_ID then return true else return false end
end

-- телепортация NPC в пределах уровня
-- сама функция только ставит флажок на выпихивание в оффлайн и запускает ждущий таймер
-- вся работа будет сделана в экшине таймера
function teleport_npc(npc_id, pos)
   local s_npc = alife():object(npc_id)
   s_npc.force_offline = true
   go_offline_watch_timer(npc_id, pos):start() -- таймер "выстрелил-забыл"
end
-- служебный таймер, ждущий ухода в оффлайн
class "go_offline_watch_timer" (ogse_qt.quick_timer)
function go_offline_watch_timer:__init(npc_id, pos) super()
   self.npc_id = npc_id -- запоминаем в таймере id непися
   self.pos    = pos -- запоминаем позицию, куда будем перемещать
end
function go_offline_watch_timer:condition()
   return (not level.object_by_id(self.npc_id)) -- ждём исчезновения клиентского объекта
end
function go_offline_watch_timer:action()
   local s_npc = alife():object(self.npc_id)
   if s_npc then
      s_npc.position = self.pos -- кастуем злое колдунство
      s_npc.force_offline = nil -- отправляем обратно в онлайн
   else
      --log1("Something wrong!") -- такое возможно при удалении объекта
   end
end

--- Возвращает класс защиты надетой на ГГ брони от выброса. В obj передавать db:actor
--- С неписями НЕ работает! Пользуйте armor_type(npc)
function armor_class(obj)
	if obj then
		local armor = obj:get_current_outfit()
		local armorname
		if armor ~= nil then armorname = armor:section() else return 5 end
		if armorname ~= nil then
			if 	string.find(armorname, "scientific_outfit") or
				string.find(armorname, "ecolog_outfit") or
				string.find(armorname, "protection_outfit") or
				string.find(armorname, "militaryspec_outfit") then
				return 1
	     elseif string.find(armorname, "exo") or
				string.find(armorname, "monolit_exoskeleton") then
				return 2
	     elseif string.find(armorname, "outfit_specnaz_m1") or
				string.find(armorname, "specops_outfit") or
				string.find(armorname, "monolit_outfit_m1") or
				string.find(armorname, "svoboda_heavy_outfit") then
				return 3 else return 4
			end
		end
	end
end

local armor_type_npc = {["novice"]=4, ["experienced"]=3, ["veteran"]=2, ["master"]=1}
--- Возвращает класс защиты непися
function armor_type(npc)
	if npc then
		local npc_rank = ranks.get_obj_rank_name(npc)
		if npc_rank ~= nil then
			return (armor_type_npc[npc_rank] or 1)
		end
	end
end

-- Показ типса
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if news_text==nil then return end
	local header = (header or game.translate_string("st_tip"))
	local timeout = (timeout or 0)
	local showtime = (showtime or 5)

	local player = xr_sound.get_safe_sound_object((tips_variable[tostring(sound)] or  tips_variable["pda_tips"]))

	--' Играем дефолтный звук
	player:play(db.actor, timeout, sound_object.s2d)

	local sender = (sender or "default")

	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]

	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)
	return true
end

-- Спавним объекты в инвентарь
function spawn_item_in_inv(section,npc)
	local npc = (npc or db.actor)
--	log1("~~spawn_item_in_inv sect ["..tostring(section).."] npc ["..npc:name().."]")	
	local sobj_abstr = alife():create(section,
			npc:position(),
			npc:level_vertex_id(),
			npc:game_vertex_id(),
			npc:id())
	if sobj_abstr then
		return alife():object(sobj_abstr.id)
	else	
		log1("!!Error spawn_item_in_inv sect ["..tostring(section).."] npc ["..npc:name().."]")	
		return false
	end	
end

-- Спавним патроны в инвентарь
function spawn_ammo_in_inv(section,number,npc)
	local npc = (npc or db.actor)
	-- log1("~~spawn_ammo_in_inv sect ["..tostring(section).."] npc ["..npc:name().."]")	
	if number > 0 then
		local sobj_abstr = se_respawn.create_ammo(section,
				npc:position(),
				npc:level_vertex_id(),
				npc:game_vertex_id(),
				npc:id(),
				number)
		if not sobj_abstr then
			return false
		end
		return alife():object(sobj_abstr.id)
	end
end


-- Удаляем объект из игры
function remove_item(item_to_remove)
	--ASSERT(item_to_remove, "[ogse.remove_item] item is a nil reference!")
	if item_to_remove then
		local sobj = alife():object(item_to_remove:id())
		if sobj then
			alife():release(sobj, true)
			return true
		else
			return false
		end
	end
	return false
end

-- Удаляем объект из игры по имени
function remove_item_by_name(item_to_remove)
	--ASSERT(item_to_remove, "[ogse.remove_item] item is a nil reference!")
	if item_to_remove then
		local sobj = alife():object(item_to_remove)
		if sobj then
			alife():release(sobj, true)
			return true
		else
			return false
		end
	end
	return false
end

-- Выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
	if item~=nil then
	    npc:mark_item_dropped(item)
	end
end


-- Убиваем непися
function make_suicide(npc)
	npc:kill(npc)
end


-- Узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
	local rel = obj:relation(target)
	if rel ~= nil then
		return (rel==game_object.neutral and "neutral" or rel==game_object.friend and "friend" or rel==game_object.enemy and "enemy") or false
	end
end


-- Задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
	ASSERT(relation, "[ogse.set_npc_relation] variable relation == nil!")
	if relation=="neutral" then
		rel=game_object.neutral
	elseif relation=="friend" then
		rel=game_object.friend
	elseif relation=="enemy" then
		rel=game_object.enemy
	else
		return false
	end
	obj:set_relation(rel,target)
	return true
end


-- Узнаем группировку непися, применимо к ГГ
function get_npc_community(npc)
	return npc:community()
end


-- Выставляем группировку непися, можно ГГ
function set_npc_community(npc,community_string)
	--значения для community_string можно узнать в config\creatures\game_relations.ltx
	return npc:set_character_community(community_string, 0, 0)
end


-- Удаляем предмет из инвентаря
function remove_item_from_inventory_by_name( remove_item_name, npc )
  return remove_item_from_inventory( npc:object( remove_item_name ), npc )
end

function remove_item_from_inventory( remove_item, npc )
  if not npc then npc = db.actor end
  if remove_item then
    -- npc:mark_item_dropped(remove_item)
    local sobj = alife():object( remove_item:id() )
    if sobj then
      alife():release( sobj )
			return true
		else
			return false
		end
	end
	return false
end


-- Создаем "ожидатели" для неписей нужно для корректной работы с объектами, созданными внутри скрипта
function create_waiter_for_npc(npc,select_string)
	npc_spawner[npc.id]=select_string
end


-- Очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory( npc )
  npc:iterate_inventory( __del_item, npc )
end

function __del_item( npc, item )
  local section = item:section()
  if section == "bolt" or section == "device_torch" then
    return
  end
  -- npc:mark_item_dropped( item )
  local sobj = alife():object( item:id() )
  if sobj then
    alife():release( sobj )
  end
end


-- Проверка, запущена ли игра
function check_game()
	if level.present() and (db.actor ~= nil) and db.actor:alive() then
		return true
	end
	return false
end

-- Записываем переменную
function save_variable(variable_name, value)
	if main_variable_tbl == nil then
		main_variable_tbl = {}
	end
	main_variable_tbl[variable_name] = value
end

-- Загружаем переменную
function load_variable(variable_name, value_if_not_found)
	if main_variable_tbl ~= nil and main_variable_tbl[variable_name] ~= nil then
		local val = main_variable_tbl[variable_name]
		if val ~= nil then
			return val
		end
	end
	if value_if_not_found ~= nil then
		return value_if_not_found
	end
	return nil
end

-- Удаляем переменную
function del_variable(variable_name)
	if main_variable_tbl[variable_name] then
		main_variable_tbl[variable_name] = nil
	end
end

local sidor_sobj
-- Готовим хранилище Сидорыча
function create_sidor_storage()
	sidor_sobj = alife():story_object(story_ids.Escape_Trader)
end

deadmans_table = {}
-- Формат хранения:
-- [id] = { time_died = time_when_killed, killer = who:id() }

-- Восстанавливаем оперативные переменные из хранилища Сидорыча
function load_main_variable_tbl()
	main_variable_tbl = nil
	if sidor_sobj and sidor_sobj.m_storage then
		local m_storage_parsed = sidor_sobj.m_storage
		local m_storage_unparsed = m_net_utils.parse_custom_data(m_storage_parsed)
		if not m_storage_unparsed.m_storage then
			main_variable_tbl = {}
			deadmans_table = {}
			log1("load_main_variable_tbl: Warning! main_variable_tbl load as empty!")
		else
			main_variable_tbl = m_storage_unparsed.m_storage
			deadmans_table = m_storage_unparsed.bones_pile
			log1("load_main_variable_tbl: INFO: main_variable_tbl load is succesful")
		end
	else
		main_variable_tbl = {}
		deadmans_table = {}
		log1("load_main_variable_tbl: ERROR!: sidor_sobj or sidor_sobj.m_storage is faile!")
		log1("load_main_variable_tbl: Warning! main_variable_tbl load as empty!")
	end
end

-- Сохраняем оперативные переменные в хранилище Сидорыча
function save_main_variable_tbl()
	if sidor_sobj then
		local m_storage_unparsed = {}
		m_storage_unparsed.m_storage = main_variable_tbl
		m_storage_unparsed.bones_pile = deadmans_table
		local m_storage_parsed = m_net_utils.gen_custom_data(m_storage_unparsed)
		sidor_sobj.m_storage = m_storage_parsed
		log1("save_main_variable_tbl: INFO: main_variable_tbl saved in store is succesful")
	else
		log1("save_main_variable_tbl: ERROR!: sidor_sobj is faile!")
	end
end


-- Определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2)
	local pos=npc:position()
	if is_point_inside_interval(pos.x,p1.x,p2.x) and
		is_point_inside_interval(pos.y,p1.y,p2.y) and
		is_point_inside_interval(pos.z,p1.z,p2.z) then
		return true
	else
		return false
	end
end
function is_point_inside_interval(x,p1,p2)
	if p1>p2 then
		p1,p2 = p2,p1
	end

	if x>p1 and x<p2 then
		return true
	else
		return false
	end
end

-- Получаем инвентарное название объекта
function get_inv_name(section)
	return sys_ini:r_string(section,"inv_name")
end

-- Парсинг ини-файла в массив
function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and string.trim(id)~="" and string.trim(id)~=nil then
				tmp[string.trim(id)] = string.trim(value)
			end
		end
	end
	return tmp
end

function add_spot_on_map(obj_id,type,text)
  --возможные типы type смотри в ui\map_spots.xml
  if obj_id then
    if text==nil then text=" " end
    -- Ставим метку на серверный объект чтобы её не пришлось обновлять
    level.map_add_object_spot_ser(obj_id, type, text)
--    save_variable("x_marker_type_"..obj_id, type)
--    save_variable("x_marker_text_"..obj_id, text)
  end
end

function remove_spot_from_map(obj_id,type)
  if obj_id and level.map_has_object_spot(obj_id, type)~= 0 then
    level.map_remove_object_spot(obj_id, type)
--    del_variable("x_marker_type_"..obj_id)
--    del_variable("x_marker_text_"..obj_id)
  end
end
-- вспомогательная функция, создание одного или нескольких объектов в заданной точке
-- назначение: убрать повторный код из функций далее по тексту
local function spawn_single_object_internal(res, spawn_item)
	ASSERT(spawn_item.sec, "[spawn_single_object_internal] section not defined")
	ASSERT(spawn_item.pos, "[spawn_single_object_internal] position not defined, sec = '%s'", spawn_item.sec)
	ASSERT(spawn_item.lvid, "[spawn_single_object_internal] lvid not defined, sec = '%s'", spawn_item.sec)
	ASSERT(spawn_item.gvid, "[spawn_single_object_internal] gvid not defined, sec = '%s'", spawn_item.sec)
	if spawn_item.lvl then
		ASSERT(level_system_name_by_gvid(spawn_item.gvid) == spawn_item.lvl,
			"[spawn_single_object_internal] gvid does not match the level name, sec = '%s', lvl = '%s', gvid = %d",
			spawn_item.sec,
			spawn_item.lvl,
			spawn_item.gvid
			)
	end
	local count = spawn_item.cnt or 1
	ASSERT(not (count > 1 and spawn_item.sid), "[spawn_single_object_internal] cannot assign same sid to multiple objects!, sec = '%s'", spawn_item.sec)
	local sim = alife()
	for i=1,count do
		local sobj_abstract = sim:create(spawn_item.sec, vector():set(unpack(spawn_item.pos)), spawn_item.lvid, spawn_item.gvid)
		-- получаем объект правильнго типа
		local sobj = sim:object(sobj_abstract.id)
		-- на самом деле в этой проверке нет смысла. Ситуации, когда объект создать не удалось, а выполнение продолжилось,
		-- просто не бывает. В этих случаях всегда идёт вылет. Но пусть будет
		ASSERT(sobj, "[spawn_single_object_internal] cannot create object, sec = '%s'", spawn_item.sec)
		if spawn_item.use_ai_location == false or spawn_item.use_ai_location == "false" then
			sobj:used_ai_locations(false)
		elseif spawn_item.use_ai_location == true or spawn_item.use_ai_location == "true" then
			sobj:used_ai_locations(true)
		end
		if spawn_item.sid then
			sim:assign_story_id(sobj.id, spawn_item.sid)
		end
		if spawn_item.angle then
			sobj.angle = vector():set(unpack(spawn_item.angle))
		end
		table.insert(res, sobj)
	end
end
-- спавнит один или несколько одинаковых предметов в заданной точке
-- фактически просто обёртка над spawn_single_object_internal
function spawn_object(spawn_item)
	local res = {}
	spawn_single_object_internal(res, spawn_item)
	return unpack(res)
end
-- спавнит несколько предметов, заданных таблицей
function spawn_objects(spawn_items)
	local res = {}
	for idx,spawn_item in ipairs(spawn_items) do
		spawn_single_object_internal(res, spawn_item)
	end
	return res
end
-- спавнит рандомно один из предметов, заданных таблицей
function spawn_object_rand(spawn_items)
	local spawn_item = spawn_items[math.random(#spawn_items)]
	local res = {}
	spawn_single_object_internal(res, spawn_item)
	return unpack(res)
end

function quest_spawn_ex(section, total, spawn_item)
	local res = {}
	for i=1,total do
		local spawn_item_tmp = table.clone_simple(spawn_item)
		spawn_item_tmp.sec = section
		spawn_single_object_internal(res, spawn_item_tmp)
	end
	return unpack(res)
end

function kill_crow()
	for k, sobj in alife():objects() do
		local crow = level.object_by_id(k)
		if crow and crow:section() == "m_crow" and math.random(0,100)<70 then
			local hit = hit()
			hit.direction = crow:direction()
			hit.impulse = 1000
			hit.draftsman = crow
			hit.power = 1000
			hit.type = hit.strike
			if crow then
				crow:hit(hit)
			end
--			checker_minefield.to_delete[k]=k
		end
	end
end

--TODO: не из-за этой ли функции вороны вылетают из одной точки на земле?
function spawn_crow()
	local lv = db.actor:level_vertex_id()
	local gv = db.actor:game_vertex_id()
	local x_offset = 0
	local z_offset = 0
	local y_offset = 100
	for k=1,20 do
	x_offset = math.random(-100,100)
	z_offset = math.random(-100,100)
		local pos = db.actor:position()
		pos.x = pos.x + x_offset
		pos.y = pos.y + y_offset
		pos.z = pos.z + z_offset
		alife():create("m_crow", pos, lv, gv)
	end
end

--[[function money_in(money)
	dialogs.relocate_money(db.actor, money, "in")
end]]

--[[function money_out(money)
	dialogs.relocate_money(db.actor, money, "out")
end]]

function give_info(info)
	if not has_info(info) then
		db.actor:give_info_portion(info)
	end
end

function has_info(info)
	return db.actor:has_info(info)
end

-- функция создания окна сообщения, которое закроется само через определённое время
function autohiding_msg(txt, delay)
	local dlg = MonologueMsg(txt)
	level.start_stop_menu(dlg, true)
	autohide_dlg_timer(delay, dlg):start()
end

-- окно "монологового" типа. Просто сообщение в рамке.
-- Закрыть можно по ESC. Также можно использовать в комбинации с
-- таймером автозакрытия (см. MonologueMsg и ф-ю autohiding_msg)
class "MonologueMsg" (CUIScriptWnd)

function MonologueMsg:__init(txt) super()
	local xml = CScriptXmlInit()
	local dev = device()
	
	if dev.aspect_ratio > 0.7 then
		xml:ParseFile("ui_ogse_monologue_msg.xml") -- 4^3
	else
		xml:ParseFile("ui_ogse_monologue_msg_16.xml") -- 16^9
	end	
	xml:InitWindow("main", 0, self)
	self.msg = xml:InitStatic("main:msg", self)
	self.msg:SetTextST(txt)
	self.dlg = self -- трюк для предотвращения вылета.
	-- Чтобы не было утечки памяти после закрытия окна надо обнулить эту ссылку
	-- (см. метод OnKeyboard и также метод срабатывания спец. таймера)
end
function MonologueMsg:OnKeyboard(dik, key_act) CUIScriptWnd.OnKeyboard(self,dik,key_act)
	if key_act == ui_events.WINDOW_KEY_PRESSED and dik == DIK_keys.DIK_ESCAPE then
		self:GetHolder():start_stop_menu(self,true)
		self:ClearCallbacks()
		self.dlg = nil -- отпускаем объект для сборщика мусора
	end
	return true
end
-- служебный таймер для автоматического закрытия диалога через заданное время
class "autohide_dlg_timer" (ogse_qt.quick_timer)
function autohide_dlg_timer:__init(delay, dlg) super(delay)
	self.dlg = dlg
end
function autohide_dlg_timer:taction()
	if self.dlg and self.dlg:IsShown() then
		level.start_stop_menu(self.dlg,true)
		self.dlg:ClearCallbacks()
		self.dlg.dlg = nil -- отпускаем объект для сборщика мусора
	end
end

--/* Уменьшения репутации на .. едениц главному герою..
function reputation_down_20(stalker, player)
	db.actor:change_character_reputation(-20)
end

function reputation_down_10(stalker, player)
	db.actor:change_character_reputation(-10)
end

function reputation_up_10(stalker, player)
	db.actor:change_character_reputation(10)
end

function reputation_up_20(stalker, player)
	db.actor:change_character_reputation(20)
end

save_var = ogse_unist.set_value
load_var = ogse_unist.get_value
load_var_safe = ogse_unist.get_value_safe
var_exists = ogse_unist.value_exist
delete_var = ogse_unist.remove_value
save_or_delete_var = ogse_unist.set_or_remove_value

------------------ таймер со счётчиком на экране --------------------------------
class "visual_timer" (ogse_st_mgr.delayed_fun_start)
function visual_timer:__init(name) super(name)
	self._class = script_name()..".visual_timer"
end

function visual_timer:start(...)
	--
	self.on_hud_show_desc = {signal = "on_hud_show", self = self, fun = self.on_hud_show}
	ogse_signals.get_mgr():subscribe(self.on_hud_show_desc)
	local hud = get_hud()
	hud:AddCustomStatic("hud_timer", true)
	return ogse_st_mgr.delayed_fun_start.start(self, ...)
end

function visual_timer:stop()
	local hud = get_hud()
	hud:RemoveCustomStatic("hud_timer")
	--
	ogse_signals.get_mgr():unsubscribe(self.on_hud_show_desc)
	ogse_st_mgr.delayed_fun_start.stop(self)
end

function visual_timer:on_hud_show()
	local hud = get_hud()
	if hud:GetCustomStatic("hud_timer") then
		hud:RemoveCustomStatic("hud_timer")
	end
	hud:AddCustomStatic("hud_timer", true)
end

function visual_timer:condition()
	local dt
	if self._game_termination_time then
		dt = game.CTime(self._game_termination_time):diffSec(game.get_game_time())
	elseif self._residual_time then
		dt =  self._residual_time - self._time_from_loading
	else
		abort("visual_timer:condition: can not update time visual. Time condition is not set.")
	end
	local h = math.floor(dt/3600)
	local m = math.floor(dt/60 - h*60)
	local s = math.floor(dt - h*3600 - m*60)
	local txt = string.format("%02d:%02d:%02d", h, m, s)
	get_hud():GetCustomStatic("hud_timer"):wnd():SetText(txt)
	return false
end

------------------ таймер со счётчиком на экране и дополниельным условием останова -----------------
class "conditional_visual_timer" (visual_timer)
function conditional_visual_timer:__init(name) super(name)
	self._class = script_name()..".conditional_visual_timer"
end

function conditional_visual_timer:init(cond_name, action_name, ...)
	self.cond_name = cond_name
	self.user_condition = loadstring("return "..self.cond_name.."(...)")
	ASSERT(self.user_condition, "conditional_visual_timer:init: can not compile function with the name '"..tostring(self.cond_name).."'")
	return ogse_st_mgr.delayed_fun_start.init(self, action_name, ...)
end

function conditional_visual_timer:condition()
	visual_timer.condition(self) -- всегда возвращает false
	return self.user_condition(unpack(self.fun_params))
end

function conditional_visual_timer:load(packet)
	self.cond_name = packet:r_stringZ()
	self.user_condition = loadstring("return "..self.cond_name.."(...)")
	ASSERT(self.user_condition, "conditional_visual_timer:load: can not compile function with the name '"..tostring(self.cond_name).."'")
	ogse_st_mgr.delayed_fun_start.load(self, packet)
end

function conditional_visual_timer:save(packet)
	packet:w_stringZ(self.cond_name)
	ogse_st_mgr.delayed_fun_start.save(self, packet)
end

----- обёртки для классов таймеров с визуальным счётчиком --------------------------------
-- только по времени
function start_visual_timer(name, delay, fname, ...)
	return visual_timer(name):set_delay(delay):init(fname, ...):start(true)
end

function start_visual_gtimer(name, delay, fname, ...)
	return visual_timer(name):set_gdelay(delay):init(fname, ...):start(true)
end

-- с дополнительным условием останова
function start_conditional_visual_timer(name, delay, cond_name, act_name, ...)
	return conditional_visual_timer(name):set_delay(delay):init(cond_name, act_name, ...):start(true)
end

function start_conditional_visual_gtimer(name, delay, cond_name, act_name, ...)
	return conditional_visual_timer(name):set_gdelay(delay):init(cond_name, act_name, ...):start(true)
end

-- псевдонимы для удобства вызова
start_tmr = ogse_st_mgr.start_timer
start_gtmr = ogse_st_mgr.start_gtimer
get_tmr = ogse_st_mgr.get_timer
tmr_exists = ogse_st_mgr.timer_exists

-- специальный таймер для прокрутки игрового времени. Является основой для более
-- специализированного таймера сна sleep_timer (см. ogse_sleep_mgr.script)
-- использование:
-- ogse.time_rewind_timer(12, 5, 4):start()
-- прокрутить 12 игровых часов за 5 секунд ревльного времени, используя 4 такта
-- ogse.time_rewind_timer(5):start() -- прокрутить 5 часов
class "time_rewind_timer" (ogse_qt.quick_timer)
function time_rewind_timer:__init(game_time_to_rewind, real_time, phases_number) super()
	ASSERT(game_time_to_rewind > 0, "time_rewind_timer:__init: game_time_to_rewind is negative")
	self.normal_time_factor = level.get_time_factor()
	self.start_sleep_time = game.get_game_time()
	self.end_sleep_time = self.start_sleep_time + seconds2ctime(game_time_to_rewind * 3600.0)
	self.real_time = real_time or 3 -- время, за которое прокрутим, по умолчанию 3 секунды
	local ph_num = phases_number or 3 -- количество периодов
	-- на каждом периоде скорость течения времени уменьшается в 10 раз по отношению к предыдущему
	-- таким образом повышается точность выставления времени
	self.real_phase_time = self.real_time / ph_num -- длительность одной фазы
	self:set_phase(ph_num)
end

function time_rewind_timer:set_phase(phase_num)
	self.phase = phase_num
	local current_game_time = game.get_game_time()
	self.phase_begin = current_game_time
	local time_left = self.end_sleep_time:diffSec(current_game_time) -- оставшееся время сна в секундах
	if self.phase == 1 then -- последняя фаза, отдаём под неё всё оставшееся время
		self.phase_end_time = self.end_sleep_time
	else -- обычная фаза, отдаём под неё время 0.9 * <оставшееся время ожидания>
		self.phase_end_time = self.phase_begin + seconds2ctime(time_left*0.9)
	end
	local tf = self.phase_end_time:diffSec(self.phase_begin) / self.real_phase_time
	level.set_time_factor(tf)
end

function time_rewind_timer:condition()
	if game.get_game_time() > self.phase_end_time then
		if self.phase == 1 then return true end
		self:set_phase(self.phase - 1)
	end
	return false
end

function time_rewind_timer:action()
	local s_time_factor = get_float("options","s_time_factor")
	ASSERT(s_time_factor, "time_rewind_timer:action: parameter 's_time_factor' was not found in the section 'options'")
	level.set_time_factor(s_time_factor)
	--level.set_time_factor(self.normal_time_factor)
end