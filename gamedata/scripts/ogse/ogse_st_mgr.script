-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--| ogse_st_mgr.script                                                      |--
--| Serializable Timers Manager                                             |--
--| Malandrinus, OGS Evolution Team, 2012                                   |--
--| version 1.0                                                             |--
-------------------------------------------------------------------------------

-- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º—ã—Ö (—Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º—ã—Ö) —Ç–∞–π–º–µ—Ä–æ–≤ –≤ —Ü–µ–ª–æ–º –ø–æ—Ö–æ–∂–µ
-- –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ "–±—ã—Å—Ç—Ä—ã—Ö" —Ç–∞–π–º–µ—Ä–æ–≤ –∏–∑ –º–æ–¥—É–ª—è
-- ogse_qt.script. –°–æ–∑–¥–∞—ë—Ç—Å—è –æ–±—ä–µ–∫—Ç —Ç–∞–π–º–µ—Ä–∞, –≤ –Ω—ë–º —Å–æ–∑–¥–∞—é—Ç—Å—è –º–µ—Ç–æ–¥—ã
-- —É—Å–ª–æ–≤–∏—è –∏ –¥–µ–π—Å—Ç–≤–∏—è, –æ–Ω –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∏ –¥–∞–ª–µ–µ –∂–∏–≤—ë—Ç —Å–≤–æ–µ–π –∂–∏–∑–Ω—å—é,
-- —Å—Ä–∞–±–∞—Ç—ã–≤–∞—è –ø–æ —É—Å–ª–æ–≤–∏—é –∏ –≤—ã–ø–æ–ª–Ω—è—è –≤ –Ω—É–∂–Ω—ã–π –º–æ–º–µ–Ω—Ç –∑–∞–¥–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.
-- –ü–µ—Ä–≤–æ–µ –æ—Ç–ª–∏—á–∏–µ –æ—Ç quick_timer –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ö –ø—Ä–∏
-- —Å–æ–∑–¥–∞–Ω–∏–∏, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å—é —Å–æ–∑–¥–∞–≤–∞—Ç—å –æ–±—ä–µ–∫—Ç –∫–ª–∞—Å—Å–∞
-- —Ç–∞–π–º–µ—Ä–∞ –∑–∞–Ω–æ–≤–æ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ.  –í—Ç–æ—Ä–æ–µ –æ—Ç–ª–∏—á–∏–µ, –≤ –Ω–∞–ª–∏—á–∏–∏ –º–µ—Ç–æ–¥–æ–≤
-- save/load, –≤ –∫–æ—Ç–æ—Ä—ã—Ö —Ç–∞–π–º–µ—Ä –º–æ–∂–µ—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ª—é–±—ã–µ –¥–∞–Ω–Ω—ã–µ,
-- –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –µ–º—É –¥–ª—è —Ä–∞–±–æ—Ç—ã. –≠—Ç–æ –º–æ–≥—É—Ç –±—ã—Ç—å –∫–∞–∫ –¥–∞–Ω–Ω—ã–µ, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ
-- –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏—è, —Ç–∞–∫ –∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
-- –¥–µ–π—Å—Ç–≤–∏—è.

-- –ü—Ä–∏–º–µ—Ä —Å–æ–∑–¥–∞–Ω–∏—è –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —Ç–∞–π–º–µ—Ä–∞, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ
-- —Ç–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–Ω–û–µ —É—Å–ª–æ–≤–∏–µ:
--
-- class "test_timer" ( ogse_st_mgr.savable_timer )
-- function test_timer:__init() super()
--   -- –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å –∏–º–µ–Ω–µ–º –∫–ª–∞—Å—Å–∞ —Ç–∞–π–º–µ—Ä–∞
--   self.class = script_name() .. ".test_timer"
-- end
-- -- –º–µ—Ç–æ–¥ –¥–ª—è –ø–µ—Ä–≤–∏—á–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏, –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–µ –∏–º—è
-- function test_timer:set_data( s )
--   self.str = s
-- end
-- –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∑–∞–≥—Ä—É–∑–∫–∏/—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
-- function test_timer:load( t )
--   self.str = unpack( t )
-- end
-- function test_timer:save( t, template )
--   table.insert( template, "string" )
--   table.insert( t,        self.str )
--   return template
-- end
-- -- –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–Ω–û–º—É —É—Å–ª–æ–≤–∏—é
-- function test_timer:taction()
--   log1( self.str ) -- —á—Ç–æ-—Ç–æ –¥–µ–ª–∞–µ–º –≤ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è
-- end
--
-- —Å–æ–∑–¥–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞
-- local t = test_timer()
-- t:set_data( "some string" )
-- t:set_delay( 600 ) -- —Å—Ä–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
-- –∏–ª–∏
-- t:set_gdelay( 600 ) -- —Å—Ä–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç –∏–≥—Ä–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
-- –∏–ª–∏
-- t:set_gtime( game.CTime():set( ... ) ) -- —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –∑–∞–¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∏–≥—Ä–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
-- t:start() -- –∑–∞–ø—É—Å—Ç–∏—Ç—å

-- –ü—Ä–∏–º–µ—Ä —Ç–∞–π–º–µ—Ä–∞ —Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º —É—Å–ª–æ–≤–∏–µ–º. –°–ª–µ–¥–∏—Ç –∑–∞ –Ω–µ–∫–∏–º –Ω–µ–ø–∏—Å–µ–º,
-- –∫–æ—Ç–æ—Ä—ã–π –∫–æ–≥–¥–∞-—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–π–¥–µ—Ç –≤ –æ–Ω–ª–∞–π–Ω:
--
-- class "conditional_timer" ( ogse_st_mgr.savable_timer )
-- function conditional_timer:__init( timer_id ) super( timer_id )
--   self.class = script_name() .. ".conditional_timer"
-- end
-- function conditional_timer:init( npc_id )
--   self.npc_id = npc_id
--   return self -- –¥–ª—è –≤—ã–∑–æ–≤–∞ —Ü–µ–ø–æ—á–∫–æ–π
-- end
-- –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∑–∞–≥—Ä—É–∑–∫–∏/—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
-- function conditional_timer:load( t )
--   self.npc_id = unpack( t )
-- end
-- function conditional_timer:save( t, template )
--   table.insert( template, "u16"       )
--   table.insert( t,        self.npc_id )
--   return template
-- end
-- function conditional_timer:condition()
--   self.npc = level.object_by_id( self.npc_id )
--   return self.npc
-- end
-- –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º—É —É—Å–ª–æ–≤–∏—é (–∏–º—è
-- –º–µ—Ç–æ–¥–∞ action, –∞ –Ω–µ taction !)
-- function conditional_timer:action()
--   self.npc:kill( db.actor ) -- —á—Ç–æ-—Ç–æ –¥–µ–ª–∞–µ–º –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏ —á—É–≤–∞–∫–∞
-- end
-- —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∑–∞–ø—É—Å–∫
-- conditional_timer( "my_timer" ):init( 12345 ):start()
-- get_timer( "my_timer" ):stop() -- –ø–µ—Ä–µ–¥—É–º–∞–ª–∏ –∏ –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏


function attach(sm)
  sm:subscribe({ signal = "on_load",   fun = this.on_load   })
  sm:subscribe( {signal = "on_save",   fun = this.on_save   })
  sm:subscribe( {signal = "on_update", fun = this.on_update })
end


-- —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å–æ —Å–ø–∏—Å–∫–æ–º —Ç–∞–π–º–µ—Ä–æ–≤. –ù–ï –ú–ï–ù–Ø–¢–¨!
local root_guid = "{663A0135-0A8F-41D9-91BA-FCCBFD59B146}_root"
-- —É–Ω–∏–∫–∞–ª—å–Ω–∞—è –±–∞–∑–æ–≤–∞—è —á–∞—Å—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ —Ç–∞–π–º–µ—Ä–æ–≤. –ù–ï –ú–ï–ù–Ø–¢–¨!
local storage_guid = "{36881905-5863-4D7C-BB12-0ECAC401FE1A}"
local registry = {} -- —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–∞–π–º–µ—Ä–æ–≤ –≤ –ø–∞–º—è—Ç–∏.


function delete_all_timers()
  for id, timer in pairs( registry ) do
    timer:stop()
  end
end


local function get_free_id()
  for i = 0, 65535 do
    local id = tostring( i )
    if not registry[ id ] then return id end
  end
  abort( "ogse_st_mgr.get_free_id: Can't find free id for timer!" )
end


function get_timer( id )
  local timer = registry[ id ]
  ASSERT(
    timer,
    "ogse_st_mgr.get_timer: timer with id '%s' doesn't exist", id
  )
  return timer
end


function timer_exists( id )
  return registry[ id ] ~= nil
end


-- –∑–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö —Ç–∞–π–º–µ—Ä–æ–≤
function on_load()
  local timers = ogse.load_var_safe( "ogse_st_mgr.timers" )
  if not timers then return end
  local t_cnt = 0
  for _, timer_class in ipairs( timers ) do
    local st = ogse.load_var(
      string.format( "%s.timers.%s", script_name(), timer_class )
    )
    for _, t in ipairs( st ) do
      local timer_id = table.remove( t, 1 )
      local f, msg = loadstring( "return " .. timer_class .. "( ... )" )
      ASSERT( f, msg )
      local timer = f( timer_id )
      timer:_aux_load( t )
      timer.loaded = true
      timer:start()
      t_cnt = t_cnt + 1
    end
    log2(
      "[%s]: %s: %s timers loaded",
      script_name(), timer_class, table.getn( st )
    )
  end
  sort_all_timers()
  log2( "[%s]: %s all timers loaded", script_name(), t_cnt )
end


-- —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤—Å–µ—Ö —Ç–∞–π–º–µ—Ä–æ–≤
function on_save()
  local timers, tclasses = {}, {}
  for _, t in pairs( registry ) do
    if timers[ t.class ] then
      table.insert( timers[ t.class ], t )
    else
      timers[ t.class ] = { t }
      table.insert( tclasses, t.class )
    end
  end
  ogse.save_var(
    "ogse_st_mgr.timers", tclasses, "array_template", { "string" }
  )
  local t_cnt = 0
  for tclass, tlist in pairs( timers ) do
    local st, template = {}, { "string" }
    for i, timer in ipairs( tlist ) do
      local t  = { timer.id }
      table.insert( st, t )
      local types = timer:_aux_save( t )
      if i == 1 then
        for _, typ in ipairs( types ) do
          table.insert( template, typ )
        end
      end
      ASSERT(
        table.getn( t ) == table.getn( template ),
        "unexpected table size: got %s, expected %s",
        table.getn( t ), table.getn( template )
      )
      t_cnt = t_cnt + 1
    end
    ogse.save_var(
      string.format( "%s.timers.%s", script_name(), tclass ),
      st, "array_template", template
    )
    log2(
      "[%s]: %s: %s timers saved", script_name(), tclass, table.getn( st )
    )
  end
  log2( "[%s]: %s all timers saved", script_name(), t_cnt )
end


local g_high_queue = {}
local r_high_queue = {}

function sort_all_timers()
  for _, q in ipairs({ g_high_queue, r_high_queue }) do
    sort_any_timers( q )
  end
end

function register_any_timer( t )
  local q, sort_by
  if t._game_termination_time then
    q       = g_high_queue
    sort_by = t._game_termination_time
  elseif t._residual_time then
    q       = r_high_queue
    sort_by = t._loading_time + t._residual_time * 1000
  else
    abort( "unknown timer type: %s.%s", t.class, t.id )
  end
  local last_t = q[ table.getn( q ) ]
  local new_t  = {
    [ "sort_by" ] = sort_by,
    [ "timer"   ] = t,
  }
  table.insert( q, new_t )
  t._queue = q
  if not t.loaded then
    if last_t and new_t.sort_by >= last_t.sort_by then
      log2(
        "[%s]: %s.%s: skip sort_any_timer", script_name(), t.class, t.id
      )
    else
      sort_any_timers( q )
    end
  end
  registry[ t.id ] = t
end

function unregister_any_timer( t )
  local q = t._queue
  registry[ t.id ] = nil
  local found = false
  for i = 1, table.getn( q ) do
    if rawequal( t, q[ i ].timer ) then
      table.remove( q, i )
      found = true
      break
    end
  end
  ASSERT( found, "can't find requested timer: %s.%s", t.class, t.id )
end

function sort_any_timers( q )
  table.sort( q, function( a, b ) return a.sort_by < b.sort_by end )
end


function on_update()
  process_r_queue( r_high_queue )
  process_g_queue( g_high_queue )
end

function process_g_queue( q )
  while (
    table.getn( q ) > 0
    and q[ 1 ].timer._game_termination_time <= game.get_game_time()
  ) do
    local t = q[ 1 ].timer
    table.remove( q, 1 )
    registry[ t.id ] = nil
    t:taction()
  end
end

function process_r_queue( q )
  while table.getn( q ) > 0 do
    local t = q[ 1 ].timer
    local time_from_loading = 1.0e-3 * ( time_global() - t._loading_time )
    if t._residual_time <= time_from_loading then
      table.remove( q, 1 )
      registry[ t.id ] = nil
      t:taction()
    else
      break
    end
  end
end


-------------------------------------------------------------------------------
--< –±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å —Å–æ—Ö—Ä–∞–Ω—è–µ–º–æ–≥–æ —Ç–∞–π–º–µ—Ä–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–≥–æ —Å–æ–±—ã—Ç–∏—è >
-------------------------------------------------------------------------------

-- –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ç–∞–π–º–µ—Ä–∞ –≤ –±–∞–∑–æ–≤–æ–º –∫–ª–∞—Å—Å–µ
class "savable_timer"
function savable_timer:__init( timer_id )
  self.class  = "error: it is forbidden to create instances of a base savable timer class!"
  self.loaded = false
  self.signal = "on_update"
  if timer_id then
    ASSERT(
      tostring( timer_id ),
      "savable_timer:__init: custom id assigned to timer must be a string or be convertible to a string"
    )
    ASSERT(
      ( not timer_exists( timer_id ) ),
      "savable_timer:__init: timer with the id '%s' already exists!", timer_id
    )
    self.id = tostring( timer_id )
  else
    self.id = get_free_id()
  end
  self.sm = ogse_signals.get_mgr()
end


function savable_timer:_aux_load( t )
  self._high_priority = table.remove( t, 1 )
  -- –∑–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–µ –≤—Ä–µ–º—è —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –ø–æ —à–∫–∞–ª–µ —Ä–µ–∞–ª—å–Ω—ã—Ö –∏ –∏–≥—Ä–æ–≤—ã—Ö
  -- —Å–µ–∫—É–Ω–¥
  local res_time = table.remove( t, 1 )
  if res_time ~= 0 then
    -- —Å—Ç—Ä–æ–≥–æ –Ω—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Ç–∞–π–º–µ—Ä —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–µ–∫—É–Ω–¥ –Ω–µ –∑–∞–¥–∞–Ω
    self:set_delay( res_time )
  end
  -- –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –≤—Ä–µ–º—è —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è
  local end_t = dsh.unpack_time( table.remove( t, 1 ) )
  if end_t ~= game.CTime() then
    self:set_gtime( end_t )
  end
  -- –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –≤—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞
  self._start_time = dsh.unpack_time( table.remove( t, 1 ) )
  -- –∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –µ—Å—Ç—å
  if table.getn( t ) > 0 then
    self:load( t )
  end
end


function savable_timer:_aux_save( t )
  local template = { "bool", "float", "time", "time" }
  table.insert( t, self._high_priority )
  -- —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –ø–æ —à–∫–∞–ª–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∏ –∏–≥—Ä–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
  -- –≤–∫–ª—é—á–µ–Ω–æ –≤ —Å–æ—Å—Ç–∞–≤ –∑–∞–≥–æ–ª–æ–≤–∫–∞ —Ç–∞–π–º–µ—Ä–∞.
  -- —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –¥–æ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –ø–æ —à–∫–∞–ª–µ —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–µ–∫—É–Ω–¥
  if self._residual_time then
    -- –≤—ã—á–∏—Å–ª—è–µ–º –∏ –ø–∏—à–µ–º –Ω–æ–≤–æ–µ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –¥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Ä–µ–º—è
    local time_from_loading = 1.0e-3 * ( time_global() - self._loading_time )
    local delay = self._residual_time - time_from_loading
    -- ASSERT( delay > 0, "wrong delay = %s: %s.%s", delay, self.class, self.id )
    if delay > 0 then
      table.insert( t, delay )
    else
      log2(
        "[%s]: saving wrong delay = %s: %s.%s",
        script_name(), delay, self.class, self.id
      )
      table.insert( t, -1 )
    end
  else
    -- —Å—Ç—Ä–æ–≥–æ –Ω—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ–∑–Ω–∞—á–∞—Ç—å, —á—Ç–æ —Ç–∞–π–º–µ—Ä —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–µ–∫—É–Ω–¥ –Ω–µ
    -- –∑–∞–¥–∞–Ω
    table.insert( t, 0 )
  end
  -- —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏–≥—Ä–æ–≤–æ–µ –≤—Ä–µ–º—è —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è
  if self._game_termination_time then
    table.insert( t, { self._game_termination_time:get() } )
  else
    table.insert( t, { game.CTime():get() } )
  end
  -- —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞
  table.insert( t, { self._start_time:get() } )
  -- —Ç–µ–ø–µ—Ä—å —Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –µ—Å—Ç—å
  return self:save( t, template )
end


-- –∑–∞–¥–∞—Ç—å —Ç–æ—á–Ω–æ–µ –≤—Ä–µ–º—è —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –≤ —Ç–µ—Ä–º–∏–Ω–∞—Ö –∏–≥—Ä–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
function savable_timer:set_gtime( t ) -- –∞—Ä–≥—É–º–µ–Ω—Ç - –æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞ game.CTime
  self._game_termination_time = game.CTime( t )
  return self
end


function savable_timer:get_start_time()
  return game.CTime( self._start_time )
end


function savable_timer:get_end_time()
  ASSERT(
    self._game_termination_time,
    "savable_timer:get_end_time: termination time is not defined!"
  )
  return game.CTime( self._game_termination_time )
end


function savable_timer:set_gdelayDHMS( d, h, m, s )
  local delay = d * 24 * 3600 + h * 3600 + m * 60 + s
  self:set_gdelay( delay )
  return self
end


function savable_timer:set_HMS_of_day( h, m, s )
  local pt      = { game.get_game_time():get() }
  local now     = pt[ 4 ] * 3600 + pt[ 5 ] * 60 + pt[ 6 ] + pt[ 7 ] / 1000
  local seconds = h * 3600 + m * 60 + s
  if now > seconds then
    seconds = ( 86400 - now ) + seconds
  else
    seconds = seconds - now
  end
  self:set_gdelay( seconds )
  return self
end


-- –∑–∞–¥–∞—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –æ—Ç —Ç–µ–∫—É—à–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö –∏–≥—Ä–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
-- –∞—Ä–≥—É–º–µ–Ω—Ç - –∑–∞–¥–µ—Ä–∂–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö, —Ç–∏–ø float
-- ( –¥—Ä–æ–±–Ω–∞—è —á–∞—Å—Ç—å –∑–∞–¥–∞—ë—Ç –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã )
function savable_timer:set_gdelay( delay )
  local s, ms = math.modf( delay )
  local t = game.CTime()
  t:setHMSms( 0, 0, s, ms * 1000 )
  self._game_termination_time = game.CTime( game.get_game_time() + t )
  return self
end


-- –∑–∞–¥–∞—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –æ—Ç —Ç–µ–∫—É—à–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö —Ä–µ–∞–ª—å–Ω–æ–≥–æ
-- –≤—Ä–µ–º–µ–Ω–∏
-- –∞—Ä–≥—É–º–µ–Ω—Ç - –∑–∞–¥–µ—Ä–∂–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö, —Ç–∏–ø float
function savable_timer:set_delay( delay )
  self._residual_time = delay
  self._loading_time = time_global()
  return self
end


function savable_timer:set_delayDHMS( d, h, m, s )
  local delay = d * 24 * 3600 + h * 3600 + m * 60 + s
  self:set_delay( delay )
  return self
end


-- –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç–∞–π–º–µ—Ä
function savable_timer:start()
  self._start_time     = self._start_time or game.get_game_time()
  self._high_priority  = false
  self._cond_slot_desc = {
    signal = self.signal, self = self, fun = self._aux_cond,
    script_name = ( self.script_name or self.class ),
  }
  self.sm:subscribe( self._cond_slot_desc )
  registry[ self.id ] = self
  return self
end


-- –æ—Å—Ç–∞–Ω–æ–≤ —Ç–∞–π–º–µ—Ä–∞
function savable_timer:stop()
  self.sm:unsubscribe( self._cond_slot_desc )
  self._cond_slot_desc = nil
  registry[ self.id ]  = nil
end


-- –º–µ—Ç–æ–¥ –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–∞–π–º–µ—Ä–æ–º
function savable_timer:_aux_cond( ... )
  if self._game_termination_time then
    -- –µ—Å–ª–∏ —Å—Ä–∞–±–æ—Ç–∞–ª —Ç–∞–π–º–∞—É—Ç –ø–æ –∏–≥—Ä–æ–≤–æ–º—É –≤—Ä–µ–º–µ–Ω–∏
    if self._game_termination_time <= game.get_game_time() then
      self:stop()           -- –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
      self:taction( ... )   -- –≤—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —Ç–∞–π–º–∞—É—Ç—É
    end
  elseif self._residual_time then -- —É –Ω–∞—Å —Ç–∞–π–º–∞—É—Ç –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    local time_from_loading = 1.0e-3 * ( time_global() - self._loading_time )
    if self._residual_time <= time_from_loading then -- –∏ –æ–Ω —Å—Ä–∞–±–æ—Ç–∞–ª
      self:stop()               -- –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
      self:taction( ... )       -- –≤—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —Ç–∞–π–º–∞—É—Ç—É
    else                        -- –∏–Ω–∞—á–µ –∑–∞—Å—ã–ø–∞–µ–º –Ω–∞ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è
      self.sm:reschedule( ( self._residual_time - time_from_loading ) * 1000 )
    end
  elseif self:condition( ... ) then -- –µ—Å–ª–∏ —Å—Ä–∞–±–æ—Ç–∞–ª–æ —É—Å–ª–æ–≤–∏–µ
    self:stop()
    self:action( ... )          -- –≤—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —É—Å–ª–æ–≤–∏—è
  end
end


-- —É—Å–ª–æ–≤–∏–µ-–∑–∞–≥–ª—É—à–∫–∞ –Ω–∞ —Å–ª—É—á–∞–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–æ–ª—å–∫–æ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
function savable_timer:condition()
  return false
end


-- –ø—É—Å—Ç—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –≤ –±–∞–∑–æ–≤–æ–º –∫–ª–∞—Å—Å–µ. –ù—É–∂–Ω—ã –¥–ª—è —Ç–æ–≥–æ —Å–ª—É—á–∞—è, –∫–æ–≥–¥–∞ –Ω–µ
-- –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ —É–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–Ω–æ–º –∫–ª–∞—Å—Å–µ
function savable_timer:action()  end
function savable_timer:taction() end


-- –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
function savable_timer:load( t ) end
function savable_timer:save( t, template ) return template end


--------------------------------------------------------------------------------
--| –û–±—ë—Ä—Ç–∫–∞ –¥–ª—è —É–ø—Ä–æ—â—ë–Ω–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ —Ç–∞–π–º–µ—Ä–∞
--| –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Å—Ç–æ–π —Ç–∞–π–º–µ—Ä —Å –≤—Ä–µ–º–µ–Ω–Ω–û–π –∑–∞–¥–µ—Ä–∂–∫–æ–π,
--| –∫–æ—Ç–æ—Ä—ã–π –∑–∞–ø—É—Å–∫–∞–µ—Ç –∑–∞–¥–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é, –ø–µ—Ä–µ–¥–∞–≤–∞—è –µ—ë –∑–∞–¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
--------------------------------------------------------------------------------
class "delayed_fun_start" ( savable_timer )
function delayed_fun_start:__init( name ) super( name )
  self.class = "ogse_st_mgr.delayed_fun_start"
end

function delayed_fun_start:init( action_name, ... )
  self.action_name = action_name
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "delayed_fun_start:init: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
  self.fun_params = { ... }
  return self
end

function delayed_fun_start:load( t )
  self.action_name, self.fun_params = unpack( t )
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "delayed_fun_start:load: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
end

function delayed_fun_start:save( t, template )
  for _, typ in ipairs({ "string", { "array" } }) do
    table.insert( template, typ )
  end
  table.insert( t, self.action_name )
  table.insert( t, self.fun_params  )
  return template
end

function delayed_fun_start:start()
  if self._residual_time then
    self.script_name = self.action_name
    savable_timer.start( self )
  else
    self._start_time    = self._start_time or game.get_game_time()
    self._high_priority = false
    register_any_timer( self )
  end
  return self
end

function delayed_fun_start:stop()
  if self._cond_slot_desc then
    savable_timer.stop( self )
  else
    unregister_any_timer( self )
  end
end

function delayed_fun_start:condition()
  return false
end

function delayed_fun_start:taction()
  self.user_action( unpack( self.fun_params ) )
end


function start_timer( name, delay, fname, ... )
  return delayed_fun_start( name )
    :set_delay( delay )
    :init( fname, ... )
    :start()
end

function start_gtimer( name, delay, fname, ... )
  return delayed_fun_start( name )
    :set_gdelay( delay )
    :init( fname, ... )
    :start()
end


class "delayed_on_signal" ( savable_timer )
function delayed_on_signal:__init( name ) super( name )
  self.class = "ogse_st_mgr.delayed_on_signal"
end

function delayed_on_signal:init( signal, action_name, ... )
  self.signal      = signal
  self.action_name = action_name
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "delayed_on_signal:init: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
  self.fun_params = { ... }
  return self
end

function delayed_on_signal:load( t )
  self.signal, self.action_name, self.fun_params = unpack( t )
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "delayed_on_signal:load: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
end

function delayed_on_signal:save( t, template )
  for _, typ in ipairs({ "string", "string", { "array" } }) do
    table.insert( template, typ )
  end
  table.insert( t, self.signal      )
  table.insert( t, self.action_name )
  table.insert( t, self.fun_params  )
  return template
end

function delayed_on_signal:start()
  self.script_name = self.action_name
  return savable_timer.start( self )
end

function delayed_on_signal:condition()
  return true
end

function delayed_on_signal:action( ... )
  self.user_action( ..., unpack( self.fun_params ) )
end


function start_on_signal( name, signal, fname, ... )
  return delayed_on_signal( name )
    :init( signal, fname, ... )
    :start()
end

--==============================[“‡ÈÏÂ ÒÓ Ò˜∏Ú˜ËÍÓÏ Ì‡ ˝Í‡ÌÂ]=================================
class "visual_timer" (delayed_fun_start)
function visual_timer:__init(name) super(name)
	self.class = script_name()..".visual_timer"
end
function visual_timer:start(...)
	self.on_hud_show_desc = {signal = "on_hud_show", self = self, fun = self.on_hud_show}
	self.sm:subscribe(self.on_hud_show_desc)
	local hud = get_hud()
	hud:AddCustomStatic("hud_timer", true)

	self.script_name = self.action_name

	return savable_timer.start(self, ...)
end
function visual_timer:stop()
	self.sm:unsubscribe(self.on_hud_show_desc)
	self.on_hud_show_desc = nil --KRodin: ÌÂÓ·ıÓ‰ËÏÓ! ŒÚÔÛÒÍ‡ÂÏ Ó·˙ÂÍÚ ‰Îˇ Ò·Ó˘ËÍ‡ ÏÛÒÓ‡.
	local hud = get_hud()
	hud:RemoveCustomStatic("hud_timer")

	savable_timer.stop(self)
end
function visual_timer:on_hud_show()
	local hud = get_hud()
	if hud:GetCustomStatic("hud_timer") then
		hud:RemoveCustomStatic("hud_timer")
	end
	hud:AddCustomStatic("hud_timer", true)
end
function visual_timer:_aux_cond()
	savable_timer._aux_cond(self)
end
function visual_timer:condition()
	local dt
	if self._game_termination_time then --»„Ó‚ÓÂ ‚ÂÏˇ
		dt = game.CTime(self._game_termination_time):diffSec(game.get_game_time())
		self.sm:reschedule( 1000 / game_time_factor ) --ÕÂÚ ÒÏ˚ÒÎ‡ ‡Ô‰ÂÈÚËÚ¸ Ú‡ÈÏÂ ˜‡˘Â ‡Á‡ ‚ ÒÂÍÛÌ‰Û.
	elseif self._residual_time then
		dt = self._residual_time - self._time_from_loading
		self.sm:reschedule( 1000 ) --ÕÂÚ ÒÏ˚ÒÎ‡ ‡Ô‰ÂÈÚËÚ¸ Ú‡ÈÏÂ ˜‡˘Â ‡Á‡ ‚ ÒÂÍÛÌ‰Û.
	else
		abort("visual_timer:condition: can not update time visual. Time condition is not set.")
	end
	local h = math.floor(dt/3600)
	local m = math.floor(dt/60 - h*60)
	local s = math.floor(dt - h*3600 - m*60)
	local txt = string.format("%02d:%02d:%02d", h, m, s)
	get_hud():GetCustomStatic("hud_timer"):wnd():SetText(txt)
	return false
end

-------------[Œ·∏ÚÍË ‰Îˇ ÛÔÓ˘∏ÌÌÓ„Ó Á‡ÔÛÒÍ‡]-----------
function start_visual_timer(name, delay, fname, ...)
	return visual_timer(name):set_delay(delay):init(fname, ...):start(true)
end
function start_visual_gtimer(name, delay, fname, ...)
	return visual_timer(name):set_gdelay(delay):init(fname, ...):start(true)
end
---------------------------------------------------------
--==============================================================================================

--=============[“‡ÈÏÂ ÒÓ Ò˜∏Ú˜ËÍÓÏ Ì‡ ˝Í‡ÌÂ Ë ‰ÓÔÓÎÌËÚÂÎ¸Ì˚Ï ÛÒÎÓ‚ËÂÏ ÓÒÚ‡ÌÓ‚‡]===============
class "conditional_visual_timer" (visual_timer)
function conditional_visual_timer:__init(name) super(name)
	self.class = script_name()..".conditional_visual_timer"
end
function conditional_visual_timer:init(cond_name, action_name, ...)
	self.cond_name = cond_name
	self.user_condition = loadstring("return "..self.cond_name.."(...)")
	ASSERT(self.user_condition, "conditional_visual_timer:init: can not compile function with the name [%s]", self.cond_name or "")

	return visual_timer.init(self, action_name, ...)
end
function conditional_visual_timer:condition()
	visual_timer.condition(self) -- ‚ÒÂ„‰‡ ‚ÓÁ‚‡˘‡ÂÚ false

	return self.user_condition(unpack(self.fun_params))
end
function conditional_visual_timer:load(t)
	self.cond_name = table.remove( t, 1 )
	self.user_condition = loadstring("return "..self.cond_name.."(...)")
	ASSERT(self.user_condition, "conditional_visual_timer:load: can not compile function with the name [%s]", self.cond_name or "")

	visual_timer.load(self, t)
end
function conditional_visual_timer:save( t, template )
	table.insert( template, "string" )
	table.insert( t, self.cond_name )

	return visual_timer.save(self, t, template)
end
function conditional_visual_timer:action() end --Õ‡ ‚ÒˇÍËÈ ÒÎÛ˜‡È, ˜ÚÓ·˚ ÚÛÚ „‡‡ÌÚËÓ‚‡ÌÓ ÌË˜Â„Ó ÌÂ ‚˚ÔÓÎÌˇÎÓÒ¸.

-------------[Œ·∏ÚÍË ‰Îˇ ÛÔÓ˘∏ÌÌÓ„Ó Á‡ÔÛÒÍ‡]-----------
function start_conditional_visual_timer(name, --»Ïˇ Ú‡ÈÏÂ‡. ≈ÒÎË nil - ·Û‰ÂÚ Ò„ÂÌÂËÓ‚‡ÌÓ ‡‚ÚÓÏ‡ÚË˜ÂÒÍË.
										delay, --¬ÂÏˇ ‰Ó Ò‡·‡Ú˚‚‡ÌËˇ (‚ ÒÂÍÛÌ‰‡ı)
										cond_name, --»Ïˇ ÙÛÌÍˆËË - ÛÒÎÓ‚Ëˇ ‰Îˇ ÓÒÚ‡ÌÓ‚ÍË Ú‡ÈÏÂ‡. œËÏÂ: script_name()..".fix_restrictors" ‘ÛÌÍˆËˇ ·Û‰ÂÚ Á‡ÔÛÒÍ‡Ú¸Òˇ Ì‡ Í‡Ê‰ÓÏ ‡Ô‰ÂÈÚÂ Ò ‡„ÛÏÂÌÚ‡ÏË {...} ≈ÒÎË ‚ÂÌ∏Ú true - Ú‡ÈÏÂ ÓÒÚ‡ÌÓ‚ËÚÒˇ.
										act_name, --»Ïˇ ÙÛÌÍˆËË, ÍÓÚÓ‡ˇ Á‡ÔÛÒÚËÚÒˇ ÔË Ò‡·‡Ú˚‚‡ÌËË Ú‡ÈÏÂ‡. «‡ÔÛÒÍ‡ÂÚÒˇ Ò ‡„ÛÏÂÌÚ‡ÏË {...} œËÏÂ: script_name()..".fix_restrictors"
										... --¿„ÛÏÂÌÚ˚ ‰Îˇ ÙÛÌÍˆËÈ cond_name Ë act_name. ÃÓ„ÛÚ ·˚Ú¸ ÚËÔ‡ string, number, boolean. ¿ ÏÓÊÌÓ Ë ‚ÓÓ·˘Â ·ÂÁ ‡„ÛÏÂÌÚÓ‚ ‚˚Á˚‚‡Ú¸.
										)
	return conditional_visual_timer(name):set_delay(delay):init(cond_name, act_name, ...):start(true)
end
function start_conditional_visual_gtimer(name, delay, cond_name, act_name, ...)
	return conditional_visual_timer(name):set_gdelay(delay):init(cond_name, act_name, ...):start(true)
end
---------------------------------------------------------
--==============================================================================================
