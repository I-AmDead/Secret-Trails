local anom_prefix = "amk_zone_"
local exclusive_chance = 5


local anoms_sections = {
zharka_static = {"zharka_static",{shtype=1,v1={1,0,0},v2={0,5,0},v3={0,0,1},offset={0,0,0}}},
witches_galantine = {"witches_galantine",{shtype=0,radius=4,center={0,0,0}}},
buzz = {"buzz",{shtype=0,radius=1.5,center={0,0,0}}},
mincer = {"mincer",{shtype=0,radius=4,center={0,0,0}}},
mosquito_bald = {"mosquito_bald",{shtype=0,radius=3,center={0,0,0}}}
}

local level_number={
  l01_escape = 1,
  l02_garbage = 2,
  l03_agroprom = 3,
  l03u_agr_underground=4,
  l04_darkvalley=5,
  l04u_labx18=6,
  l05_bar=7,
  l06_rostok=8,
  l07_military=9,
  l08_yantar=10,
  l08u_brainlab=11,
  l10_radar=12,
  l10u_bunker=13,
  l12_stancia=14,
  l12_stancia_2=15,
  l12u_control_monolith=16,
  l12u_sarcofag=17,
  total=17 -- Общее количество
}

-- Здесь перечислены все интервалы game_vertex для каждого
-- уровня. Можно не запуская игру смотреть, на каком уровне спавнится
-- объект
local game_vertexes = {
  l01_escape            = {    0, 251  },
  l02_garbage           = {  252, 415  },
  l03_agroprom          = {  416, 702  },
  l03u_agr_underground  = {  703, 810  },
  l04_darkvalley        = {  811, 1108 },
  l04u_labx18           = { 1109, 1167 },
  l05_bar               = { 1168, 1307 },
  l06_rostok            = { 1308, 1437 },
  l08_yantar            = { 1438, 1528 },
  l08u_brainlab         = { 1529, 1544 },
  l07_military          = { 1545, 1861 },
  l10_radar             = { 1862, 2116 },
  l12_stancia           = { 2273, 2401 },
  l12u_sarcofag         = { 2402, 2466 },
  l12u_control_monolith = { 2467, 2516 },
  l12_stancia_2         = { 2517, 2660 },
  l10u_bunker           = { 2661, 2791 },
}

-- кол-во левел вертексов на локации
level_vertexes = {
  l01_escape            =  595499,
  l02_garbage           =  382663,
  l03_agroprom          =  437421,
  l03u_agr_underground  =    4932,
  l04_darkvalley        =  390125,
  l04u_labx18           =    7581,
  l05_bar               =   99539,
  l06_rostok            =   67713,
  l07_military          =  418268,
  l08_yantar            =  141471,
  l08u_brainlab         =    8008,
  l10_radar             =  227189,
  l10u_bunker           =    8821,

  l12_stancia           =  477923,
  l12_stancia_2         =  264577,
  l12u_control_monolith =    3982,
  l12u_sarcofag         =   10672,
}

level_anoms = {
  l01_escape = {
    100,150,1000,
{
mosquito_bald = 60 ,
mincer = 30 ,
witches_galantine = 10
    },
  },
  l02_garbage = {
    80,100,800,
{
mosquito_bald=25 ,
mincer=50 ,
witches_galantine=25
    },
  },
  l03_agroprom = {
50,90,800,
{
mosquito_bald=40 ,
mincer=20 ,
witches_galantine=20 ,
buzz=20
    },
  },
  l04_darkvalley = {
130,170,1000,
{
mincer=15, 
mosquito_bald=15 ,
witches_galantine=20 ,
buzz=20 ,
zharka_static=30
}
},
  l05_bar = {
5,20,300,
{
mosquito_bald=60 ,
mincer=30 ,
witches_galantine=10
}
},
  l06_rostok = {
5,20,300,
{
mincer=10 ,
mosquito_bald=10 ,
witches_galantine=60,
zharka_static=20
}
},
  l08_yantar = {
20,40,400,
{
mosquito_bald=30,
mincer= 20, 
witches_galantine=20,
buzz=20 ,
zharka_static=10
}
},
  l07_military = {
90,110,1000,
{
mincer=20 ,
mosquito_bald=40 ,
witches_galantine=20,
zharka_static=20
}
},
  l10_radar = {
90,100,1000,
{
mincer=15,
mosquito_bald=30,
witches_galantine=30 ,
buzz=10 ,
zharka_static=15
}
},
  l12_stancia = {
50,60,700,
    {
mincer=15 ,
mosquito_bald=20 ,
witches_galantine=15,
buzz=20 ,
zharka_static=30
    }
  },
}

local anom_suffixes = {
	_weak = 20,
	_average = 50,
	_strong = 30
}

local on_anoms_per_level={}

local anti_spawn_zones = {}

local xmin,xmax,ymin,ymax = 10000,-10000,10000,-10000
local dx,dy
local initialized=false
local prtime=0
local anoms_off_per_hour=1

-------------------------------------------

function init()
	amk.mylog("amk_anoms.init begin")
  local lname = level.name()

	local sini = ini_file("scripts\\amk\\anoms\\anoms.ltx")
	
	if sini:section_exist(lname) then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count(lname)-1 do
			result, id, value = sini:r_line(lname,a,"","")
			if id~=nil and amk.trim(id)~="" and amk.trim(id)~=nil then
				local s = amk.str_explode(",", id, true)
				if s[1]==nil or s[2]==nil or s[3]==nil or s[4]==nil then abort("amk_anoms:init() - error while parsing safe zones for "..lname.." at section's line #"..(a+1)) end
				table.insert(anti_spawn_zones,{vector():set(tonumber(s[1]),tonumber(s[2]),tonumber(s[3])),tonumber(s[4])})
			end
		end
	end

	collect_info()
	
	initialized=true
	amk.mylog("amk_anoms.init end")
end

function collect_info()
	local lname=level.name()
	on_anoms_per_level={}
	local on_anoms,off_anoms=0,0
	for i=0,65534 do
		local sobj = alife():object(i)
		if sobj then
			if sobj:clsid()>172 and sobj:clsid()<180 then
				local map = alife():level_name(game_graph():vertex(sobj.m_game_vertex_id):level_id())
				if not check_exclusion(sobj,map) then
					local status=get_anomaly_status(sobj)
					if status=="" or status=="del" then
					  -- удаляем помеченные аномалии, и несюжетные стандартные
						alife():release(sobj,true)
					elseif status=="on" then
						if on_anoms_per_level[map]==nil then
							on_anoms_per_level[map]={}
						end
						table.insert(on_anoms_per_level[map],i)
					end
					if map==lname then
						if status=="on" then
							on_anoms=on_anoms+1
						elseif status=="off" then
							off_anoms=off_anoms+1
						end -- status
					end -- level
				end -- exclusiion 
			end
		end
	end
	
--если нет ни офф ни он - генерим два набора
--если есть офф, нет он - ничего не делаем (выброс)
--если есть он, нет офф - генерим офф.
--если есть он и офф - ничего не делаем (уже всё сгенерили)	
	if on_anoms==0 and off_anoms==0 then
		-- незаполненный уровень
		generate_anoms("on")
		generate_anoms("off")
	elseif on_anoms>0 and off_anoms==0 then
		generate_anoms("off")
	elseif on_anoms==0 and off_anoms>0 then
		-- выброс
	else
		-- all is ok
	end
end

-- Создаёт набор аномалий на уровне со статусом status
function generate_anoms(status)
	local lname=level.name()
	local v=level_anoms[lname]
	if v then
		local cnt, mxx = 0,math.random(v[1],v[2])
		while cnt<mxx do
			if generate_anomaly(status) then cnt = cnt+1 end
		end
	end
end

function check_coordinates(pos)
	local lname=level.name()
	for k,v in pairs(anti_spawn_zones) do
		if pos:distance_to(v[1])<=v[2] then 
			return false 
		end
	end
	
	local hides=amk_hideouts.hide[lname]
	local tmp
	if hides then
		for i,o in ipairs(hides) do
			if o.zone then
				for j,v in ipairs(o.zone) do
					if v.p3 then
						tmp=amk.check_npc_in_box(pos,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
					else
						tmp=amk.check_npc_in_box(pos,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
					end
					if tmp==true then return false end
				end
			end
		end
	end
	
	return true
end

function generate_anomaly(status)
	local lname=level.name()
	if level_vertexes[lname] == 0 then return nil end
	local gvn,gvx,lvx = game_vertexes[lname][1], game_vertexes[lname][2], level_vertexes[lname]

	local new_lv=math.random(1,lvx)
	
	local pos = level.vertex_position(new_lv)
	if not check_coordinates(pos) then
		return false
	end
	
	local new_gv = 0
	local min_dist = 100000
	--подбираем геймвертекс
	for a = gvn, gvx do
		g1 = game_graph():vertex(a):game_point()
		if g1:distance_to(pos)<min_dist then
			min_dist = g1:distance_to(pos)
			new_gv = a
		end
	end
	
	return spawn_rand_anom(pos,new_gv,new_lv,status)
end

function spawn_anomaly(section, pos, gv, lv, shape, status)
	local sobj
	sobj = amk.spawn_item(section, pos, gv, lv)
	if sobj then
		local tbl=amk.get_anomaly_data(sobj)
		tbl.shapes=shape
		tbl.custom=modify_anomaly_custom_data(tbl.custom,status)
		amk.set_anomaly_data(tbl, sobj)
	end
	return sobj
end

function spawn_rand_anom(pos,gv,lv,status)
	local lname=level.name()
	local shapes,shape1={},{}
	local section
	section = "zone_ice"
	if exclusive_chance>math.random()*100 then
		shape1={shtype=0,radius=4,center={0,0,0}}
	else
		local rnd=math.random()*100
		local suffix=''
		for k,v in pairs(anom_suffixes) do
			if rnd<=v then 
				suffix=k 
				break
			end
			rnd=rnd-v
		end
		rnd=math.random()*100
		for k,v in pairs(level_anoms[lname][4]) do
			if rnd<=v then 
				section=anoms_sections[k]
				break
			end
			rnd=rnd-v
		end

		shape1=section[2]
		section=anom_prefix..section[1]..suffix
	end
	
	shapes[1]={}
	shapes[1].shtype=shape1.shtype
	if shape1.shtype == 0 then
		shapes[1].radius = shape1.radius
		shapes[1].center = vector():set(shape1.center[1],shape1.center[2],shape1.center[3])
	else
		shapes[1].v1 = vector():set(shape1.v1[1],shape1.v1[2],shape1.v1[3])
		shapes[1].v2 = vector():set(shape1.v2[1],shape1.v2[2],shape1.v2[3])
		shapes[1].v3 = vector():set(shape1.v3[1],shape1.v3[2],shape1.v3[3])
		shapes[1].offset = vector():set(shape1.offset[1],shape1.offset[2],shape1.offset[3])
	end
	
	return spawn_anomaly(section,pos,gv,lv,shapes,status)
end

function set_anomaly_status(sobj, status)
	local anom_id=sobj.id
	if status=="del" then
		amk.mylog("Disabling "..sobj:name())
	end
	local tbl = amk.get_anomaly_data(sobj)
	tbl.custom=modify_anomaly_custom_data(tbl.custom,status)
	amk.set_anomaly_data(tbl, sobj)
	set_online_anomaly_status(anom_id, status)
end

-- Возвражает изменённую cd, c установленным статусом status
function modify_anomaly_custom_data(cd,status)
	cd = amk.parse_custom_data(cd)
	if not cd then cd={} end
	if not cd.dyn_anom then cd.dyn_anom={} end
	cd.dyn_anom.status = status
	return amk.gen_custom_data(cd)
end

function set_online_anomaly_status(obj_id,status)
	local obj = level.object_by_id(obj_id)
	if obj then
		if status=="off" or status=="del" then
			amk.mylog("Disabling online "..obj:name())
			obj:disable_anomaly()
			amk_anoms.remove_anomaly(obj_id)
			amk_anoms.restrictor_deleted(obj_id,obj:name())
		else
			obj:enable_anomaly()
			local sobj = alife():object(obj_id)
			amk_anoms.add_anomaly(obj_id,sobj.position,sobj.radius)
		end
	end
end

function get_anomaly_status(sobj)
	local tbl = amk.get_anomaly_data(sobj)
	local cd = tbl.custom
	cd = amk.parse_custom_data(cd)
	if not cd.dyn_anom then return "" end
	if not cd.dyn_anom.status then return "" end
	return cd.dyn_anom.status
end

blow_out_turn_off_anomalies=false

function update()
	if initialized==false then return end
	

end

-- Включенные аномалии помечаются на удаление. На всех уровнях.
function turn_off_all()
	for i=0,65534 do
		local sobj = alife():object(i)
		if sobj then
			if sobj:clsid()>172 and sobj:clsid()<180 then
				local map = alife():level_name(game_graph():vertex(sobj.m_game_vertex_id):level_id())
				if not check_exclusion(sobj,map) then
					local status=get_anomaly_status(sobj)
					if status=="on" then
						set_anomaly_status(sobj,"del")
					end
				end
			end
		end
	end
end




function pre_blow_off()
	turn_off_all()
end

-- Выключенные аномалии включаются. На всех уровнях.
function after_blow_on()
	for i=0,65534 do
		local sobj = alife():object(i)
		if sobj then
			if sobj:clsid()>172 and sobj:clsid()<180 then
				local map = alife():level_name(game_graph():vertex(sobj.m_game_vertex_id):level_id())
				if not check_exclusion(sobj,map) then
					local status=get_anomaly_status(sobj)
					if status=="off" then
						set_anomaly_status(sobj,"on")
					end
				end
			end
		end
	end
end

function check_exclusion(obj,map)
	if string.find(obj:name(),"amk_") then return false end
	if level_vertexes[map]==nil or level_vertexes[map]==0 then
		return true
	end
	return 	string.find(obj:name(),"rostok_zone_zharka_static") or
					string.find(obj:name(),"tutorial") or 
					string.find(obj:name(),"esc_zone_mincer_strong") or
					string.find(obj:name(),"esc_zone_witches") or
					string.find(obj:name(),"rostok_zone_witches")
end

--[[
ТЗ на систему управления in рестрикторами
1. Для NPC изменения рестрикторов должны производится только в эшкенах или при reset_scheme
2. Удаление объекта рестриктора или отключение аномалии должно приводить к снятию рестриктора со всех NPC и зверушек
3. Функция снятия рестриктора с NPC должна иметь параметр immediate, для мгновенного снятия рестриктора
	 (нужно при валидации патрульных путей).
4. Необходимо изменить работу с рестрикторами в схеме blowout (удалять только out рестрикторы, не сохранять список in рестрикторов)
5. Назначенные гулагом рестрикторы учитывать не будем.
6. Добавить проверку на автоматические рестрикторы. Их должно быть немного.

Реализация:
1. Для каждого NPC и зверушки хранится список уже назначенных рестрикторов и целевой список рестрикторов.
	 Синхронизация производится в blowout_scheme.action_anomaly для NPC и в bind_monster.generic_object_binder:update()
2. Для каждой аномалии (рестриктора) хранится список NPC, которым она назначена. Добавление в этот список происходит
	 при синхронизации.
3. При уходе NPC в оффлайн/смерти, все его списки очищаются.
4. Контроль за размером списка рестрикторов осуществляется на стадии синхронизации.
Списки хранятся в виде 
actual_restrictor[nid][aid]=restrictor_name
anoms_for_npc[nid][aid]=restrictor_name
npsc_for_anom[aid][nid]=true
,где nid=npc:id(), aid=anomaly:id()
]]

-- Учёт рестрикторов, навешанных на неписей.

local anoms_for_npc={}
local npcs_for_anom={}
local actual_anoms_for_npc={}
local npc_restrictors_need_update={}

local function init_if_needed(nid)
	if (not anoms_for_npc[nid]) then
		anoms_for_npc[nid]={}
	end
	if (not actual_anoms_for_npc[nid]) then
		actual_anoms_for_npc[nid]={}
	end
	return anoms_for_npc[nid],actual_anoms_for_npc[nid]
end

-- Добавить неписю или зверушке рестриктор. Он добавится на следующем экшене или апдейте.
function add_restriction(npc,id,name)
	local nid=npc:id()
	if name==nil then
		name=(level.object_by_id(id) and level.object_by_id(id):name())
	end
	if not name then
		get_console():execute("load ~~~ add_restriction(): Warning! Nonexistent restrictor id "..id)
		return
	end
	init_if_needed(nid)
	if anoms_for_npc[nid][id] then
		-- Уже добавлен
	else
		anoms_for_npc[nid][id]=name
		npc_restrictors_need_update[nid]=true
	end
end

function remove_restriction(npc,id,name,immed)
	local nid=npc:id()
	if name==nil then
		name=(level.object_by_id(id) and level.object_by_id(id):name())
	end
	if not name then
		abort("remove_restriction(): Nonexistent restrictor id "..id)
		return
	end
	init_if_needed(nid)
	if immed then
	-- Мгновенное снятие рестриктора
		if actual_anoms_for_npc[nid][id] then
			npc:remove_restrictions("",name)
			actual_anoms_for_npc[nid][id]=nil
			npcs_for_anom[id][nid]=nil -- не проверяем npcs_for_anoms[id] на nil, т.к. рестриктор уже в actual
		end
		if anoms_for_npc[nid][id] then
			-- Не изменяем npc_restrictors_need_update, т.к. уже удалили его
			anoms_for_npc[nid][id]=nil
		end
	else
		-- Отложенное снятие
		if anoms_for_npc[nid][id] then
			anoms_for_npc[nid][id]=nil
			npc_restrictors_need_update[nid]=true
		end
	end
end

-- Вызывать при удалении/выключении рестриктора/аномалии (ставит этот рестиктор в очередь на очистку)
-- ВНИМАНИЕ! Этот рестриктор не должен больше использоваться в add_restriction! 
-- Вызывать в net_destroy или после удаления из списка онлайновых рестрикторов
function restrictor_deleted(id,name)
	for nid,anoms in pairs(anoms_for_npc) do
		if anoms[id] then
			anoms[id]=nil
			npc_restrictors_need_update[nid]=true
		end
	end
end

-- Рестриктор/аномалия может быть удалена
function clear_to_release(id)
	local cnt
	if npcs_for_anom[id] then
		for nid in pairs(npcs_for_anom[id]) do
			cnt=cnt+1
		end
		return cnt==0
	else
		return true
	end
end

-- Нужно ли обновление рестрикторов
function have_pending_sync(npc)
	local nid=npc:id()
	return npc_restrictors_need_update[nid]==true
end

local max_dynamic_restrictors_count=40

function syncronize(npc)
	local nid=npc:id()
	local cnt=0
	local anoms,actual=init_if_needed(nid)
	-- Сократим список аномалий до 20
	local disttbl={}
	for id in pairs(anoms) do
		cnt=cnt+1
	end
	if cnt>max_dynamic_restrictors_count then
		local disttbl={}
		for id in pairs(anoms) do
			local dist=0
			local sobj=alife():object(id)
			if sobj then
				dist=npc:position():distance_to_sqr(sobj.position)
			else
				dist=1000000
			end
			table.insert(disttbl,{id=id,dist=dist})
		end
	-- Отсортируем по расстоянию и выберем 20 ближайших
		table.sort(disttbl,function (a,b) return a.dist>b.dist end)
		for i=1,cnt-max_dynamic_restrictors_count do
			anoms[disttbl[i].id]=nil
		end
	end
	-- Cоставим списки удаляемых/добавляемых аномалий
	local add,rem="",""
	local first=true
	for id,name in pairs(actual) do
		if not anoms[id] then
			-- удаление
			if first then
				first=false
				rem=name
			else
				rem=name..","..rem
			end
			-- удаляем назначение непися аномалии
			if npcs_for_anom[id] then
				npcs_for_anom[id][nid]=nil
			end
			-- удаляем из списка актуальных
			actual[id]=nil
		end
	end
	first=true
	for id,name in pairs(anoms) do
		if not actual[id] then
		-- добавление
			if first then
				first=false
				add=name
			else
				add=name..","..add
			end
			-- добавляем непися к аномалии
			if not npcs_for_anom[id] then
				npcs_for_anom[id]={}
			end
			npcs_for_anom[id][nid]=true
			-- добавляем к актуальным
			actual[id]=name
		end
	end
	npc:remove_restrictions("",rem)
	npc:add_restrictions("",add)

	npc_restrictors_need_update[nid]=false
end

-- Очищает список аномалий для npc не удаляя рестрикторы. Вызывать при смерти npc или при его уходе в оффлайн.
function unreg_in_anom_manager(npc)
	local nid=npc:id()
--	npc:remove_all_restrictions()
	local anoms=anoms_for_npc[nid]
	if anoms then
		for aid in pairs(anoms) do
			if npcs_for_anom[aid] then
				npcs_for_anom[aid][nid]=nil
			end
		end
		anoms_for_npc[nid]=nil
	end
end

-- 

function bind(obj)
--	amk.mylog(obj:name().." bind")
	obj:bind_object(anom_binder(obj))
end



class "anom_binder" ( object_binder )
function anom_binder:__init( obj ) super( obj )
  self.sm = ogse_signals.get_mgr()
end


function anom_binder:net_spawn( sobj )
  if not object_binder.net_spawn( self, sobj ) then
    return false
  end
  add_anomaly( sobj.id, sobj.position, self.object:get_shape_radius(), sobj )
  self.sm:call( "on_anomaly_spawn", self.object, self )
  return true
end


function anom_binder:net_destroy()
  remove_anomaly( self.object:id() )
  self.sm:call( "on_anomaly_net_destroy", self.object, self )
  object_binder.net_destroy( self )
end


function get_radius_for_section( section )
  return get_float( section, "effective_radius", 2 )
end


anom_list = {}
function add_anomaly( id, pos, radius, sobj )
  local lname = object_level_name( sobj )
  anom_list[ id ] = {
    pos      = pos,
    clsid    = sobj:clsid(),
    radius   = radius or 0,
    section  = sobj:section_name(),
    location = lname
  }
end


function remove_anomaly( id )
  anom_list[ id ] = nil
end


function get_nearest_anomaly( npc )
  return get_nearest_anomaly_for_pos( npc:position() )
end


function get_nearest_anomaly_for_pos( posn )
  local anomid, pos, radius, dist
  local mindist = 10000000
  for id, o in pairs( anom_list ) do
    dist = posn:distance_to( o.pos ) - o.radius
    if dist < mindist then
      mindist = dist
      anomid  = id
      pos     = o.pos
      radius  = o.radius
    end
  end
  return anomid, pos, radius, mindist
end


function get_anomaly_list( npc, radius )
  return get_anomaly_list_for_pos( npc:position(), radius )
end


function get_anomaly_list_for_pos( posn, radius )
  local ret = {}
  for id, o in pairs( anom_list ) do
    local sobj = alife():object( id )
    if sobj then
      local dist = posn:distance_to( o.pos ) - o.radius
      if dist < radius then
        table.insert(
          ret, { id = id, name = sobj:name(), pos = o.pos, radius = o.radius }
        )
      end
    end
  end
  return ret
end
