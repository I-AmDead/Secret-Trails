-- -*- mode: lua; coding: windows-1251-dos -*-
function attach( sm )
  sm:subscribe({ signal = "on_save",       fun = this.save_changed_variables })
end

local load_table_cache = {}


local table_sort = table.sort
local table_remove = table.remove
local math_floor = math.floor
local math_random = math.random
local math_sqrt = math.sqrt
local string_sub = string.sub
local string_find = string.find
local string_byte = string.byte
local string_char = string.char
local string_match = string.match
local string_len = string.len
local string_gsub = string.gsub
local string_rep = string.rep
local string_gmatch = string.gmatch

----------------
local timers={}   --—Ö—Ä–∞–Ω–∏—Ç —Ä–µ–∞–ª-—Ç–∞–π–º —Ç–∞–π–º–µ—Ä—ã
local g_timers={} --—Ö—Ä–∞–Ω–∏—Ç —Ç–∞–π–º–µ—Ä—ã –≤ –∏–≥—Ä–æ–≤–æ–º –≤—Ä–µ–º–µ–Ω–∏
local markers={}  --—Ö—Ä–∞–Ω–∏—Ç –º–∞—Ä–∫–µ—Ä—ã –Ω–∞ –∫–∞—Ä—Ç–µ
local x_objs={}     --—Ö—Ä–∞–Ω–∏—Ç –ò–î—à–Ω–∏–∫–∏ –æ–±—ä–µ–∫—Ç–æ–≤
convert_npc={}
g_kick=false
local StartTime

is_debug = false
ver = "0"
oau_watchdog=0
oau_reason=""
--–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ç–∏–ø—Å–æ–≤
local pda_news = xr_sound.get_safe_sound_object([[device\pda\pda_news]])
local pda_tips = xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
local pda_rem  = xr_sound.get_safe_sound_object([[device\pda\accent_1]])
local pda_task = xr_sound.get_safe_sound_object([[device\pda\pda_objective]])
local pda_sos = xr_sound.get_safe_sound_object([[device\pda\pda_sos]])

local bufferedmessages={}

function logct(msg,tag)
	if true and (tag and (tag=="mcbt" or tag=="temp")) then --(tag=="dram")) then
	    get_console():execute("load ~~~ "..string_sub(msg,1,200))		
	end
end

function rep(npc,msg,tag)
	if string_find(npc:name(),"gar_dm") then
		logct(msg,tag)
	end
end

function mylog(msg)
  if is_debug then 
	  if msg==nil then
	    return 
	  end
	  if db and db.actor then
	    if bufferedmessages then
	      for k,v in ipairs(bufferedmessages) do
	        db.actor:give_game_news(v, "ui\\ui_iconsTotal", Frect():set(0,658,83,47), 0, 15000)
	      end
	      bufferedmessages=nil
	    end
	  db.actor:give_game_news(msg, "ui\\ui_iconsTotal", Frect():set(0,658,83,47), 0, 15000)
	  else
	    if bufferedmessages then
	      table.insert(bufferedmessages,msg)
	    end
	  end

	  if get_console() then
	    get_console():execute("load ~~~ "..string_sub(msg,1,200))
	    get_console():execute("flush")
	  end

	end
end

function start_timer( name, delay, params )
  if not delay then return false end
  if not params then params = "" end
  local tn = "amk." .. name
  if ogse_st_mgr.timer_exists( tn ) then
    local found = false
    for i = 0, 65535 do
      local id = tn .. "." .. tostring( i )
      if not ogse_st_mgr.timer_exists( id ) then
        log2(
          "[%s.start_timer]: found free id %s for %s",
          script_name(), id, tn
        )
        found = true
        tn    = id
        break
      end
    end
    ASSERT( found, "can't find free id for timer %s", tn )
  end
  ogse_st_mgr.start_timer(
    tn, delay, "amk.on_ogse_amk_timer",
    pack_array_to_string({ name, params })
  )
  return true
end


function g_start_timer( name, d, h, m, params )
  if not ( d and h and m ) then return false end
  if not params then params = "" end
  local tn = "amk." .. name
  if ogse_st_mgr.timer_exists( tn ) then
    local found = false
    for i = 0, 65535 do
      local id = tn .. "." .. tostring( i )
      if not ogse_st_mgr.timer_exists( id ) then
        log2(
          "[%s.g_start_timer]: found free id %s for %s",
          script_name(), id, tn
        )
        found = true
        tn    = id
        break
      end
    end
    ASSERT( found, "can't find free id for timer %s", tn )
  end
  ogse_st_mgr.delayed_fun_start( tn )
    :set_gdelayDHMS( d, h, m, 0 )
    :init(
      "amk.on_ogse_amk_timer",
      pack_array_to_string({ name, params })
    )
    :start()
  return true
end


function on_ogse_amk_timer( s )
  local t = unpack_array_from_string( s )
  local name, params = unpack( t )
  if type( params ) == "table" then
    params = pack_array_to_string( params )
  end
  __do_timer_action( name, params )
end


function start_timer_no_save()
  local tn = "amk.no_save"
  if ogse_st_mgr.timer_exists( tn ) then
    return false
  end
  ogse_st_mgr.start_timer( tn, 5, "amk.on_no_save_timer" )
  dsh.exec_on_update(
    function()
      db.actor:binded_object():show_hud_save_warning(
        "–ù–µ–ª—å–∑—è —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è, –ø–æ–∫–∞ –µ—Å—Ç—å —ç—Ç–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ!!!",
        6000, true, { 255, 255, 255, 255 }
      )
    end
  )
  return true
end

function on_no_save_timer() end


-- —Ñ—É–Ω–∫—Ü–∏—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ —Ç–∞–π–º–µ—Ä–æ–≤
-- –≤ –∫–æ–Ω—Ü–µ —Ç–∞–±–ª–∏—Ü—ã —Ç–∞–π–º–µ—Ä—ã —Å —Å–∞–º—ã–º –º–∞–ª–µ–Ω—å–∫–∏–º –≤—Ä–µ–º–µ–Ω–µ–º
function timersSort( t1, t2 )
  return t1[ 2 ] > t2[ 2 ]
end


function has_timer( name )
  for _, t in ipairs( load_table( "timers" ) ) do
    if t[ 1 ] == name then return true end
  end
  return ogse_st_mgr.timer_exists( "amk." .. name )
end


function remove_timer( name )
  local tn = "amk." .. name
  if ogse_st_mgr.timer_exists( tn ) then
    ogse_st_mgr.get_timer( tn ):stop()
  else
    local timers = load_table( "timers" )
    if table.getn( timers ) > 0 then
      for i = table.getn( timers ), 1, -1 do
        if timers[ i ][ 1 ] == name then
          table.remove( timers, i )
          break
        end
      end
      save_table( "timers", timers )
    end
  end
end


function has_g_timer( name )
  return has_timer( name )
end


-- –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —É–¥–∞–ª—ë–Ω–Ω—ã—Ö –∏–∑ pstor
local emerg_store
-- –£–¥–∞–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ pstor. –ß—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–∏—Ç—å –±—É—Ñ–µ—Ä
function emergency_cleanup()
  emerg_store={}
  if load_variable("zombied",false) then
    emerg_store.zombied=load_table("zombied")
    del_variable("zombied")
  end
  --get_console():execute("load ~~~ TIMERS emergency_cleanup: "..name)
  emerg_store.timers = load_table("timers")
	--dump_table(emerg_store.timers)
  del_variable("timers")
  save_variable("emerg",true)
end

-- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —É–¥–∞–ª—ë–Ω–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
function emergency_restore()
	if emerg_store.zombied then
		save_table("zombied", emerg_store.zombied)
	end
  --get_console():execute("load ~~~ TIMERS emergency_restore")
  save_table("timers", emerg_store.timers)
  del_variable("emerg")
end

function convert_timers()
  if load_variable("tmcv2",true) then
	--get_console():execute("load ~~~ TIMERS convert_timers: ")
	local timers = load_table("timers")
	--dump_table(timers)
	local tmp
	local name,delay,params
	local g_milliseconds = game_milliseconds()
	--local time_factor = sys_ini:r_float("alife","time_factor")
	local time_factor = getIniValueFloat("alife","time_factor",5,nil)
	local timers_to_unpack = {
		["af_transform"]					= true,
		["af_transform_universal"]			= true,
		["timer_drop_obj_varka"]			= true,
	}
    for a=1,100,1 do
		-- —Ä–µ–∞–ª—å–Ω—ã–µ —Ç–∞–π–º–µ—Ä—ã
		-- –æ—á–µ–Ω—å —Å—Ç–∞—Ä—ã–µ —Ç–∞–π–º–µ—Ä—ã
      tmp=load_variable("x_timer_"..a,nil)
      if tmp~=nil then
			name,delay,params=tmp,load_variable("x_timer_"..a.."_delay",0),load_variable("x_timer_"..a.."_params","")
			-- 400499000 -- –ø–æ–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Ä–∞–∑–Ω–∏—Ü—É —Å game.time()
			--get_console():execute("load ~~~ TIMERS convert_timers old real: "..name..", "..delay..", "..math_floor(delay - 400499000)..", "..params)
			if timers_to_unpack[name] == true then
				params = unpack_array_from_string(params)
				--dump_table(params)
			end
			table.insert(timers, {name, math_floor(delay - 400499000), params})
        del_variable("x_timer_"..a)
        del_variable("x_timer_"..a.."_delay")
        del_variable("x_timer_"..a.."_params")
      end
		-- —Å—Ç–∞—Ä—ã–µ —Ç–∞–π–º–µ—Ä—ã
		name = load_variable("xt"..a, nil)
		if name ~= nil then
			delay	= load_variable("xd"..a, nil)
			params	= load_variable("xp"..a, nil)
			-- 400499000 -- –ø–æ–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Ä–∞–∑–Ω–∏—Ü—É —Å game.time()
			--get_console():execute("load ~~~ TIMERS convert_timers real: "..name..", "..delay..", "..math_floor(delay - 400499000)..", "..params)
			if timers_to_unpack[name] == true then
				params = unpack_array_from_string(params)
				--dump_table(params)
    end
			table.insert(timers, {name, math_floor(delay - 400499000), params})
			del_variable("xt"..a)
			del_variable("xd"..a)
			del_variable("xp"..a)
		end
		-- –∏–≥—Ä–æ–≤—ã–µ —Ç–∞–π–º–µ—Ä—ã
		-- –æ—á–µ–Ω—å —Å—Ç–∞—Ä—ã–µ —Ç–∞–π–º–µ—Ä—ã
      tmp=load_variable("x_gtimer_"..a,nil)
      if tmp~=nil then
			name,delay,params=tmp,load_variable("x_gtimer_"..a.."_delay",0),load_variable("x_gtimer_"..a.."_params","")
			--get_console():execute("load ~~~ TIMERS convert_timers old game: "..name..", "..delay..", "..math_floor(delay * 60 * 1000)..", "..params)
			if timers_to_unpack[name] == true then
				params = unpack_array_from_string(params)
				--dump_table(params)
			end
			table.insert(timers, {name, math_floor(delay * 60 * 1000), params})
        del_variable("x_gtimer_"..a)
        del_variable("x_gtimer_"..a.."_delay")
        del_variable("x_gtimer_"..a.."_params")
      end
		-- —Å—Ç–∞—Ä—ã–µ —Ç–∞–π–º–µ—Ä—ã
		name = load_variable("gt"..a, nil)
		if name ~= nil then
			delay	= load_variable("gd"..a, nil)
			params	= load_variable("gp"..a, nil)
			--get_console():execute("load ~~~ TIMERS convert_timers game: "..name..", "..delay..", "..math_floor(delay * 60 * 1000)..", "..params)
			if timers_to_unpack[name] == true then
				params = unpack_array_from_string(params)
				--dump_table(params)
    end
			table.insert(timers, {name, math_floor(delay * 60 * 1000), params})
			del_variable("gt"..a)
			del_variable("gd"..a)
			del_variable("gp"..a)
		end
    end
    save_variable("tmcv2",false)
	-- —Å–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ —Ç–∞–π–º–µ—Ä–∞–º
	-- —Ç–∞–π–º–µ—Ä—ã —Å –º–µ–Ω—å—à–∏–º –≤—Ä–µ–º–µ–Ω–µ–º –±—É–¥—É—Ç –≤ –∫–æ–Ω—Ü–µ —Ç–∞–±–ª–∏—Ü—ã
	table_sort(timers, timersSort)
	--dump_table(timers)
	save_table("timers", timers)
  end
end


-- –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–π–º–µ—Ä–æ–≤
function check_timers()
  local timers = load_table( "timers" )
  -- —Å–ø–∏—Å–æ–∫ —Ç–∞–π–º–µ—Ä–æ–≤ –Ω–∞ –∑–∞–ø—É—Å–∫, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–ø—É—Å—Ç—è—Ç—Å—è –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏ —Ç–∞–±–ª–∏—Ü—ã,
  -- —Ç–∞–∫ –∫–∞–∫ —Ç–∞–±–ª–∏—Ü–∞ –º–æ–∂–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ —á–∏—Å—Ç–∏—Ç—Å—è –∏ –∑–∞–ø–æ–ª–Ω—è—Ç—Å—è –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ
  -- –∑–∞–ø—É—Å–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π
  local timersToStart = {}
  local milliseconds  = game_milliseconds()
  -- –∏–¥—ë–º —Å —Ö–≤–æ—Å—Ç–∞ –ø–æ —Ç–∞–π–º–µ—Ä–∞–º —Å –Ω–∞–∏–º–µ–Ω—å—à–∏–º –≤—Ä–µ–º–µ–Ω–µ–º —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è
  for i = table.getn( timers ), 1, -1 do
    local name  = timers[ i ][ 1 ]
    local delay	= timers[ i ][ 2 ]
    if delay <= milliseconds then
      local parameters = timers[ i ][ 3 ]
      if type( parameters ) == "table" then
        parameters = pack_array_to_string( parameters )
      end
      table.insert( timersToStart, { name, parameters } )
      -- —Å–Ω–∞—á–∞–ª–∞ —á–∏—Å—Ç–∏–º —Ç–∞–±–ª–∏—Ü—É, –∞ —Ç–æ –µ—â—ë –≤ __do_timer_action() –æ–Ω–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å
      -- –¥–æ–ø–æ–ª–Ω–µ–Ω–∞
      table.remove( timers )
    else
      -- —Ç–∞–π–º–µ—Ä–æ–≤ —Å –≤—Ä–µ–º–µ–Ω–µ–º –º–µ–Ω—å—à–∏–º –∑–∞ —Ç–µ–∫—É—â–µ–µ —É–∂–µ –Ω–µ—Ç, —Ç–∞–∫ –∫–∞–∫ —Ç–∞–±–ª–∏—Ü–∞ –±—ã–ª–∞
      -- –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
      break
    end
  end

  -- –∫–∞–∫–∏–µ-—Ç–æ —Ç–∞–π–º–µ—Ä—ã —Å—Ä–∞–±–æ—Ç–∞–ª–∏ –∏ –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
  if table.getn( timersToStart ) > 0 then
    -- –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º —Ç–∞–±–ª–∏—Ü—É
    save_table( "timers", timers )
    -- –∑–∞–ø—É—Å–∫ –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
    for i = 1, table.getn( timersToStart ) do
      local name       = timersToStart[ i ][ 1 ]
      local parameters = timersToStart[ i ][ 2 ]
      oau_reason = name .. " " .. parameters -- –¥–ª—è –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –≤ —Å–ª—É—á–∞–µ —Å–ª–µ–∂–∫–∏
      __do_timer_action( name, parameters )
    end
  end
end


-- —Ç–∞–±–ª–∏—Ü–∞ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –∏—Ö –≤—ã–∑–æ–≤–æ–≤
-- –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∏–∂–µ
local func_by_string = {}

	-- Proper70: –ù–∞–¥–æ–µ–ª–æ –¥–æ–±–∞–≤–ª—è—Ç—å —Å—é–¥–∞ —Å—Ç—Ä–æ–∫–∏ - —Å–¥–µ–ª–∞–ª —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ –ø–æ —Ç–∞–π–º–µ—Ä—É –ª—é–±–æ–π —Å–ª—É–∂–µ–±–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.
	-- params_string = –Ω—É–∂–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è.
	-- –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è: –Ω–µ–ª—å–∑—è –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —Ç–æ–ª—å–∫–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
	func_by_string["run"] = function (params_string)
		if params_string then
			loadstring(params_string)()
		end
	end
	-- —Å–ª–µ–¥—É—é—â–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
	func_by_string["run2"] = function (params_string)
		if params_string then
			loadstring(params_string)()
		end
	end
	func_by_string["run3"] = function (params_string)
		if params_string then
			loadstring(params_string)()
		end
	end
	func_by_string["run4"] = function (params_string)
		if params_string then
			loadstring(params_string)()
		end
	end
	func_by_string["run5"] = function (params_string)
		if params_string then
			loadstring(params_string)()
		end
	end
	func_by_string["af_transform"] = function (params_string)
		mod_call("af_transform_end",unpack_array_from_string(params_string))
	end
	func_by_string["af_transform_universal"] = function (params_string)
		mod_call("af_transform_universal_end", unpack_array_from_string(params_string))
	end
	func_by_string["amk_freeplay"] = function (params_string)
		if amk.load_variable("freeplay",0)==1 and level.name()=="l12_stancia_2" then
			xr_effects.game_credits()
		end
	end

	func_by_string["timer_drop_obj_varka"] = function (params_string)
		local tbl = unpack_array_from_string(params_string)
		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then
			-- —Å—ä–µ–ª–∏
			--amk.send_tip("—Å—ä–µ–ª–∏","—Å—ä–µ–ª–∏",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then
			-- –≤—ã–±—Ä–æ—Å–∏–ª–∏
			--amk.send_tip("–≤—ã–±—Ä–æ—Å–∏–ª–∏","–≤—ã–±—Ä–æ—Å–∏–ª–∏",0,15,"gen_info")
			-- –∑–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ —Ä–µ—Ü–µ–ø—Ç –∏, –µ—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ, –≤–∞—Ä–∫—É
			local obj	= level.object_by_id(tbl.obj_id)
			local anom	= level.object_by_id(tbl.anom_id)
			if obj and anom then -- –µ—Å–ª–∏ —á–µ–≥–æ —Å–∞–º–æ –≤—ã–ø–∞–¥–µ—Ç –∏–ª–∏ –±—É–¥–µ—Ç –≤–±—Ä–æ—à–µ–Ω–æ –≤ –∏–≥—Ä—É —Å–∫—Ä–∏–ø—Ç–æ–º –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –ì–ì –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏, —Ç–æ obj == nil –∏ –∞–Ω–æ–º–∞–ª–∏–∏ —Ç–æ–∂–µ –Ω–µ –±—É–¥–µ—Ç
				local obj_sect	= obj:section()
				local obj_pos	= obj:position()
				local anom_sect	= anom:section()
				local anom_pos	= anom:position()
				amk_mod.check_af_transform(obj, obj_sect, obj_pos, tbl.anom_id, anom_sect, anom_pos, tbl.anom_radius, tbl.lv, tbl.gv)
			end
		else
			-- –ø–µ—Ä–µ–ª–æ–∂–∏–ª–∏
			--amk.send_tip("–ø–µ—Ä–µ–ª–æ–∂–∏–ª–∏","–ø–µ—Ä–µ–ª–æ–∂–∏–ª–∏",0,15,"gen_info")
		end
 	end

function __do_timer_action( select_string, params_string )
  if func_by_string[ select_string ] then
    func_by_string[ select_string ]( params_string )
  end
end


--—Å–ø–∞–≤–Ω–∏–º –æ–±—ä–µ–∫—Ç—ã –Ω–∞ –∫–∞—Ä—Ç—É
--–¥–ª—è —Å–ø–∞–≤–Ω–∞ –Ω–µ–ø–∏—Å–µ–π —Å–º–æ—Ç—Ä–∏–º config\creatures\spawn_sections.ltx - —Ç–∞–º –Ω–∞–ø–∏—Å–∞–Ω—ã –∏–º–µ–Ω–∞ —Å–µ–∫—Ü–∏–π –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –Ω–µ–ø–∏—Å–µ–π
function spawn_item( spawn_item, pos, gv, lv )
  if not gv then gv = db.actor:game_vertex_id()  end
  if not lv then lv = db.actor:level_vertex_id() end
  return alife():create( spawn_item, pos, lv, gv )
end

--–∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–ª—è —Å–ø–∞–≤–Ω–∞ –ø–∞—Ç—Ä–æ–Ω–æ–≤
function spawn_ammo_in_inv(spawn_item,number,npc)
  if npc==nil then 
    npc=db.actor 
  end
  if number > 0 then
    return se_respawn.create_ammo(spawn_item, 
        npc:position(),
        npc:level_vertex_id(),  
        npc:game_vertex_id(),
        npc:id(),
        number)
  end
end

-- —É–¥–∞–ª—è–µ–º –æ–±—ä–µ–∫—Ç –∏–∑ –∏–≥—Ä—ã
function remove_item(remove_item)
  if remove_item~=nil then
    alife():release(alife():object(remove_item:id()), true)
    return true
  end
  return false
end

-- –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º –æ–±—ä–µ–∫—Ç –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è, –ø—Ä–∏–º–µ–Ω–∏–º–æ –∫ –ì–ì
function drop_item(npc,item)
  if item~=nil then
--      npc:mark_item_dropped(item)
    npc:drop_item(item)
  end
end

--—É–±–∏–≤–∞–µ–º –Ω–µ–ø–∏—Å—è
function make_suicide(npc)
  npc:kill(npc)
end


--—É–∑–Ω–∞–µ–º –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –Ω–µ–ø–∏—Å—è –∫ –¥—Ä—É–≥–æ–º—É
function get_npc_relation( obj, target )
  local rel = obj:relation( target )
  local relation
  if rel == game_object.neutral then
    relation = "neutral"
  elseif rel == game_object.friend then
    relation = "friend"
  elseif rel == game_object.enemy then
    relation = "enemy"
  else
    return false
  end
  return relation
end


--–∑–∞–¥–∞–µ–º –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –Ω–µ–ø–∏—Å—è –∫ –¥—Ä—É–≥–æ–º—É
function set_npc_relation(obj,target,relation)
  local rel
  if relation=="neutral" then
    rel=game_object.neutral
  elseif relation=="friend" then
    rel=game_object.friend
  elseif relation=="enemy" then
    rel=game_object.enemy
  else
    return false
  end 
  obj:set_relation(rel,target)
  return true
end

-- —É–∑–Ω–∞–µ–º –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É –Ω–µ–ø–∏—Å—è, –ø—Ä–∏–º–µ–Ω–∏–º–æ –∫ –ì–ì, —Ç–æ–ª—å–∫–æ –û–ù–õ–ê–ô–ù
function get_npc_community(npc)
  return npc:character_community()
end

-- –≤—ã—Å—Ç–∞–≤–ª—è–µ–º –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É –Ω–µ–ø–∏—Å—è, –º–æ–∂–Ω–æ –ì–ì, —Ç–æ–ª—å–∫–æ –û–ù–õ–ê–ô–ù
function set_npc_community(npc,community_string)
  --–∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è community_string –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å –≤ config\creatures\game_relations.ltx
  return npc:set_character_community(community_string, 0, 0)
end

--—É–¥–∞–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –ø–æ –∏–º–µ–Ω–∏
function remove_item_from_inventory_by_name(remove_item_name,npc)
  return remove_item_from_inventory(npc:object(remove_item_name),npc)
end

--—É–¥–∞–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
function remove_item_from_inventory(remove_item,npc)
  if npc==nil then npc=db.actor end
  if remove_item~=nil then
--      npc:mark_item_dropped(remove_item)
    alife():release(alife():object(remove_item:id()), true)
    return true
  end
  return false
end

--–ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –ª–∏ –∏–≥—Ä–∞
function check_game()
  if level.present() and (db.actor ~= nil) and db.actor:alive() then
    return true
  end
  return false
end


-- –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
local amk_vars = "amk.vars."
local changed_amk_vars = {}

function save_variable( variable_name, value )
  if value == nil then
    del_variable( variable_name )
  else
    changed_amk_vars[ variable_name ] = value
  end
end


function save_changed_variables()
  local cnt = 0
  for k, v in pairs( changed_amk_vars ) do
    ogse.save_var( amk_vars .. k, v )
    changed_amk_vars[ k ] = nil
    cnt = cnt + 1
  end
  log2( "[%s]: %s changed variables saved", script_name(), cnt )
end


-- –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
function load_variable( variable_name, value_if_not_found )
  local value
  if changed_amk_vars[ variable_name ] then
    value = changed_amk_vars[ variable_name ]
  else
    value = ogse.load_var_safe( amk_vars .. variable_name )
    if value == nil then value = value_if_not_found end
  end
  return value
end


-- –µ—Å—Ç—å –ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
function has_variable( variable_name )
  return ogse.var_exists( amk_vars .. variable_name )
end


-- —É–¥–∞–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
function del_variable( variable_name )
  ogse.delete_var( amk_vars .. variable_name )
  changed_amk_vars[ variable_name ] = nil
  load_table_cache[ variable_name ] = nil
end


-- —Ç–∞–±–ª–∏—Ü–∞ –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏ –∏–º—ë–Ω
local compress_table={
}
local checked=false

-- –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ –∫–æ—Ä–æ—Ç–∫–æ–µ
function compress_name(name)
  return name
end

--–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ì–ì –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –∑–æ–Ω–µ
function check_npc_in_box(npc, p1,p2,p3)
  local pos
  if npc.name then pos=npc:position() else pos=npc end
  if p3==nil then
    if is_point_inside_interval(pos.x,p1.x,p2.x) and
      is_point_inside_interval(pos.y,p1.y,p2.y) and
      is_point_inside_interval(pos.z,p1.z,p2.z) then
      return true
    else
      return false  
    end
  else
    local v1,v2,r,proj1,proj2,dv1,dv2
    v1=sub(p2,p1)
    v2=sub(p3,p2)
    v1.y=0 
    v2.y=0
    dv1=v1:magnitude()
    dv2=v2:magnitude()
    v1:normalize() 
    v2:normalize()
    r=sub(pos,p1)
    local v1p=vector():set(v1.z,0,-v1.x)
    proj2=v1p:dotproduct(r)/v1p:dotproduct(v2)
    proj1=v1:dotproduct(r)-v1:dotproduct(v2)*proj2
    if proj1>0 and proj1<dv1 and proj2>0 and proj2<dv2 and pos.y>p1.y and pos.y<p3.y then
      return true
    else
      return false
    end
  end
end

function is_point_inside_interval(x,p1,p2)
  if p1>p2 then 
    p1,p2 = p2,p1 
  end
  
  if x>p1 and x<p2 then 
    return true
  else 
    return false
  end
end

function sub(v1,v2)
  local newvec = vector():set( 0, 0, 0 )
  newvec.x = v1.x-v2.x
  newvec.y = v1.y-v2.y
  newvec.z = v1.z-v2.z
  return newvec
end
----------------------------


-- –í–Ω–∏–º–∞–Ω–∏–µ! –°—Ç—Ä–æ–∫–∏ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –Ω–µ –¥–æ–ª–∂–Ω—ã —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–∏–º–≤–æ–ª–æ–≤ —Å –∫–æ–¥–∞–º–∏ 0-31.
function pack_array_to_string(array)
  return string_char(1)..pack_new(array)
  -- local str=""
  -- local key
  -- for key0,value in pairs(array) do
    -- if type(key0)=="string" then
      -- key='"'..key0..'"'
    -- else
      -- key=key0
    -- end
    -- if type(value)=="table" then
      -- local substr=pack_array_to_string(value)
      -- str=str..key.."=>{"..substr.."}|"
    -- elseif type(value)=="customdata" or type(value)=="function" then
      -- mylog("Custom data and function isn't supported")
    -- elseif type(value)=="boolean" or type(value)=="number" then
      -- str=str..key.."=>"..tostring(value).."|"
    -- else
      -- str=str..key..'=>"'..value..'"|'
    -- end
  -- end
  -- return str
end

function unpack_array_from_string(str)
  if str==nil or str=="" then return {} end
  --get_console():execute("load ~~~ unpack_array_from_string: "..str)
  if string_sub(str,1,1)~=string_char(1) then
    -- –°—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç —É–ø–∞–∫–æ–≤–∫–∏
    return _parse(str)
  else
    -- –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —É–ø–∞–∫–æ–≤–∫–∏ —Ç—ç–≥–∏—Ä–æ–≤–∞–Ω —Å–∏–º–≤–æ–ª–æ–º c –∫–æ–¥–æ–º 1.
    return parse_new(string_sub(str,2,-1))
  end
end

function _assign(tbl,key,val)
  local key0=string_match(key,'"(.*)"')
  if key0 then
    tbl[key0]=val
  else
    tbl[key+0]=val
  end
end

local pack_type_num=1
local pack_type_string=2
local pack_type_bool=3
local pack_type_table=4
local pack_val_endtable=5

--[[
 –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —É–ø–∞–∫–æ–≤–∫–∏: 
 table ::= subtable
 subtable ::= keytype key valuetype ( value | subtable 0x5 )
 keytype ::= ( 0x1 | 0x2 | 0x3 | 0x4 )
 valuetype ::= ( 0x1 | 0x2 | 0x3 | 0x4 )
]]
function pack_new(tbl)
  local ret=""
  for k,v in pairs(tbl) do
    if type(k)=="number" then
      ret=ret..string_char(pack_type_num)..k
    elseif type(k)=="string" then
      ret=ret..string_char(pack_type_string)..k
    else
      abort("unsupported key type "..type(k))
    end
    if type(v)=="number" then
      ret=ret..string_char(pack_type_num)..v
    elseif type(v)=="string" then
      ret=ret..string_char(pack_type_string)..v
    elseif type(v)=="boolean" then
		--get_console():execute("load ~#I#:"..string.format(" !–ü–∞–∫—É–µ–º –±—É–ª–µ–≤ —Ç–∏–ø: "..tostring(v)))
		if v then
			ret=ret..string_char(pack_type_bool).."1"
		else
			ret=ret..string_char(pack_type_bool).."0"
		end
    elseif type(v)=="table" then
      ret=ret..string_char(pack_type_table)..pack_new(v)..string_char(pack_val_endtable)
    end
  end
  return ret
end

function parse_new(str,idx)
  local ret={}
  idx=idx or 1
  while true do
    local key,value
    if idx>string_len(str) then
      return ret,idx
    end
    vtype,idx=get_byte(str,idx)
    if vtype==pack_type_num then
      key,idx=get_num(str,idx)
    elseif vtype==pack_type_string then
      key,idx=this.get_string(str,idx)
    elseif vtype==pack_val_endtable then
      return ret,idx
    else
      abort("unsupported key type "..tostring(vtype))
    end
    vtype,idx=get_byte(str,idx)
    if vtype==pack_type_num then
      value,idx=get_num(str,idx)
    elseif vtype==pack_type_string then
      value,idx=this.get_string(str,idx)
    elseif vtype==pack_type_bool then
      value,idx=this.get_bool(str,idx)
    elseif vtype==pack_type_table then
      value,idx=parse_new(str,idx)
    else
      abort("unsupported key type "..tostring(vtype))
    end
    ret[key]=value
  end
end

function get_byte(str,idx)
  return string_byte(string_sub(str,idx,idx)),idx+1
end

function get_string(str,idx)
  local idx1=string_len(str)+1
  for i=idx,string_len(str),1 do
    if string_byte(string_sub(str,i,i))<32 then
      idx1=i
      break
    end
  end
  return string_sub(str,idx,idx1-1),idx1
end

function get_num(str,idx)
  local st,idx1=this.get_string(str,idx)
  return st+0,idx1
end

function get_bool(str,idx)
  local st,idx1=this.get_string(str,idx)
  return st=="1",idx1
end


function _parse(str)
  local ret={}
  while str and str~="" do
    local i1,i2,key=string_find(str,'(.-)=>')
    str=string_sub(str,i2+1)
    i1,i2,val=string_find(str,'"(.-)"|')
    if val and i1==1 then
      -- —Å—Ç—Ä–æ–∫–∞
      _assign(ret,key,val)
    else
      i1,i2,val=string_find(str,'(%b{})|')
      if val and i1==1 then
        -- —Ç–∞–±–ª–∏—Ü–∞
        _assign(ret,key,_parse(string_sub(val,2,-2)))
      else
        i1,i2,val=string_find(str,'(.-)|')
        -- —á–∏—Å–ª–æ –∏–ª–∏ –±—É–ª–µ–≤–æ –∑–Ω–∞—á–µ–Ω–∏–µ
        if val=="true" then
          _assign(ret,key,true)
        elseif val=="false" then
          _assign(ret,key,false)
        else
          _assign(ret,key,val+0)
        end
      end
    end
    str=string_sub(str,i2+1)
  end
  return ret
end
---------------------------------------------
--callback section
---------------------------------------------

--–∫–æ–ª–±—ç–∫ –Ω–∞ –≤–∑—è—Ç–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ì–ì
function on_item_take( obj )
  escape_dialog.have_a_art()
  level.map_remove_object_spot( obj:id(), "red_location" )
  amk_mod.check_usable_item( obj )
end


--–∫–æ–ª–±—ç–∫ –Ω–∞ –≤–∑—è—Ç–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ì–ì –∏–∑ —è—â–∏–∫–∞
function on_item_take_from_box( obj, item )
  level.map_remove_object_spot( obj:id(), "crlc_big" )
end

-- –∫–æ–ª–±—ç–∫ –Ω–∞ –∞–ø–¥–µ–π—Ç –ì–ì (—É–¥–æ–±–Ω–æ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π, —Ç–∞–∫ –∫–∞–∫ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è
-- –ø–æ—Å—Ç–æ—è–Ω–Ω–æ, –Ω–µ–ª—å–∑—è –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å, –∞ —Ç–æ –±—É–¥—É—Ç –ª–∞–≥–∏)
function on_actor_upade()
  ogse_signals.get_mgr():reschedule( 100 )
  check_timers()
end

class "convert_npc_timer" ( ogse_qt.quick_timer )
function convert_npc_timer:__init( id, flag ) super()
  self.id = id
  convert_npc[ self.id ] = flag
end

function convert_npc_timer:condition()
  return convert_npc[ self.id ] == nil
end

function convert_npc_timer:action()
end

function convert_npc_timer:update()
  local obj  = level.object_by_id( self.id )
  local sobj = alife():object( self.id )
  if sobj then
    local v = convert_npc[ self.id ]
    if ( not obj ) and v == true then
        convert_npc[ self.id ] = false
        switch_online( self.id )
      elseif obj and v == false then
        convert_npc[ self.id ] = nil
      elseif obj and v == 1 then
        -- —Ç–∞–π–Ω–∏–∫ –Ω–µ –ø–µ—Ä–µ—à—ë–ª –≤ –æ—Ñ—Ñ–ª–∞–π–Ω –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –µ–≥–æ —Ç—É–¥–∞ –∑–∞–ø–∏—Ö–Ω—É—Ç—å.
        alife():set_switch_online(  self.id, false )
        alife():set_switch_offline( self.id, true  )
      elseif v == 1 then -- —Ç–∞–π–Ω–∏–∫ –≤ –æ—Ñ—Ñ–ª–∞–π–Ω–µ. –≤—ã—Ç–∞–ª–∫–∏–≤–∞–µ–º.
        convert_npc[ self.id ] = nil
        switch_online( self.id )
      end
  else
    convert_npc[ self.id ] = nil
  end
end

function on_net_spawn(obj)
	amk_mod.build_btrs_table(obj)
end

--–∫–æ–ª–±—ç–∫ –Ω–∞ —é–∑–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
function on_use(victim, who)
  if db.actor and who and who:id()==db.actor:id() then
    mod_call("check_usable_item",victim)
  end
end

function on_npc_hit(obj, amount, local_direction, who, bone_index)
	if who:id()==db.actor:id() then
		local typ = "npc"
		if IsMonster(obj) then typ="monster" end 
	end
end

-- òòòòòòòò òò òòòòòòòòò òòòòòòòòòòòò òòò ò òòòòòòò
-- –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–∏–¥–∏–º–æ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
function enemy_see_actor(obj,typ)
  if string.find(obj:name(),"fedya_razboinik") then
       db.actor:give_info_portion("fedya_razboinik_see")
  end 
  if string.find(obj:name(),"ucen_ohr1") then
       db.actor:give_info_portion("ucen_ohr1_see")
  end
  if string.find(obj:name(),"ucen_ohr2") then
       db.actor:give_info_portion("ucen_ohr2_see")
  end
  if string.find(obj:name(),"ucen_ohr3") then
       db.actor:give_info_portion("ucen_ohr3_see")
  end
  if string.find(obj:name(),"razbor_ban1") then
       db.actor:give_info_portion("razbor_ban1_see")
  end
  if string.find(obj:name(),"razbor_ban2") then
       db.actor:give_info_portion("razbor_ban2_see")
  end
  if string.find(obj:name(),"razbor_ban3") then
       db.actor:give_info_portion("razbor_ban3_see")
  end
  if string.find(obj:name(),"razbor_ban4") then
       db.actor:give_info_portion("razbor_ban4_see")
  end
  if string.find(obj:name(),"razbor_ban5") then
       db.actor:give_info_portion("razbor_ban5_see")
  end
end

-- –∑–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ, –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∫–µ –∏–≥—Ä—ã,
-- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏; –≤—Ä—É—á–Ω—É—é –Ω–µ –≤—ã–∑—ã–≤–∞—Ç—å
function on_game_load()
  if db.storage[ db.actor:id()].pstor == nil then
    db.storage[ db.actor:id() ].pstor = {}
  end

  mod_call( "first_run" )
  convert_timers() -- –ø–µ—Ä–µ–Ω–æ—Å–∏–º —Å—Ç–∞—Ä—ã–µ –∏ –Ω–æ–≤—ã–µ —Ç–∞–π–º–µ—Ä—ã –≤ —Ç–∞–±–ª–∏—Ü—É

  mod_call( "check_spawn" )
  
  local timers = load_table( "timers" )
  if table.getn( timers ) > 0 then
    log2(
      "[%s]: found %s timers, subscribing",
      script_name(), table.getn( timers )
    )
    ogse_signals.get_mgr():subscribe({
      signal = "on_update", fun = this.on_actor_upade,
      [ "script_name" ] = "amk.on_actor_upade",
    })
  end

  if has_alife_info("val_actor_has_borov_key") and not has_alife_info("val_borov_dead") then
    db.actor:give_info_portion("val_borov_dead")
  end    
end

-- –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å–∞–º–æ–π –ø–µ—Ä–≤–æ–π. –û–Ω–ª–∞–π–Ω–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã! db.actor –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω!
function on_game_start()
	ver = get_ver()
	getStartTime()
end


function getStartTime()
  local d = string.explode( ".", _G.get_string( "alife", "start_date" ), true )
  StartTime = game.CTime()
  StartTime:set( tonumber( d[ 3 ] ), tonumber( d[ 2 ] ), 1, 0, 0, 0, 0 )
  local temp = game.CTime()
  temp:setHMS( 24, 0, 0 )
  StartTime = StartTime - temp
end


--------------------- user function section---------------
function mod_call(i,...)
  if not amk_mod[i] then
    amk_mod.f=function () loadstring(amk.decode(c))() end
    setfenv(amk_mod.f,amk_mod)
    amk_mod.f()
  end
  amk_mod[i](...)
end


function load_table( name )
  if not load_table_cache[ name ] then
    local var = load_variable( name )
    load_table_cache[ name ] = ( var == nil and {} )
      or unpack_array_from_string( var )
  end
  return load_table_cache[ name ]
end


function save_table( name, tbl )
  load_table_cache[ name ] = tbl
  save_variable( name, pack_array_to_string( tbl ) )
end


function update_table( name, id, val )
  local tbl = load_table( name )
  tbl[ id ] = val
  save_table( name, tbl )
  return tbl
end


function sixbit(char)
	local byte = string_byte(char)
	local result = nil
	if (byte == 61) then
		result = 0
	elseif (byte == 45 or byte == 43) then
		result = 62
	elseif (byte == 95 or byte == 47) then
		result = 63
	elseif (byte <= 57) then
		result = byte + 4
	elseif (byte <= 90) then
		result = byte - 65
	elseif (byte <= 122) then
		result = byte - 71
	end

	return result
end

function decodeblock(block)
	local sixbits = {}
	local result = ""
	for counter=1,4 do
		sixbits[counter] = sixbit(string_sub(block,counter,counter))
	end

	result = string_char(sixbits[1]*4 + math_floor(sixbits[2] / 16))
	if (string_sub(block,3,3) ~= "=") then
		result = result .. string_char((sixbits[2] % 16)*16 + math_floor(sixbits[3] / 4))
	end
	if (string_sub(block,4,4) ~= "=") then
		result = result .. string_char((sixbits[3] % 4) * 64 + sixbits[4])
	end

	return result
end

function decode(data)
	local result = ""
	local str={string_byte("CheckForCheat",1,1000)}
	local strl=#str
	for c=1,string_len(data),4 do
		result=result..decodeblock(string_sub(data,c,c+3))
	end

	local result1=""
	for c=1,string_len(result),1 do
		local sl=string_byte(string_sub(result,c))
		sl=bit_xor(sl,str[1+(c-1)%strl])
		result1 = result1 .. string_char(sl)
	end

	return result1
end

function bind_lc(obj)
  if obj:name()=="exit_to_sarcofag_01" and level.name()=="l12_stancia" and amk.load_variable("freeplay",0)>0 then
    local sobj = alife():object(obj:id())
    if sobj then
      alife():release(sobj,true)
    end
  end
end

function dump_table(tbl, lvl)
	if not lvl then
		lvl = 1
	end
  for k,v in pairs(tbl) do
    if type(v)=="table" then
      get_console():execute("load ~~~ "..string_rep(".", lvl)..tostring(k).." => #")
      dump_table(v, lvl + 1)
    else
      str="load ~~~ "..string_rep(".", lvl)..tostring(k).." => "..tostring(v)
      if string_len(str)>200 then
        str=string_sub(str,1,200)
      end
      get_console():execute(str)
    end
  end
  --get_console():execute("flush")
end


-- —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –æ–±—ä–µ–∫—Ç –Ω–∞ –≤—Ö–æ–¥–µ
function read_stalker_params( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function read_monster_params( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

-- —Ç–∞–±–ª–∏—Ü–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –æ–±—ä–µ–∫—Ç –Ω–∞ –≤—Ö–æ–¥–µ
function write_stalker_params( tbl,sobj,noconvert )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function write_monster_params( tbl, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function get_anomaly_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_anomaly_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

--–¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∑–∞–ø—Ä–µ—â–µ–Ω—ã –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏!!!
function parse_custom_data(str)
	local t={}
	if str then
		for section, section_data in string_gmatch(str,"%s*%[([^%]]*)%]%s*([^%[%z]*)%s*") do
			section = trim(section)
			t[section]={}
			for line in string_gmatch(trim(section_data), "([^\n]*)\n*") do
				if string_find(line,"=")~=nil then
					for k, v in string_gmatch(line, "([^=]-)%s*=%s*(.*)") do
						k = trim(k)
						if k~=nil and k~='' and v~=nil then 
							t[section][k]=trim(v) 
						end
					end
				else
					for k, v in string_gmatch(line, "(.*)") do
						k = trim(k)
						if k~=nil and k~='' then
							t[section][k]="<<no_value>>" 
						end
					end
				end
			end
		end
	end
	return t
end

function trim (s)
	return (string_gsub(s, "^%s*(.-)%s*$", "%1"))
end

function gen_custom_data(tbl)
	local str=''
	for key, value in pairs(tbl) do
		str = str.."\n["..key.."]\n"
		for k, v in pairs(value) do
			if v~="<<no_value>>" then
				str=str..k.." = "..v.."\n"
			else
				str=str..k.."\n"
			end
		end
	end
	return str
end 


function get_lc_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_lc_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function point_in_poly (pts, x,y)
	local cnt,k,j
	local ret = false
	cnt = #pts
	j = cnt
	for k = 1,cnt do
		if ((pts[k].y <=y) and (y < pts[j].y)) or ((pts[j].y <=y) and (y < pts[k].y)) then
			if (x < (pts[j].x - pts[k].x) * (y - pts[k].y) / (pts[j].y - pts[k].y) + pts[k].x) then
				ret = not ret
			end
			j = k
		end
	end
	return ret
end


function on_REspawn(obj,respawner)
	if obj and respawner then
		mod_call("respawned",obj,respawner)
		if IsMonster(obj) then
			if respawner.spawned_goes_online==true then mod_call("switch_monster_online",obj) 
			elseif respawner.spawned_goes_online==false then mod_call("switch_monster_offline",obj) 			end
		end
	end
end

function get_breakable_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_breakable_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_spawner_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_spawner_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end

function parse_ini_section_to_array_new(iniFileName, section)
	local tmp={}
	if iniLineSectionExist(section, iniFileName) then
		local result, id, value = nil, nil, nil
		for a=0,iniLinesCount(section, iniFileName)-1 do
			result, id, value = getIniLine(section,a,"","",iniFileName)
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end


function str_explode( div, str, clear )
  return string.explode( div, str, clear )
end


function quotemeta(str)
	return (string_gsub(s, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1"))
end


function add(v1,v2)
	local nv=vector():set( 0, 0, 0 )
	nv.x=v1.x+v2.x
	nv.y=v1.y+v2.y
	nv.z=v1.z+v2.z
	return nv
end

function set_len(v,num)
	local cl = math_sqrt(v.x*v.x+v.y*v.y+v.z*v.z)
	cl = num/cl
	v.x= v.x*cl
	v.y= v.y*cl
	v.z= v.z*cl
	return v
end


function get_restrictor_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_restrictor_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_trader_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_trader_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_invbox_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_invbox_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_ammo_params( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_ammo_params( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_item_params( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_item_params( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function cfg_get_string(ini,sect,name,def)
	if ini and ini:line_exist(sect,name) then
		return ini:r_string(sect,name)
	end
	return def
end


function get_destroyable_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_destroyable_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_weapon_data( sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end

function set_weapon_data( t, sobj )
  ASSERT( false, "[%s]: OBSOLETED! sobj = %s", script_name(), sobj:name() )
end


function get_ver()
	local ver = "0"
	local mm = _G.main_menu.get_main_menu()
	if mm then ver = mm:GetGSVer() end
	return ver
end

function game_milliseconds()
	if StartTime == nil then
		getStartTime()
		if StartTime == nil then
			return 0
		end
	end
	local gtime = game.get_game_time()
	local seconds = gtime:diffSec(StartTime)
	local y,m,d,h,min,sec,ms = gtime:get()
	return (seconds * 1000 + ms)
end

function game_seconds()
  if not StartTime then
    getStartTime()
    if not StartTime then
      return 0
    end
  end
  return game.get_game_time():diffSec( StartTime )
end

function game_minutes()
  return math.floor( game_seconds() / 60 )
end

function game_hours()
	return math_floor(game_seconds() / 3600)
end

function game_days()
	return math_floor(game_seconds() / 86400)
end
