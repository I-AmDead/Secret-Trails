-- Нужны списки тайников, которые НПС не будут обыскивать.
off_npcs={}
items={}
relation_matrix={}
tables_ready = false
local sell_table = {}
local item_dependence = {}
local always_keep_item = {}

local wpn_fp = {}
-- Пора апдейт делать
local bFlag = false
-- Номер последнего отработанного обьекта
local iCounter = 0
-- Время последнего глобального апдейта
local iTime = -1
-- Как часто делать апдейты, игровые минуты
local iFreq = 60 * 3
local initialized = false

local monster_params = {}

local maps={
	"l01_escape",
	"l02_garbage",
	"l03_agroprom",
--	"l03u_agr_underground",
	"l04_darkvalley",
--	"l04u_labx18",
	"l05_bar",
	"l06_rostok",
	"l07_military",
	"l08_yantar"--,
	--"l08u_brainlab",
	--"l10_radar",
	--"l10u_bunker",
	--"l11_pripyat",
	--"l12_stancia",
	--"l12_stancia_2",
	--"l12u_control_monolith",
	--"l12u_sarcofag"
}

  protected = {
	5008,
	5013,
	5014,
	5041,
	5065,
	5084,
	5104,
	5205,
	5222,
	5226,
	5237,
	5238,
	5243,
	5244,
	5245,
	5246,
	5247,
	5248,
	5249,
	5250,
	5254,
	5255,
	5408,
	5413,
	5428,
	5433,
	5434,
	5444,
	5446,
	5470,
	5471,
	5472,
	5473,
	5474,
	573
}

local smart_filters = {
	"esc_bridge", "esc_blokpost"
}


local rel_enemy,rel_friend

--радиус "обзора"
local look_radius=100
--интенсивность поиска (количество отрабатываемых неписей)
--local search_intensivity=40
local search_intensivity=60
-- продолжительность боев
local max_rounds = 10
-- При каком уровне здоровья НПС считается раненым
local health_wound = 0.20
local health_wound_set = 0.02
-- Эталон firepower\distance при distance = 1 который снимет 100% health
local base_fp = 1400
-- Коэффициент для расстояния
local dist_coeff = 8
-- Вещи дешевле продает торговцам
local sell_limit = 3000
-- Рейтинг за убийство. При убийстве более слабого - 0.5 * rate_kill_base, более сильного - 2 * rate_kill_base
local rate_kill_base = 100
local rate_art_found = 100
local to_actor = 150
local look_radius_box = 100

function init()
	if (initialized == false) then
		if amk.load_variable("freeplay",0) == 2 then -- Фриплей - везде гуляем.
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "l05_bar", "l06_rostok", "l07_military",
				"l08_yantar", "l10_radar", "l11_pripyat", "l12_stancia", "l12_stancia_2" }
		end
		build_tables()
		iTime = (game_minutes() - iFreq) + 3
		initialized = true
	end
end

function update()
	if (bFlag == false and iTime ~= -1) then
		if (game_minutes() - iTime > iFreq) then
			bFlag = true			
			off_npcs={}	
			items={}
			iCounter = 1
			amk.mylog("Updating offline-ALife started")
		end
	end
	if (bFlag == true) then
		if (iCounter >= 65535) then
			bFlag = false
			iTime = game_minutes()
			iCounter = 1
			amk.mylog("Updating offline-ALife finished")
		else
			local obj
			obj = alife():object(iCounter)
			add_fresh_meat(obj)
			iCounter = iCounter + 1
		end
	end
end

--on_death - не убиваем!
--on_hit - не обрабатываем!
function add_fresh_meat(obj)
	if obj and obj.m_game_vertex_id and db.actor and db.actor:id() ~= obj.id then
		if game_graph():valid_vertex_id(obj.m_game_vertex_id) then
			local map=alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
			if not off_npcs[map] then off_npcs[map]={monsters={},stalkers={},weapons={},artefacts={},inv_boxes={}} end
			if IsMonster(obj) and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id~=nil and obj.m_story_id==4294967296 then
				local flags = get_flags(obj.id)
				if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
					table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
				end
			elseif IsStalker(obj) and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id~=nil and obj.m_story_id==4294967296 then
				local flags = get_flags(obj.id)
				if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
					if obj:community()~="zombied" then
						table.insert(off_npcs[map].stalkers, {id = obj.id, name = obj:name()})
					else
						table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
					end
				end
			elseif isWeapon(obj) then
				if obj.m_story_id~=nil and obj.m_story_id==4294967296 then
					if (obj.parent_id ~= nil) then
						local p_obj = alife():object(obj.parent_id)
						if (p_obj) then
							if p_obj.m_game_vertex_id and game_graph():valid_vertex_id(p_obj.m_game_vertex_id) then
								--if p_obj:section_name()=="inventory_box" and box_is_protected(p_obj)==true then
								if p_obj:section_name()=="inventory_box" 
or 
p_obj:section_name()=="treasure_item" then
									-- НПС "не видят" этого
									map = ""
								else
									local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
									if (p_map ~= map) then
										if not off_npcs[p_map] then off_npcs[p_map]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}} end
										map = p_map
									end	
								end
							end
						end
					end
					if map ~= "" then table.insert(off_npcs[map].weapons, {id=obj.id, name = obj:name()}) end
				end
			elseif string.find(obj:section_name(),"^af_") then
				if (obj.parent_id ~= nil) then
					local p_obj = alife():object(obj.parent_id)
					if (p_obj) then
						if p_obj.m_game_vertex_id and game_graph():valid_vertex_id(p_obj.m_game_vertex_id) then
							--if p_obj:section_name()=="inventory_box" and box_is_protected(p_obj)==true then
							if p_obj:section_name()=="inventory_box" then
								-- НПС "не видят" этого
								map = ""
							else
								local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
								if (p_map ~= map) then
									if not off_npcs[p_map] then off_npcs[p_map]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}} end
									map = p_map
								end	
							end
						end
					end
				end
				if map ~= "" then table.insert(off_npcs[map].artefacts, {id = obj.id, name = obj:name()}) end
			elseif (obj:section_name()=="inventory_box" and box_is_protected(obj)==false) then
				table.insert(off_npcs[map].inv_boxes, {id = obj.id, name = obj:name()})
			end
			
			if (obj.parent_id ~= nil and obj.m_story_id~=nil and obj.m_story_id==4294967296 and IsMonster(obj)==false and IsStalker(obj)==false) then
				local zz = alife():object(obj.parent_id)
				if zz then
					if IsStalker(zz) and zz.m_story_id~=nil and zz.m_story_id==4294967296 then
						if not items[obj.parent_id] then items[obj.parent_id] = {} end
						table.insert(items[obj.parent_id], {id = obj.id, name=obj:name()})
						gps_habar.insert_item(obj.parent_id, obj) -- Idler++-- корректируем хабар в помеченных тайниках
					else
						if not items[obj.parent_id] then items[obj.parent_id] = {} end
						table.insert(items[obj.parent_id], {id = obj.id, name=obj:name()})
						gps_habar.insert_item(obj.parent_id, obj) -- Idler++-- корректируем хабар в помеченных тайниках
					end
				end
			end
		end
	end
end

--строим таблицу неписей, монстров и оружия
function build_tables()
	-- Почистим таблицу
--	off_npcs={}	
--	local obj
--	for a=1,65534 do
--		obj = alife():object(a)
--		add_fresh_meat(obj)
--	end

	rel_enemy,rel_friend = utils.cfg_get_number(system_ini(), "game_relations", "goodwill_enemy", nil, false, -1000), utils.cfg_get_number(system_ini(), "game_relations", "goodwill_friend", nil, false, 1000)
	local s_comm_list = utils.cfg_get_string(system_ini(), "game_relations", "communities", nil, false, "", "")
	local comm_list = {}
	local s_value = amk.str_explode(",", amk.trim(s_comm_list), true)
	for a=1, table.getn(s_value), 2 do
		local s_comm = s_value[a]
		table.insert(comm_list, s_comm)
	end
  
	local tmp={}
	local result, id, value = nil, nil, nil
	for a=0,system_ini():line_count("communities_relations")-1 do
		result, id, value = system_ini():r_line("communities_relations",a,"","")
		if id~=nil and trim(id)~="" and trim(id)~=nil then
			relation_matrix[trim(id)]={}
			table.insert(tmp, trim(id))
		end
	end
	
	for a=1,table.getn(tmp) do
		local value = utils.cfg_get_string(system_ini(), "communities_relations", tmp[a], nil, false, "", "")
		local idx = tmp[a]
		local m_value = amk.str_explode(",", amk.trim(value), true)
		for i=1, table.getn(m_value) do
			local idx2 = comm_list[i]
			local v = m_value[i]
			if relation_matrix[idx] and idx2~=nil and v ~= nil then
				relation_matrix[idx][idx2]=tonumber(amk.trim(v))
			end
		end
	end
	
	sell_table = {}
	local sini = ini_file("misc\\trade_generic.ltx")
	local cfg_sell = utils.cfg_get_string(sini, "trader", "sell_condition", npc, false, false, "")
	if sini and sini:section_exist(cfg_sell) then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count(cfg_sell)-1 do
			result, id, value = sini:r_line(cfg_sell,a,"","")
			if id~=nil and amk.trim(id)~="" and amk.trim(id)~=nil and amk.trim(value)~="" and amk.trim(value)~=nil then
				-- Добавим в таблицу, что можно продавать.
				sell_table[id] = true
			end
		end
	end

	local death_ini = ini_file("misc\\death_generic.ltx")
    --' Заполняем таблицу зависимостей
	item_dependence = {}
	local n = death_ini:line_count("item_dependence")
	local id, value = "", ""
	for i=0,n-1 do
		result, id, value	= death_ini:r_line("item_dependence",i,"","")
		item_dependence[id] = {}
		local vvv = parse_names(value)
		for k,v in pairs(vvv) do
			item_dependence[id][v] = true
		end
	end
 	--' Предметы, которые нельзя продавать (квестовые например)
	always_keep_item = {}
    local n = death_ini:line_count("keep_items")
	for i=0,n-1 do
		result, id, value	= death_ini:r_line("keep_items",i,"","")
        if value == "true" then
            always_keep_item[id] = true
        end
    end
	
	tables_ready = true
end

function update_npc_tables()
	off_npcs={}	
	local obj
	for a=1,65534 do
		obj = alife():object(a)
		if obj then
			add_fresh_meat(obj)
		end
	end
	bFlag = false
	iTime = game_minutes()
	iCounter = 1
end

function update_trade()
	for a=1,65534 do
		obj = alife():object(a)
		if obj then
			process_trade(obj)
		end
	end
end

function update_tables(level)
	off_npcs[level]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}}
	local obj
	for a=1,65534 do
		obj = alife():object(a)
		if (obj and alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())==level) then
			add_fresh_meat(obj)
		elseif (obj and obj.parent_id ~= nil) then
			local p_obj = alife():object(obj.parent_id)
			if (p_obj) then
				local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
				if (p_map == level) then
					add_fresh_meat(obj)
				end
			end
		end
	end	
end

function trim (s)
	return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

--генерируем оффлайн события
function offline_alife()
	
	local lname = maps[math.random(table.getn(maps))]
--	update_tables(lname)
	amk.mylog("Offline_alife - "..lname)
	local st = 0
	if off_npcs[lname] then st = table.getn(off_npcs[lname].stalkers) end
	if st>0 then
		for search = 1,search_intensivity do
			local rnd = math.random(st)
			if off_npcs[lname].stalkers[rnd] then 
				local victim = alife():object(off_npcs[lname].stalkers[rnd].id)
				if victim and not victim.online and victim.health and victim.can_switch_online and victim:health()>0 and victim:can_switch_online() and victim:name() == off_npcs[lname].stalkers[rnd].name then
					local vdata = collect_info(victim,lname)
					if table.getn(vdata.enemies)>0 then
					--есть вражина - воюем нах!
						on_enemies_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.monsters)>0 then
					--есть монстрятина - видели, слышали, убили, сдохли...
						on_monsters_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.corpses.stalkers)>0 then
					--есть труп сталкера
						on_npc_corpses_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.corpses.monsters)>0 then
					--есть труп монстра
						on_monster_corpses_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.weapons.seen)>0 then
					--есть бесхозное оружие
						on_weapons_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.artefacts)>0 then
					--есть арты
						on_artifacts_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.inv_boxes)>0 then
					--есть контейнеры. Надо обыскать.
						on_inv_boxes_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif items[victim.id] and table.getn(items[victim.id]) > 0 then
					--попробуем продать всякого
						amk.mylog("Offline: lets trade")
						process_trade(victim)
						amk.mylog("Offline: trade done")
						break
					else
						--amk.mylog("__")
					end
				end
			end
		end
	end
end

--собираем инфу о неписе
function collect_info(victim,map)
  local vdata = {}
	vdata.rank = victim:rank() --ранг
	vdata.health = victim:health()  --хелсы
	vdata.community = victim:community()  --группировка
	
	--пытаемся определить пушку
	local wp = table.getn(off_npcs[map].weapons)
	--условная огневая мощь
	vdata.fire_power = 0
	
	vdata.weapons={own={},seen={}}
	-- если есть пушки в карманах, выбираем лучшую (по условной мощности)
	if wp>0 then
		for w=1,wp do
			if off_npcs[map].weapons[w] then
				local www = alife():object(off_npcs[map].weapons[w].id)
				if www and www:name()==off_npcs[map].weapons[w].name then
					if www.parent_id == victim.id then
						table.insert(vdata.weapons.own, {id = www.id, name = www:name()})
						local fp = get_weapon_firepower(www)
						if vdata.fire_power<fp then vdata.fire_power=fp end
					elseif www:can_switch_online() and victim.position:distance_to(www.position)<look_radius and sobj_is_far(www, to_actor) then
						if www.parent_id==nil or www.parent_id==65535 or (alife():object(www.parent_id) and alife():object(www.parent_id):section_name()=="inventory_box") then
							table.insert(vdata.weapons.seen, {id = www.id, name = www:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем списки друзей и врагов в зоне "видимости"
	-- Для тех, у кого смарт в фильтрах - не собираем врагов
	-- Для остальных - не учитываем врагов из смартов
	local npc_peaceful = npc_smart_is_peaceful(victim)
	
	vdata.friends={}
	vdata.enemies={}
	vdata.corpses={monsters={},stalkers={}}
	if table.getn(off_npcs[map].stalkers)>0 then
		for a=1,table.getn(off_npcs[map].stalkers) do
			if off_npcs[map].stalkers[a] then
				local opponent = alife():object(off_npcs[map].stalkers[a].id)
				if opponent and opponent.id~=victim.id and opponent.health and opponent.can_switch_online and opponent:can_switch_online() and opponent:name() == off_npcs[map].stalkers[a].name  then
					if victim.position:distance_to(opponent.position)<look_radius then
						if opponent:health()>0 then
							local rel = relation_check(victim,opponent)
							if rel>=rel_friend then
								table.insert(vdata.friends, {id = opponent.id, name = opponent:name()})
							elseif rel<=rel_enemy then
								if npc_peaceful == false and npc_smart_is_peaceful(opponent) == false then
									table.insert(vdata.enemies, {id = opponent.id, name = opponent:name()})
								end
							end
						else
							if (sobj_is_far(opponent, to_actor)) then
								table.insert(vdata.corpses.stalkers, {id = opponent.id, name = opponent:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список монстряков в зоне "видимости"
	vdata.monsters={}
	if off_npcs[map].monsters then
		if table.getn(off_npcs[map].monsters)>0 then
			for a=1,table.getn(off_npcs[map].monsters) do
				if off_npcs[map].monsters[a] then
					local monster = alife():object(off_npcs[map].monsters[a].id)
					if monster and monster.health and monster.can_switch_online and monster:can_switch_online() and monster:name() == off_npcs[map].monsters[a].name and victim.position:distance_to(monster.position)<look_radius then
						if monster:health()>0 then
							table.insert(vdata.monsters, {id = monster.id, name = monster:name()})
						else
							if (sobj_is_far(monster, to_actor)) then
								table.insert(vdata.corpses.monsters, {id = monster.id, name = monster:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список артов в зоне "видимости"
	vdata.artefacts={}
	if off_npcs[map].artefacts then
		if table.getn(off_npcs[map].artefacts)>0 then
			for a=1,table.getn(off_npcs[map].artefacts) do
				if off_npcs[map].artefacts[a] then
					local artefact = alife():object(off_npcs[map].artefacts[a].id)
					if (artefact and artefact.can_switch_online and artefact:can_switch_online() and artefact:name() == off_npcs[map].artefacts[a].name and victim.position:distance_to(artefact.position)<look_radius and sobj_is_far(artefact, to_actor)) then
						if artefact.parent_id==nil or artefact.parent_id==65535 or (alife():object(artefact.parent_id) and (alife():object(artefact.parent_id):section_name()=="inventory_box" or (alife():object(artefact.parent_id):clsid()>172 and alife():object(artefact.parent_id):clsid()<180))) then
							table.insert(vdata.artefacts, {id = artefact.id, name = artefact:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем список контейнеров в зоне "видимости"
	vdata.inv_boxes={}
	if off_npcs[map].inv_boxes then
		if table.getn(off_npcs[map].inv_boxes)>0 then
			for a=1,table.getn(off_npcs[map].inv_boxes) do
				if off_npcs[map].inv_boxes[a] then
					local inv_box = alife():object(off_npcs[map].inv_boxes[a].id)
					if (inv_box and inv_box.can_switch_online and inv_box:can_switch_online() and inv_box:name() == off_npcs[map].inv_boxes[a].name and victim.position:distance_to(inv_box.position)<=look_radius_box and sobj_is_far(inv_box, to_actor)) then
						local zdist = victim.position:distance_to(inv_box.position)/100
						if math.random() > zdist then
							if inv_box.parent_id==nil or inv_box.parent_id==65535 then
								table.insert(vdata.inv_boxes, {id = inv_box.id, name = inv_box:name()})
							end
						end
					end
				end
			end
		end
	end

	return vdata
end

-- получаем отношение группировки к неписю, в оффлайне фактически равно личным отношениям неписей
function relation_check(victim,opponent)
	if relation_matrix[opponent:community()] and relation_matrix[opponent:community()][victim:community()] then
		return relation_matrix[opponent:community()][victim:community()]
	else
		return 0
	end
end

-- Вокруг враги! Что же делать..
function on_enemies_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found enemy ("..table.getn(vdata.enemies)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	-- Собираем weapons
	-- Учитываем rank, weapon, distance...
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
	if (vdata.friends and table.getn(vdata.friends) > 0) then
		for i=1, table.getn(vdata.friends) do
			v_obj = vdata.friends[i]
			if v_obj then
				obj = alife():object(v_obj.id)
				if (obj and obj:name()==v_obj.name) then
					wpn = get_npc_weapon(obj)
					rank = obj:rank()
					health = obj:health()
					firepower = get_weapon_firepower(wpn)
					player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
					table.insert(team_A, player)
				end
			end
		end
	end
	for i=1, table.getn(vdata.enemies) do
		v_obj = vdata.enemies[i]
		obj = alife():object(v_obj.id)
		if (obj and obj:name() == v_obj.name) then
			wpn = get_npc_weapon(obj)
			if (wpn == nil) then
				list_npc_items(obj)
			end
			rank = obj:rank()
			health = obj:health()
			firepower = get_weapon_firepower(wpn)
			player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
			table.insert(team_B, player)
		end
	end
	local distances = {}
	for a=1, table.getn(team_A) do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, table.getn(team_B) do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math.floor(from.position:distance_to(to.position))
				local fp_A = math.floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math.floor(team_B[b].firepower / (dist / dist_coeff))
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	-- Берем тех, у кого самый высокий rank и мин. distance
	table.sort(team_A, function(a,b) return a.rank > b.rank end)
	table.sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = table.getn(team_A)
	local size_B = table.getn(team_B)
	local died_A = 0
	local died_B = 0
	for i=1, max_rounds do
		if (table.getn(team_A) >0 and table.getn(team_B) > 0) then
			local index = table.getn(team_A)
			local attacker
			local defender 
			local attack_info 
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance			
			if (table.getn(team_B) > index) then index = table.getn(team_B) end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math.random(table.getn(team_B))]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					--amk.mylog(attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					-- master to novice - 30% max
					-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
					rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
					distance_hit_chance = 100 - math.floor((attack_info.distance) / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math.random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if (attack_info.fp >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp)
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if (defender.flags >= 2) then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if (IsStalker(attacker.player) and attacker.player.community) then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base * coeff))
									end
								end
								amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and table.getn(items[defender.player.id]) > 0) then
									amk.mylog("В трупе "..defender.player:name().." "..table.getn(items[defender.player.id]).." вещичек.")
									for a=1,table.getn(items[defender.player.id]) do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = alife():object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end
											end	
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						--amk.mylog(attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						--amk.mylog(attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math.random(table.getn(team_A))]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						--amk.mylog(attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Попал или нет? Зависит от: расстояния, рангов
						-- master to novice - 30% max
						-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
						rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
						distance_hit_chance = 100 - math.floor((attack_info.distance) / 1.5)					
						hit_chance = distance_hit_chance + rank_hit_chance
						if math.random() * 100 < hit_chance then
							-- Попал таки, гад. Посмотрим, как сильно.
							if attack_info.fp >= base_fp then
								-- Все, убил.
								defender.health = 0
							else
								defender.health = defender.health - (attack_info.fp / base_fp)
								if (defender.health < 0 ) then defender.health = 0 end
							end
							if (defender.health <= 0) then
								if (defender.flags >= 2) then
									defender.health = health_wound
								else								
									-- Если сталкер - дадим опыт.
									if (IsStalker(attacker.player) and attacker.player.community) then
										local m_comm  = attacker.player:community()
										if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
											-- Будет теперь опытным.
											local coeff = 1
											if (defender.rank < attacker.rank) then coeff = 0.5 end
											if (defender.rank > attacker.rank) then coeff = 2 end
											attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base * coeff))							
										end
									end
									amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
									news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
									-- Заберем вещички с трупа
									local itB, v_itB
									local l_objB
									if (items[defender.player.id] and table.getn(items[defender.player.id]) > 0) then
										amk.mylog("В трупе "..defender.player:name().." "..table.getn(items[defender.player.id]).." вещичек.")
										for a=1,table.getn(items[defender.player.id]) do
											v_itB = items[defender.player.id][a]
											if (v_itB) then
												itB = alife():object(v_itB.id)
												if (itB and itB:name() == v_itB.name and itB.parent_id == defender.player.id) then
													l_objB = pick_item(attacker.player, itB)
												else
													if(itB) then
														local mm = itB.parent_id
														if mm == nil then mm = "nil" end
														amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itB:name().." parent_id="..mm)													
													end
												end
											end
										end
									end
									process_trade(attacker.player)
								end
							end
							--amk.mylog(attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
						else
							--amk.mylog(attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				amk.mylog("Участник команды А погиб. "..vv.player:name())			
				table.remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				amk.mylog("Участник команды А ранен. "..vv.player:name())
				news_main.on_offline_wound(vv.player)
				table.remove(team_A, kk)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				amk.mylog("Участник команды B погиб. "..vv.player:name())
				table.remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				amk.mylog("Участник команды B ранен. "..vv.player:name())
				news_main.on_offline_wound(vv.player)
				table.remove(team_B, kk)
			end
		end		
	end
	amk.mylog("Бой закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- Вокруг монстры! Что же делать..
function on_monsters_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found monsters ("..table.getn(vdata.monsters)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
		--amk.add_spot_on_map(victim.id,"red_location", s)
	end
	-- Собираем комманды.
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
	if (vdata.friends and table.getn(vdata.friends) > 0) then
		for i=1, table.getn(vdata.friends) do
			v_obj = vdata.friends[i]
			obj = alife():object(v_obj.id)
			if (obj and obj:name()==v_obj.name) then
				wpn = get_npc_weapon(obj)
				rank = obj:rank()
				health = obj:health()
				firepower = get_weapon_firepower(wpn)
				player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
				table.insert(team_A, player)
			end
		end
	end
	local params
	for i=1, table.getn(vdata.monsters) do
		v_obj = vdata.monsters[i]
		obj = alife():object(v_obj.id)
		if (obj and obj:name() == v_obj.name) then
			params = get_monster_params(obj)
			if (params) then
				rank = obj:rank()
				health = obj:health()
				firepower = params.attack * base_fp
				player = {player = obj, speed = params.speed, attack_dist = params.dist, immunity = params.immunity, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id) }
				table.insert(team_B, player)
			else
				amk.mylog("get_monster_params returns nil for "..obj:name())
		end
	end
	end
	local distances = {}
	for a=1, table.getn(team_A) do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, table.getn(team_B) do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math.floor(from.position:distance_to(to.position))
				local fp_A = math.floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math.floor(team_B[b].firepower)
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	-- Берем тех, у кого самый высокий rank и мин. distance
	table.sort(team_A, function(a,b) return a.rank > b.rank end)
	table.sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = table.getn(team_A)
	local size_B = table.getn(team_B)
	local died_A = 0
	local died_B = 0
	for i=1, max_rounds do
		if (table.getn(team_A) >0 and table.getn(team_B) > 0) then
			local index = table.getn(team_A)
			local attacker
			local defender
			local attack_info
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance
			if (table.getn(team_B) > index) then index = table.getn(team_B) end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math.random(table.getn(team_B))]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					amk.mylog(attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
					local dii = math.floor(attack_info.distance - defender.speed * i * 5)
					if (dii <=8) then dii = 45 end -- Вблизи еще и фиг попадешь...
					distance_hit_chance = 100 - math.floor(dii / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math.random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if ( math.floor(attack_info.fp * defender.immunity) >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp) * defender.immunity
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if defender.flags >= 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if (IsStalker(attacker.player) and attacker.player.community) then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base * coeff))
									end
								end
								amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and table.getn(items[defender.player.id]) > 0) then
									amk.mylog("В трупе "..defender.player:name().." "..table.getn(items[defender.player.id]).." вещичек.")
									for a=1,table.getn(items[defender.player.id]) do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = alife():object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end											
											end			
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						--amk.mylog(attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						--amk.mylog(attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math.random(table.getn(team_A))]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						amk.mylog(attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Для начала неплохо бы узнать, добежал ли монстрик до дистанции атаки.
						if (attack_info.distance - attacker.speed * i * 5 < attacker.attack_dist) then
							rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
							distance_hit_chance = 100
							hit_chance = distance_hit_chance + rank_hit_chance
							if math.random() * 100 < hit_chance then
								-- Попал таки, гад. Посмотрим, как сильно.
								if attack_info.fp >= base_fp then
									-- Все, убил.
									defender.health = 0
								else
									defender.health = defender.health - (attack_info.fp / base_fp)
									if (defender.health < 0 ) then defender.health = 0 end
								end
								if (defender.health == 0) then
									if defender.flags >= 2 then
										defender.health = health_wound
									else
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", nil")
										news_main.on_offline_death(defender.player, attacker.player, nil)
										-- Забитрать вещички с трупа не будем. Хотя, может некоторые клептоманы...
										-- А вот труп грохнуть... Надо подумать :)
									end
								end
								--amk.mylog(attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
							else
								--amk.mylog(attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
							end
						else
							amk.mylog(attacker.player:name().." [team_B] еще не добежал "..(attack_info.distance - attacker.speed * i * 5).." метров до "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				amk.mylog("Участник команды А погиб. "..vv.player:name())			
				table.remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				amk.mylog("Участник команды А ранен. "..vv.player:name())
				news_main.on_offline_wound(vv.player)
				table.remove(team_A, kk)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				amk.mylog("Участник команды B погиб. "..vv.player:name())
				table.remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				amk.mylog("Участник команды B ранен. "..vv.player:name())
				news_main.on_offline_wound(vv.player)
				table.remove(team_B, kk)
			end
		end		
	end	
	amk.mylog("Бой с монстрами закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- О, трупик. Щас шмонать будем.
function on_npc_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.stalkers == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found stalker's corpse ("..table.getn(vdata.corpses.stalkers)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local id
	local v_id = victim.id
	for i=1, table.getn(vdata.corpses.stalkers) do
		v_obj = vdata.corpses.stalkers[i]
		local corpse = alife():object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)
			id = corpse.id
			if (id and items[id]) then
				for a=1, table.getn(items[id]) do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = alife():object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, трупик монстра. Будем шмонать?
function on_monster_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.monsters == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found monster's corpse ("..table.getn(vdata.corpses.monsters)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local object
	local id
	local v_id = victim.id
	for i=1, table.getn(vdata.corpses.monsters) do
		v_obj = vdata.corpses.monsters[i]
		local corpse = alife():object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)		
			id = corpse.id
			if (id and items[id]) then
				for a=1, table.getn(items[id]) do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = alife():object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- Хорошая пушка - не помешает.
function on_weapons_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found weapons ("..table.getn(vdata.weapons.seen)..") for "..victim.id.." on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local object
	local v_id = victim.id
	for i=1, table.getn(vdata.weapons.seen) do
		v_obj = vdata.weapons.seen[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
			end
		end
	end
	process_trade(victim)
end

-- Моя прелесссть
function on_artifacts_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if (IsStalker(victim) and victim.community) then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, table.getn(vdata.artefacts) do
		v_obj = vdata.artefacts[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
				if (obj) then
					if (b_stalker == true) then
						victim:set_rank(victim:rank() + rate_art_found)
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, нычка - это гуд.
function on_inv_boxes_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if (IsStalker(victim) and victim.community) then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, table.getn(vdata.inv_boxes) do
		v_obj = vdata.inv_boxes[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				if items[v_obj.id] and table.getn(items[v_obj.id])>0 then
					for a=1,table.getn(items[v_obj.id]) do
						local v_itA = items[v_obj.id][a]
						if (v_itA) then
							local itA = alife():object(v_itA.id)
							if (itA and itA:name()==v_itA.name and itA.parent_id == v_obj.id) then
								--news_main.trace("on_inv_boxes_found - found "..itA:section_name().." in "..object:name())
								-- Решим, подбираем или нет?
								local bTake = is_valuable(itA)
								if bTake then
									local l_objA = pick_item(victim, itA)
								end
							else
								if(itA) then
									local mm = itA.parent_id
									if mm == nil then mm = "nil" end
									amk.mylog("В контейнере "..object:name().." странная вещичка - "..itA:name().." parent_id="..mm)
								end											
							end			
						end
					end					
				end
			end
		end
		if (b_stalker == true) then
			victim:set_rank(victim:rank() + rate_art_found)
		end
	end
	process_trade(victim)
end

function pick_item(npc, obj)
	local new = nil
	if (npc and obj and db.actor and obj.id ~= db.actor:id()) then
		local section = obj:section_name()
		new = alife():create(section, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
		if (new) then
			if (new.parent_id) then
				if not items[new.parent_id] then items[new.parent_id] = {} end
				table.insert(items[new.parent_id], {id = new.id, name = new:name()})
	gps_habar.insert_item(new.parent_id, new) -- Idler++-- корректируем хабар в помеченных тайниках
			end
			if (obj.parent_id and items[obj.parent_id] and table.getn(items[obj.parent_id])>0) then
				for z=1, table.getn(items[obj.parent_id]) do
					if (items[obj.parent_id][z] and items[obj.parent_id][z].id == obj.id) then
						table.remove(items[obj.parent_id], z)
	gps_habar.remove_item(obj.parent_id, items[obj.parent_id][z]) -- Idler++-- корректируем хабар в помеченных тайниках
						break
					end
				end
			end
			alife():release(alife():object(obj.id), true)
		end
	end
	return new
end

function get_npc_weapon(npc)
	local obj = nil
	local fp = 0
	if (npc) then
		for k,v in pairs(items[npc.id]) do
			local wpn = alife():object(v.id)
			if wpn and isWeapon(wpn) and wpn:name() == v.name and wpn.parent_id == npc.id then
				local cur_fp = get_weapon_firepower(wpn)
				if cur_fp > fp then
					fp = cur_fp
					obj = wpn
				end			
			end
		end
	end
	return obj
--[[
		local map = news_main.get_object_levelname(npc)
		if (map and off_npcs[map]) then
			local wp = table.getn(off_npcs[map].weapons)
			if wp>0 then
				for w=1,wp do
					if off_npcs[map].weapons[w] then
						local www = alife():object(off_npcs[map].weapons[w].id)
						if www and www.parent_id == npc.id and isWeapon(www) then
							local cur_fp = get_weapon_firepower(www)
							if cur_fp > fp then
								fp = cur_fp
								obj = www
							end
						end
					end
				end
			end
		end
	end
	return obj
]]	
end

function get_weapon_firepower(wpn)
	local result = 0
	if (wpn and isWeapon(wpn)) then
		local sect = wpn:section_name()
		if not (sect == "grenade_f1" or sect == "grenade_rgd5") then
			--local fd = utils.cfg_get_number(system_ini(), wpn:section_name(), "fire_distance", wpn, false, 1)
			--local bs = utils.cfg_get_number(system_ini(), wpn:section_name(), "bullet_speed", wpn, false, 1)
			--local rpm = utils.cfg_get_number(system_ini(), wpn:section_name(), "rpm", wpn, false, 1)
			local priority = utils.cfg_get_number(system_ini(), wpn:section_name(), "ef_weapon_type", wpn, false, 1)
			local priority2 = utils.cfg_get_number(system_ini(), wpn:section_name(), "ef_main_weapon_type", wpn, false, 0)
			local GetRPM = ui_wpn_params.GetRPM(wpn:section_name())
			local GetDamage = ui_wpn_params.GetDamage(wpn:section_name())
			local GetHandling = ui_wpn_params.GetHandling(wpn:section_name())
			local GetAccuracy = ui_wpn_params.GetAccuracy(wpn:section_name())
			local fp = 1
			if priority>1 and priority2>0 then
				priority = priority + priority2
			end
			--fp = priority*1000 + math.sqrt(fd*bs*rpm)		
			fp = math.ceil(priority * 1000 + GetAccuracy * 100 + GetRPM * 3 + GetDamage * 8) - 5000
			if GetHandling >= 99 then
				fp = fp + 1500
			end
			result = fp
			if wpn_fp[wpn:section_name()] == nil then
				wpn_fp[wpn:section_name()] = {frp = fp, p = priority, rpm = GetRPM, dam = GetDamage, acc = GetAccuracy, han = GetHandling}
			end
		end
	end
	return result
end

function get_weapon_cost(weapon)
	local result = 0
	if (weapon and isWeapon(weapon)) then
		result = utils.cfg_get_number(system_ini(), weapon:section_name(), "cost", weapon, false, 0)
	end
	return result
end

function get_item_cost(item)
	local result = 0
	if (item and item.section_name) then
		result = utils.cfg_get_number(system_ini(), item:section_name(), "cost", item, false, 0)
	end
	return result
end

function list_npc_items(obj)
	if (obj) then
		amk.mylog("list_npc_items - "..obj:name()..":")
		local it
		local find = 0
		for a=1,65534 do
			it = alife():object(a)
			if (it and it.parent_id == obj.id) then
				amk.mylog("list_npc_items - "..it:name().." "..it:section_name())
				if (_g.isWeapon(it)) then
					find = it.id
				end
			end			
		end
	end
end

function dbg_show_team(team)
	if(team) then
		for k, player in pairs(team) do
			if (player.weapon) then
				mylog("Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon="..player.weapon:name().." firepower="..player.firepower)
			else
				mylog("Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon=none firepower="..player.firepower)
			end
		end
	end
end

--[[
	Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.	
	Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
	Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class + item_dependence
	Оставили одно, которое лучше (а), но патронов нет (б) (%)
	Одно, которое лучше (а), но хуже (б) - в новости на продажу
	Остальное на продажу
	Патроны оставили только те, что подходят к (а), остальные на продажу
	Для вояк - только родной калаш надо бы... Не продавать вобще?
	Оставляем не более 2 аптечек и бинтов, антирада
	Оставляем 1-2 гранаты (%)
	Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
	Еда, водка - не более 1-2 шт (%)	
	Броники наверное продаем...
	Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
]]
function process_trade(npc)	
	local item_list = {}
	local sell_list = {}
	-- Имеет смысл проверять на наличие trade в секции [logic]...
	if npc and IsStalker(npc) and npc:alive() and npc.m_story_id~=nil and npc.m_story_id == 4294967296 and items[npc.id] and table.getn(items[npc.id])>0 then
		local m_comm = npc:community()
		local b_stalker = false		
		if (m_comm == "actor" or m_comm == "actor_dolg" or m_comm == "actor_freedom" or m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			if (npc.name and npc:name() ~= "agr_ratcatcher") then
				b_stalker = true
			end
		elseif m_comm == "zombied" then
			return
		end
			
		--Фильтруем квестовые items - always_keep_item, sell_table	
		local obj, v_obj
		for ok,ov in pairs(items[npc.id]) do
			obj = alife():object(ov.id)
			if obj and obj:name()==ov.name then
				if always_keep_item[obj:section_name()] or sell_table[obj:section_name()] == nil then
					-- Это нам не надо.
					--news_main.trace("Process_trade: "..npc:name().." ["..m_comm.."] filtered "..obj:section_name().." ["..obj:name().."]")
				else
					table.insert(item_list, obj)
					--item_list[v.id] = obj
					--news_main.trace("Process_trade: "..npc:name().." ["..m_comm.."] have "..obj:section_name().." ["..obj:name().."]")
				end
			end
		end
		if item_list and table.getn(item_list)>0 then
			--news_main.trace("Process_trade: "..npc:name().." ["..m_comm.."] have "..tostring(table.getn(item_list)).." items.")
			table.sort(item_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)		
			-- Выберем, что за оружие оставит себе NPC.
			local cnt_medkit = 0
			local cnt_antirad = 0
			local cnt_bandage = 0
			local cnt_grenade = 0
			local cnt_food = 0
			local cnt_drink = 0
			local cnt_torch = 0
			local cnt_pda = 0
			local cnt_radio = 0
			local cnt_guitar = 0
			local cnt_harmonica = 0
			local cnt_binocular = 0
			local cnt_knife = 0
			local cnt_arts = 0
			local cnt_detector = 0
			local cnt_addons = 0
			local cnt_mparts = 0
			
			local weapons = {}
			local ammo = {}
			for k,v in pairs(item_list) do			
				local sect = v:section_name()
				--news_main.trace("Process_trade: first pass - "..npc:name().." ["..m_comm.."] have "..sect.." ["..v:name().."]")
				if isWeapon(v) and not (sect == "grenade_f1" or sect == "grenade_rgd5" or sect == "wpn_knife") then
					local bOk = false
					if m_comm == "military" then
						if sect == "wpn_ak74_n" or sect =="wpn_ak74u_n1" or sect =="wpn_abakan_n" or sect =="wpn_pm_bas" or sect =="wpn_korth" or sect =="wpn_val_tac" or sect =="wpn_walther_p99" or sect =="wpn_svu" or sect =="wpn_sig550_siber" or sect =="wpn_fn2000" or sect =="wpn_vintorez_isg" or sect =="wpn_groza" then
							bOk = true
						end
					else
						bOk = true
					end
					if bOk == true then
						local ac = utils.cfg_get_string(system_ini(), sect, "ammo_class", v, false, "")
						if ac and ac ~= "" then
							local vvv = amk.str_explode(",", ac, true)
							local ammo_classes = {}
							for ak,av in pairs(vvv) do
								table.insert(ammo_classes, av)
							end
							table.insert(weapons, {obj = v, ammo = ammo_classes})
						else
							table.insert(weapons, {obj = v, ammo = nil})
						end
					end
				elseif string.find(sect, "^ammo_") then
					if ammo[sect] == nil then 
						ammo[sect] = 1
					else
						ammo[sect] = ammo[sect] + 1
						if ammo[sect] > 2 then
							table.insert(sell_list, v)
						end
					end
				elseif string.find(sect, "^af_") then
					-- 3 самых хороших арта оставили себе (+здоровье), остальные на продажу (фильтруем булыжник)				
					if sect ~= "af_buliz" then
						cnt_arts = cnt_arts + 1
						if cnt_arts > 3 then
							table.insert(sell_list, v)
						end				
					end
				elseif sect == "device_torch" then
					cnt_torch = cnt_torch + 1
					if cnt_torch > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "device_pda" then
					cnt_pda = cnt_pda + 1
					if cnt_pda > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "hand_radio" then
					cnt_radio = cnt_radio + 1
					if cnt_radio > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "harmonica_a" then
					cnt_harmonica = cnt_harmonica + 1
					if cnt_harmonica > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "guitar_a" then
					cnt_guitar = cnt_guitar + 1
					if cnt_guitar > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "binocular_a" or sect == "wpn_binoc" then
					cnt_binocular = cnt_binocular + 1
					if cnt_binocular > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "wpn_knife" then
					cnt_knife = cnt_knife + 1
					if cnt_knife > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "medkit" or sect == "medkit_army" or sect == "medkit_scientic" then
					cnt_medkit = cnt_medkit + 1
					if cnt_medkit > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "antirad" then
					cnt_antirad = cnt_antirad + 1
					if cnt_antirad > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "bandage" then
					cnt_bandage = cnt_bandage + 1
					if cnt_bandage > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "grenade_f1" or sect == "grenade_rgd5" then
					cnt_grenade = cnt_grenade + 1
					if cnt_grenade > 2 then
						table.insert(sell_list, v)
					end
				elseif sect == "bread_a" or sect =="bread" or sect == "kolbasa" or sect == "kolbasa_a" or sect == "conserva" then
					cnt_food = cnt_food + 1
					if cnt_food > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "vodka_a" or sect =="vodka" or sect == "energy_drink" then
					cnt_drink = cnt_drink + 1
					if cnt_drink > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "detector_simple" or sect =="detector_advances" or sect == "detector_elite" then
					cnt_detector = cnt_detector + 1
					if cnt_detector > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "pso" or sect =="susat" or sect == "wpn_addon_silencer" or sect == "wpn_addon_grenade_launcher" or sect == "wpn_addon_grenade_launcher_m203" then
					cnt_addons = cnt_addons + 1
					if cnt_addons > 2 then
						table.insert(sell_list, v)
					end
				elseif sect =="mutant_flesh_eye" or sect == "mutant_boar_leg" or sect =="mutant_dog_tail" or sect == "mutant_psevdodog_tail" or sect =="mutant_krovosos_jaw" or sect == "mutant_burer_hand" or sect =="mutant_zombie_hand" or sect == "mutant_snork_leg" then
					cnt_mparts = cnt_mparts + 1
					if cnt_mparts > 2 then
						table.insert(sell_list, v)
					end
				else
					news_main.trace("Process trade - unknown - "..sect.." "..v:name())
				end			
			end
			table.sort(weapons, function(a,b) return get_weapon_firepower(a.obj) > get_weapon_firepower(b.obj) end)
			-- Так, теперь у нас отсортированны все пушки НПС. Найдем ту, для которой есть патроны...
			-- А вот воякам надо оставить бы их АКшники...? (wpn_ak74_n, wpn_ak74u_n1, wpn_abakan_n, wpn_pm_bas, wpn_korth, wpn_val_tac, wpn_walther_p99, wpn_svu, wpn_sig550_siber, wpn_fn2000, wpn_vintorez_isg, wpn_groza)
			local b_self = false
			local b_best = false
			local s_self = ""
			for k, v in pairs(weapons) do
				--news_main.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] weapons "..v.obj:section_name().." ["..v.obj:name().."] "..get_weapon_firepower(v.obj))
				local b_ammo = false
				local vac = v.ammo
				if vac and table.getn(vac)>0 then
					for kk, vv in pairs(vac) do
						if ammo[vv] and ammo[vv] > 0 then -- Так, патроны есть.
							b_ammo = true
							break
						end
					end
				end
				if b_self == false and b_ammo == true then
					b_self = true
					--news_main.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] SELF weapon is  "..v.obj:section_name().." ["..v.obj:name().."]")
					s_self = v.obj:section_name()
				elseif b_best == false then
					if s_self ~= "" then
						if v.obj:section_name() ~= s_self then
							b_best = true
							--news_main.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] BEST weapon is  "..v.obj:section_name().." ["..v.obj:name().."]")
						else
							table.insert(sell_list, v.obj)
						end
					else
						b_best = true
						--news_main.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] BEST weapon is  "..v.obj:section_name().." ["..v.obj:name().."]")
					end
				else
					table.insert(sell_list, v.obj)
				end
			end
			-- Так, с оружием закончили...
			-- Все, что осталось - надо продать.
			-- 1 самое дорогое можно попробовать через новости...
			item_list = nil
			local money = 0
			if sell_list and table.getn(sell_list)>0 then
				table.sort(sell_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)		
				local zz = sell_list[1]
				if zz and b_stalker == true and (get_item_cost(zz) >= sell_limit) then
					-- Продадим через новости.
					--news_main.trace("Offline: "..npc:name().." собирается продать через новости "..zz:name())
					--amk.mylog("Offline: "..npc:name().." собирается продать через новости "..vv:name())
					news_main.on_offline_trade(npc, zz)
					table.remove(sell_list, 1)
				end
			end
			for kk,vv in pairs(sell_list) do
				--news_main.trace("Process_trade: final pass - "..npc:name().." ["..m_comm.."] sells "..vv:section_name().." ["..vv:name().."]")
				local cost = get_item_cost(vv)
				if (cost > 0) then
					s_name = utils.cfg_get_string(system_ini(), vv:section_name(), "inv_name", vv, false, "", "")
					if (s_name == nil) then s_name = "" end
					s_name = game.translate_string(s_name)
					local coeff = math.random(30,50) / 100
					local price = math.floor(cost * coeff)
					money = money + price
					--news_main.trace("Offline: "..npc:name().." продает "..s_name.." ["..vv:name().."] торговцу за "..price)
					--amk.mylog("Offline: "..npc:name().." продает "..s_name.." ["..vv:name().."] торговцу за "..price)
					-- Почистим items
					if (items[npc.id] and table.getn(items[npc.id])>0) then
						for z=1, table.getn(items[npc.id]) do
							if (items[npc.id][z] and items[npc.id][z].id == vv.id) then
								table.remove(items[npc.id], z)
					gps_habar.remove_item(npc.id, items[npc.id][z]) -- Idler++-- корректируем хабар в помеченных тайниках
								break
							end
						end
					end
					alife():release(alife():object(vv.id), true)
				end				
			end
		end
		--news_main.flushlog()
	end
end

-- Строим таблицы, если надо.
-- В них - макс. скорость, сила атаки, дистанция атаки.
-- Не забываем про иммунитеты.
-- Поучаем immunities_sect
-- В immunities_sect читаем fire_wound_immunity. Все повреждения множим на него.
function get_monster_params(obj)
	if (obj and IsMonster(obj)) or (obj and obj.community and obj:community()=="zombied") then
		if (monster_params and monster_params[obj:section_name()]) then
			return monster_params[obj:section_name()]
		else
			local speed 	= utils.cfg_get_number(system_ini(), obj:section_name(), "MaxSpeed", obj, false, 5)
			local dist 		= utils.cfg_get_number(system_ini(), obj:section_name(), "MaxAttackDist", obj, false, 3)
			local imm_sect 	= utils.cfg_get_string(system_ini(), obj:section_name(), "immunities_sect", obj, false, "", "")
			local immunity 	= utils.cfg_get_number(system_ini(), imm_sect, "fire_wound_immunity", obj, false, 1)
			local att_sect 	= utils.cfg_get_string(system_ini(), obj:section_name(), "attack_params", obj, false, "", "") 
			local attack	= 0
			if (system_ini():section_exist(att_sect)) then
				local result, id, value = nil, nil, nil
				local max_attack = 0
				for a=0, system_ini():line_count(att_sect)-1 do
					result, id, value = system_ini():r_line(att_sect,a,"","")
					if id~=nil and trim(id)~="" and trim(id)~=nil and value~=nil then
						local m_value = amk.str_explode(",", amk.trim(value), true)
						if (m_value and table.getn(m_value)>2) then
							local v = tonumber(m_value[2])
							if (v and v > max_attack) then					
								max_attack = v
							end
						end
					end
				end
				attack = max_attack
			end
      amk.mylog("speed for "..obj:section_name().." is "..tostring(speed))
			monster_params[obj:section_name()] = {speed = speed, dist = dist, immunity = immunity, attack = attack}
			return monster_params[obj:section_name()]			
		end
	else
		return nil
	end
end

function sobj_is_far(obj, distance)
	local result = true
	if (db.actor and obj and distance and obj.position and db.actor.position ) then
		-- на одном ли уровне?
		if obj.m_game_vertex_id and game_graph():valid_vertex_id(obj.m_game_vertex_id) then
		local map = alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
		if (map and level.name() == map) then
			-- Достаточно ли далеко?
			if (obj.position:distance_to(db.actor:position()) < distance) then
				result = false
			end
		end
   end
   end
   return result
end

function game_minutes()
	local gtime = level.get_time_days()*60*24+level.get_time_hours()*60+level.get_time_minutes()  --time in game minutes
	return gtime
end

function have_ammo(npc, weapon)
	local result = false
	if npc and weapon and IsStalker(npc) and isWeapon(weapon) then
		local ammo_str = utils.cfg_get_number(system_ini(), weapon:section_name(), "ammo_class", weapon, false, "")
		if ammo_str=="" then -- Болт или граната
			return false
		end
		local ammo_list = parse_names(ammo_str)
		for k, v in items[npc.id] do
			if string.find(obj:section_name(),"^ammo_") then
			end
			--if v:section_name() == 
		end
	end
	return result
end

function box_is_protected(v)
	if v then
		for k, o in pairs(protected) do
			if type(o)=="number" and v.m_story_id then
				if o == v.m_story_id then return true end
			elseif type(o)=="string" then
				if o == v:name() then return true end
			end
		end
	end
	return false
end

function npc_smart_is_peaceful(sobj)
	local result = false
	if (sobj and smart_filters and table.getn(smart_filters)>0) then
		if (sobj.smart_terrain_id and sobj:smart_terrain_id() and sobj:smart_terrain_id()~=65535) then
			local sm = alife():object(sobj:smart_terrain_id())
			if (sm and sm.name and sm:name()) then
				local sn = sm:name()
				for ks, vs in pairs(smart_filters) do
					if (vs == sn) then
						-- Ага, он у нас мирный.
						result = true
						break
					end
				end
			end
		end
	end
	return result
end

function on_death(npc_id)
	smart_terrain.on_death( npc_id )
end

function get_flags(npc_id)
	local flags = 0
	local obj = alife():object(npc_id)
	if obj then
		if IsMonster(obj) or IsStalker(obj) then
			local char_ini = xr_logic.get_customdata_or_ini_file(obj, "<customdata>")
			if char_ini:section_exist("logic") then
				local from = ""
				local items = ""
				if char_ini:line_exist("logic", "on_hit") then
					flags = 1
				end
				if char_ini:line_exist("logic", "on_death") then
					flags = flags + 2
				end
			end
		end
	end
	return flags
end

function is_valuable(item)
	local result = false
	if item and not (IsMonster(item) or IsStalker(item)) then
		-- Уники не подбираем (пока?)
		if always_keep_item[item:section_name()] or sell_table[item:section_name()] == nil then
			return false
		end
		local cost = get_item_cost(item)
		if isWeapon(item) and cost >= 1000 then
			result = true
		elseif cost >= 800 then
			result = true
		end
	end
	return result
end
