-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- File:  amk_mod .script
-- copyright © AMK TEAM 2007-2008
--
-- добавлена  fenechka by TAG

function attach( sm )
  sm:subscribe({ signal = "on_drop",         fun = this.on_drop })
  sm:subscribe({ signal = "on_use",         fun = this.check_sleep_item })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_actor_spawn    })
end

function on_actor_spawn()
  if db.actor:has_info( "blowout" ) then
    on_blowout_hit_actor()
    blowout_phantoms()
  end
  if level.name() == "l10_radar" then
    if not has_alife_info( "esc_serious_talk" ) then
      ogse_signals.get_mgr():subscribe({
        signal = "on_update", fun = this.check_radar_off,
        script_name = script_name(),
      })
    end
  end
end

function on_drop(obj)
check_for_af_drop(obj)
end

local afs = {}
-- аномалия "узнаётся" по части названия!
-- komp - компонентv
-- удача v_udachi + вvрождение в булvжник v_virogd <= 100 !!!
-- отторжение v_ottorg = 100 - (v_udachi + v_virogd) посему и не нужно прописvвать в таблицу
-- cel - цель (может бvть одновременно несколько целей)
-- info - инфопорция, которая будет вvдана после L-L+=+Ј варки
-- virogd - во что вvрождается (может бvть одновременно несколько вvрождений)
-- vremya = {дни, часы, минуты} - время варки/мутации
-- remove_anomaly - удалить ли аномалию (можно комбинировать вместе с варкой/мутацией)
-- not_for_mutator - рецепт никогда не попадёт в трансмутатор
anom_recept_komp = {}


local math_random = math.random
local math_floor = math.floor
local math_pi = math.pi
local math_sin = math.sin
local math_cos = math.cos
local math_ceil = math.ceil
local string_find = string.find
local string_sub = string.sub

local nrg,med,cnt,gv,lv,w
in_hide=false
local sound_obj_right,sound_obj_left,snd_volume,snd_obj_eq
local sync_done=false
local dynlasthour
zombied={}

local weather_types={
        l01_escape=1,
        l02_garbage=1,
        l03_agroprom=1,
        l03u_agr_underground=1,
        l04_darkvalley=1,
        l04u_labx18=1,
        l05_bar=1,
        l06_rostok=1,
        l07_military=1,
        l08_yantar=1,
        l08u_brainlab=1,
        l10_radar=1,
        l10u_bunker=1,
        l11_pripyat=1,
        l12_stancia=1,
        l12_stancia_2=1,
        l12u_control_monolith=1,
        l12u_sarcofag=1
}

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        FIRST_RUN          **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
-- Эта функция вызывается первой. Онлайновые объекты недоступны! db.actor недоступен!
function on_game_start()
	math.randomseed (device ():time_global ())
end
local tmp_intro=false
function first_run() 
  -- На момент вызова этой функции актор уже доступен - переделано на поршень.
  if has_alife_info( "x_first_run" ) then return end
  
		amk.spawn_item_in_inv("matras")
		amk.spawn_item("x18_zapiska_ruk",vector():set(21.6,-3.94,-18.28),1140,5991)
		amk.spawn_item("x16_zapiska_ruk",vector():set(-126.92,23.27,-36.98),1543,7083)
		local obj = alife():story_object(830)
		if obj then
			alife():release(obj)
			alife():create(6132)
		end		
		tmp_intro=true
		amk_anoms.pre_blow_off()
		amk_anoms.after_blow_on()
		spawn_military_btr()	
		spawn_fuel()
  dsh_alife.invalidate_items()

  db.actor:give_info_portion( "x_first_run" )
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **        CHECK_SPAWN          **   *
--'****************************************************************************

local weather_on_load

function check_spawn()
  amk_anoms.init()
	spawn_unspawned_respawners() 

  news_main.init()
  amk_offline_alife.update_trade()
  amk_offline_alife.update_npc_tables()

	if (amk_offline_alife) then
		amk_offline_alife.init()
	end
	if (amk_corpses) then
		amk_corpses.init()
	end
	if (amk_objects) then
		amk_objects.init()
	end
	local obj = alife():story_object(6000)
	if not obj then
		alife():create(6520)
		obj = alife():story_object(6000)
	end

	if amk.load_variable("freeplay",0)==1 then
		amk.save_variable("freeplay",2)
	elseif amk.load_variable("freeplay",0)==2 and (not has_alife_info("cit_fail_first_task")) then
		db.actor:give_info_portion("cit_fail_first_task")
	end
  
	if not db.actor:has_info("val_chase_start") then
		local objt = alife():story_object(6002)
		if objt then
			alife():release(objt)
		end
	end
	braad_test.delete_new_lc(833,"info_way_pripyat")
	braad_test.delete_new_lc(1007,"info_way_radar")
    --level_changers section
	local lname = level.name()
	local sname = amk.load_variable("level_on_save","")
	if (amk_corpses) then
		amk_corpses.update_all_corpses()
	end
	if lname ~= sname and amk_objects then 
		amk_objects.update() 
	end

	if lname=="l01_escape" and sname=="l04_darkvalley" then
		local obj = alife():story_object(6002)
		if not obj then
			alife():create(111)
		end
	end
  
	if sname=="l01_escape" and lname=="l04_darkvalley" then
		db.actor:set_actor_position(vector():set(-44.38, 0.43, -541.47))
	end
  
	--spots section
	obj = alife():story_object(6001)
	if obj then
		level.map_add_object_spot(obj.id, "level_changer", "to_pripyat")
	end
	obj = alife():story_object(6002)
	if obj then
		level.map_add_object_spot(obj.id, "level_changer", "to_darkvalley")
	end

	game.start_tutorial("restore_sun")
  restore_sun()
end


function restore_sun()
  -- level.set_weather( weather_on_load, true )
  local lname = level.name()
  local sname = amk.load_variable( "level_on_save", "" )
  amk.save_variable( "level_on_save", lname )
	if tmp_intro then
		amk.send_tip(game.translate_string("amk_welcome_msg"),game.translate_string("amk_welcome_title"),nil,35,"default")
		tmp_intro=false
	end
	sync_done=true	
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **         FREEPLAY           **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function freeplay()
	amk.save_variable("freeplay",1)
	
	local obj = alife():story_object(6001)
	if not obj then
		alife():create(6304)
	end

	for a=1,5 do
		amk_anoms.after_blow_on()
	end
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      SLEEP_AMK          **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function check_sleep_item(obj)
	local flagg = amk.load_variable("flagg")
	local section = obj:section()
	local stype=nil
	
	if section=="treasure_item" then
		stype="tr_item"
	end
 
	if stype~=nil then
		amk.start_timer("sleep_"..stype,0.1,obj:id())
	end
end

function test_for_need_sleep( add )
end

function test_for_need_sleep_tr_item(oid)
        if alife():object(oid)==nil then
            if news_main then
              news_main.create_treasurebox()
            end
        end
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **      RADAR_FIX         **   **   *
--'****************************************************************************


function check_radar_off()
  ogse_signals.get_mgr():reschedule( 1000 )
		if not has_alife_info("esc_serious_talk") then
			local pos = db.actor:position()
    if pos.z > 65 and pos.x > 350 and pos.x < 410 then
      if amk.load_variable( "radar_fix", 0 ) == 0 then
        level.add_pp_effector( "fire_hit.ppe", 1523, true )
        level.set_pp_effector_factor( 1523, 0.5 )
        amk.save_variable( "radar_fix", 1 )
        amk.start_timer( "radar_fix", 5 )
				end
			end
		end
	end


function radar_fix()
  level.remove_pp_effector( 1523 )
  local pos = db.actor:position()
  if pos.z > 65 and pos.x > 350 and pos.x < 410 then
    db.actor:kill( db.actor )
  end
  amk.del_variable( "radar_fix" )
end
--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      AF_TRANSFORM         **   **   **   **   **    **   **   **
--'*******************************************************************************
local cur_level=nil
local havegoodart=false

-- список компонентов
-- желательно добавлять в алфавитном порядке
local afs={
["af_ameba_mica"] = true,
["af_ameba_slime"] = true,
["af_ameba_slug"] = true,
["af_armor_1"] = true,
["af_armor_2"] = true,
["af_armor_3"] = true,
["af_babka_1"] = true,
["af_babka_2"] = true,
["af_babka_3"] = true,
["af_blood"] = true,
["af_buliz"] = true,
["af_cristall"] = true,
["af_cristall_flower"] = true,
["af_cry_1"] = true,
["af_cry_2"] = true,
["af_cry_3"] = true,
["af_dik_1"] = true,
["af_dik_2"] = true,
["af_dik_3"] = true,
["af_drops"] = true,
["af_dummy_battery"] = true,
["af_dummy_battery_red"] = true,
["af_dummy_dummy"] = true,
["af_dummy_glassbeads"] = true,
["af_dummy_pellicle"] = true,
["af_dummy_pellicle_red"] = true,
["af_dummy_spring"] = true,
["af_dummy_spring_red"] = true,
["af_electra_flash"] = true,
["af_electra_moonlight"] = true,
["af_electra_sparkler"] = true,
["af_fireball"] = true,
["af_fuzz_kolobok"] = true,
["af_gold_fish"] = true,
["af_gravi"] = true,
["af_kamen_udachy"] = true,
["af_kol_1"] = true,
["af_kol_2"] = true,
["af_kol_3"] = true,
["af_medusa"] = true,
["af_mincer_meat"] = true,
["af_night_star"] = true,
["af_part_monolit2"] = true,
["af_pudd_1"] = true,
["af_pudd_2"] = true,
["af_pudd_3"] = true,
["af_rusty_kristall"] = true,
["af_rusty_sea-urchin"] = true,
["af_rusty_thorn"] = true,
["af_simbion"] = true,
["af_soul"] = true,
["af_spirit_1"] = true,
["af_spirit_2"] = true,
["af_spirit_3"] = true
}

-- проверка на упавший предмет/артефакт
function check_for_af_drop(obj)
	local obj_sect = obj:section()
	
	-- проверка не один ли это из компонентов
	if afs[obj_sect] == true then
		local anom_id,anom_pos,anom_radius,dist = amk_anoms.get_nearest_anomaly(obj)
		
		if anom_id and anom_radius - dist > -2 then
			--local anom_sect = level.object_by_id(anom_id):section()
			--local obj_pos = obj:position()
			local lv = level.object_by_id(anom_id):level_vertex_id()
			local gv = level.object_by_id(anom_id):game_vertex_id()
			if gv == 65535 then gv = obj:game_vertex_id() end
			if gv == 65535 then gv = db.actor:game_vertex_id() end
			if gv == 65535 then return end -- похоже, что рядом нету вертекса
			
			-- предмет подходит - отправляем его на экспертизу
			-- узнаем не съели ли его или вvложили в нvчку
			local tbl		= {}
			tbl.obj_id		= obj:id()
			tbl.anom_id		= anom_id
			tbl.anom_radius	= anom_radius
			tbl.lv			= lv
			tbl.gv			= gv
			amk.start_timer("timer_drop_obj_varka", 0.2, tbl)

			-- перенесено в amk.script
			--check_af_transform(obj, obj_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv)
		end
	end
end

-- проверка: является ли компонентом для варки
-- параметр - название секции
function is_komponent(sec)
     return (afs[sec] ~= nil)
end

-- аномали "узнаітся" по части названия!
-- komp - компонентv
-- удача v_udachi + вvрождение в булvжник v_virogd <= 100 !!!
-- отторжение v_ottorg = 100 - (v_udachi + v_virogd) посему и не нужно прописvвать в таблицу
-- cel - цель (может бvть одновременно несколько целей)
-- info - инфопорция, которая будет вvдана после L-L+=+Ј варки
-- virogd - во что вvрождается (может бvть одновременно несколько вvрождений)
-- vremya = {дни, часv, минутv} - время варки/мутации
-- remove_anomaly - удалить ли аномалиі (можно комбинировать вместе с варкой/мутацией)
-- not_for_mutator - рецепт никогда не попадїт в трансмутатор
-- ne_ugadat -  рецепт не угадvвается в трансмутаторе, но будет в нїм показан при наличии поршня
local anom_recept_komp = {
	-- умолчание, если нет даннvх ближе к рецепту
	default = {
		cel = {},
		v_udachi = 80,
		v_virogd = 17,
		virogd = {["af_buliz"]=true},
		vremya = {0,0,5},
		remove_anomaly = false
	},
	
	anomalii = {
		["_zharka"] = {
			-- умолчание, если нет даннvх ближе к рецепту,
			-- которое может переопределятья в рецепте
			name = "\"Жарка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_drops"] = {
					komp = {["af_soul"]=true},
					cel = {["af_spirit_1"]=true},
					vremya = {0,4,0}
				},


				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_fire"] = {
					komp = {["af_spirit_1"]=true},
					cel = {["af_spirit_2"]=true},
					vremya = {0,6,0}
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_cristal"] = {
					komp = {["af_spirit_2"]=true},
					cel = {["af_spirit_3"]=true},
					vremya = {0,10,0}
				},
				["info_amk_recipt_tears_fire"] = {
					komp = {["af_cry_1"]=true},
					cel = {["af_cry_2"]=true},
					vremya = {0,6,0}
				},
				["info_amk_recipt_dikoobraz"] = {
					komp = {["af_rusty_sea-urchin"]=true},
					cel = {["af_dik_1"]=true},
					vremya = {0,3,0}
				},
				["info_amk_recipt_giant_small_brother"] = {
					komp = {["af_kol_3"]=true},
					cel = {["af_kol_4"]=true},
					vremya = {0,3,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_controller_skalp"] = {
					komp = {["af_armor_3"]=true},
					cel = {["af_armor_4"]=true},
					vremya = {0,6,0},
					v_udachi = 100,
					v_virogd = 0
				}
			}
		},
		
		["_galant"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Электра\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_battery"] = { -- артефакт удалит аномалииі без результатов варки/мутации
					komp = {["af_dummy_battery_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_bengal"] = {
					komp = {["af_spirit_3"]=true},
					cel = {["af_spirit_4"]=true},
					vremya = {0,1,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_tears_electra"] = {
					komp = {["af_drops"]=true},
					cel = {["af_cry_1"]=true},
					vremya = {0,5,0}
				},
				["info_amk_recipt_grandmother_glassbeards"] = {
					komp = {["af_dummy_glassbeads"]=true},
					cel = {["af_babka_1"]=true},
					vremya = {0,5,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_fire"] = {
					komp = {["af_dummy_dummy"]=true},
					cel = {["af_pudd_1"]=true},
					vremya = {0,3,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_bright"] = {
					komp = {["af_pudd_1"]=true},
					cel = {["af_pudd_2"]=true},
					vremya = {0,6,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_moon"] = {
					komp = {["af_pudd_2"]=true},
					cel = {["af_pudd_3"]=true},
					vremya = {0,8,0}
				},
				["info_amk_recipt_electra_dikoobraz"] = {
					komp = {["af_dik_1"]=true},
					cel = {["af_dik_2"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["_buzz"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Холодец\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_amk_recipt_tears_chimaera"] = {
					komp = {["af_cry_2"]=true},
					cel = {["af_cry_3"]=true},
					vremya = {0,2,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_pra_grandmother_glassbeards"] = {
					komp = {["af_babka_1"]=true},
					cel = {["af_babka_2"]=true},
					vremya = {0,3,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_puding"] = {
					komp = {["af_pudd_3"]=true},
					cel = {["af_pudd_4"]=true},
					vremya = {0,12,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_sopl_dikoobraz"] = {
					komp = {["af_dik_2"]=true},
					cel = {["af_dik_3"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_almaz_kolobok"] = {
					komp = {["af_kol_2"]=true},
					cel = {["af_kol_3"]=true},
					vremya = {0,8,0}
				},
				["info_amk_recipt_pancir"] = {
					komp = {["af_armor_2"]=true},
					cel = {["af_armor_3"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_simbion"] = {
					komp = {["af_medusa"]=true,["af_drops"]=true,["af_blood"]=true,["af_rusty_thorn"]=true},
					cel = {["af_simbion"]=true},
					vremya = {0,4,0}
				}
			}
		},
		
		
		["_mincer"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Карусель\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_spring"] = { -- артефакт удалит аномалиі без результатов варки/мутации
					komp = {["af_dummy_spring_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["info_amk_recipt_burer_grandmother_glassbeards"] = {
					komp = {["af_babka_2"]=true},
					cel = {["af_babka_3"]=true},
					vremya = {0,0,10}
				},
				["info_amk_recipt_titan_kolobok"] = {
					komp = {["af_kol_1"]=true},
					cel = {["af_kol_2"]=true},
					vremya = {0,5,0}
				},
				["info_amk_recipt_cheshya"] = {
					komp = {["af_armor_1"]=true},
					cel = {["af_armor_2"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["_mosquito_bald"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Tрамплин\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_pellicle"] = { -- артефакт удалит аномалиі без результатов варки/мутации
					komp = {["af_dummy_pellicle_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["info_amk_recipt_stone_dikoobraz"] = {
					komp = {["af_dik_3"]=true},
					cel = {["af_dik_4"]=true},
					vremya = {0,9,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_steel_kolobok"] = {
					komp = {["af_fuzz_kolobok"]=true},
					cel = {["af_kol_1"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_shkura"] = {
					komp = {["af_dummy_pellicle"]=true},
					cel = {["af_armor_1"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["_gravi_zone"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Воронка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_battery"] = { -- артефакт удалит аномалиі без результатов варки/мутации
					komp = {["af_dummy_battery_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				}
			}
		},
		
		["_ice"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Морозилка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_battery"] = {
					komp = {["af_dummy_battery"]=true},
					cel = {["af_dummy_battery_red"]=true}
				},
				["info_red_spring"] = {
					komp = {["af_dummy_spring"]=true},
					cel = {["af_dummy_spring_red"]=true}
				},
				["info_red_pellicle"] = {
					komp = {["af_dummy_pellicle"]=true},
					cel = {["af_dummy_pellicle_red"]=true}
				}
			}
		}
	}
}

-- возвра ает значение, возможно из умолчаний
local res2key = {
	[0] = "komp",	-- РѕС‚С‚РѕСЂР¶РµРЅРёРµ
	[1] = "virogd",	-- РІС‹СЂРѕР¶РґРµРЅРёРµ
	[2] = "cel"		-- СѓРґР°С‡Р°
}
function get_af_transform_param(name, recept, recepti)
	local result
	if recept[name] ~= nil then
		result = recept[name]
	elseif recepti["default"] ~= nil and recepti["default"][name] ~= nil then
		result = recepti["default"][name]
	elseif anom_recept_komp["default"] ~= nil and anom_recept_komp["default"][name] ~= nil then
		result = anom_recept_komp["default"][name]
	else
		-- нет информации!!!
		amk.send_tip("нет информации для "..name.."!","варка артефактов",0,15,"gen_info")
		result = nil
	end
	return result
end

-- іолучаем полнvй набор рецептов для аномалии anom_sect
function fill_recepti_est(anom_sect)
	local recepti_est = {} -- рецептv для заданной аномалии
	local anom_name = nil
	for anom, recepti in pairs(anom_recept_komp["anomalii"]) do
		if string_find(anom_sect, anom) ~= nil then --нашли в списке аномалиі.
			anom_name = anom_recept_komp["anomalii"][anom]["name"]
			if anom_recept_komp["anomalii"][anom]["recepti"] then
				for info, recept in pairs(recepti["recepti"]) do
					if not recept["not_for_mutator"] and not recept["remove_anomaly"] and (db.actor:has_info(info) or not recept["ne_ugadat"]) then
						recepti_est[info] = {}
						for k, v in pairs(recept) do
							if type(v) == "table" then
								recepti_est[info][k] = {}
								for i, j in pairs(v) do
									recepti_est[info][k][i] = j
								end
							else
								recepti_est[info][k] = v
							end
						end
					-- end
					end
				end
			end
		end
	end
	return recepti_est,anom_name
end

-- проверяет рецептv и компонетv
-- если всї в порядке - запускает варку/мутациі
function check_af_transform(af, af_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv)
	local actor = db.actor
	
	--поиск по аномалиям
	local finish = false -- флаг для вvхода из циклов
	for anom, recepti in pairs(anom_recept_komp["anomalii"]) do
		if string_find(anom_sect, anom) ~= nil then --нашли в списке аномалиі, возле которой стоим
			local recepti_est = {} -- рецептv в наличии у ++, в которvх участвует даннvй компонент
			local recept_podhodit = false
			
			-- собираем рецептv, в которvх участвует даннvй компонент
			for info, recept in pairs(recepti["recepti"]) do
				if actor:has_info(info) and recept["komp"][af_sect] == true then --есть рецепт и этот компонент в нїм участвует
					recept_podhodit = true
					-- копируем рецепт
					recepti_est[info] = {}
					for k, v in pairs(recept) do
						if type(v) == "table" then
							recepti_est[info][k] = {}
							for i, j in pairs(v) do
								recepti_est[info][k][i] = j
							end
						else
							recepti_est[info][k] = v
						end
					end
					-- так как table.getn() как и оператор # не работаіт с таблицами, у которvх не целочисельнvе индексv,
					-- то считаем количество в ручнуі
					local count = 0
					for k,v in pairs(recepti_est[info]["komp"]) do
						count = count + 1
					end
					recepti_est[info]["count"] = count
					--get_console():execute("load ~#I#:"..string.format("0 "..af_sect.." принят. Lном: "..anom.." рец. "..info.." "..recepti_est[info]["count"]))
				end
			end
			
			if recept_podhodit then -- если нашли хоть один имеіийся подходяий рецепт
				--amk.send_tip("іецепт подошел. anom_radius "..anom_radius," варка",0,15,"gen_info")
				--ием рядом другие компонентv
				--если находим их в вvбраннvх рецептах, то удаляем их из рецептов
				--как только какой-то рецепт остаїтся без компонентов - рецепт сработал
				local obj
				for i=1,65534 do
					obj = level.object_by_id(i)
					if obj and alife():object(i) then
						local dist = obj:position():distance_to(anom_pos)
						if obj:parent() == nil and ((anom_radius - obj:position():distance_to(anom_pos)) > -2) then
							local obj_sect = obj:section()
							--get_console():execute("load ~#I#:"..string.format(" obj_sect: "..obj_sect.." dist: "..dist))
							--проверяем отобраннvе рецептv
							for info, recept in pairs(recepti_est) do
								-- если компонент есть в рецепте
								if recepti_est[info]["komp"][obj_sect] == true then
									-- добавляем L- компонента для буду его удаления из игрv
									recepti_est[info]["komp"][obj_sect] = obj:id()
									-- уменьшаем количество компонентов в рецепте
									recepti_est[info]["count"] = recepti_est[info]["count"] - 1
									--amk.send_tip(obj_sect.." найден. Lном: "..anom.." рец. "..info.." "..recepti_est[info]["count"],"варка",0,15,"gen_info")
									--get_console():execute("load ~#I#:"..string.format(obj_sect.." найден. Lном: "..anom.." рец. "..info.." "..recepti_est[info]["count"]))
									
									-- если рецепт пуст, то он сработал
									if recepti_est[info]["count"] == 0 then
										--get_console():execute("load ~#I#:"..string.format(info.." сработал. Lном: "..anom))
										
										-- устанавливаем все параметрv для рецепта, возможно из умолчаний
										local cel		= get_af_transform_param("cel", recepti_est[info], recepti)
										local v_udachi		= get_af_transform_param("v_udachi", recepti_est[info], recepti)
										local v_virogd		= get_af_transform_param("v_virogd", recepti_est[info], recepti)
										local virogd		= get_af_transform_param("virogd", recepti_est[info], recepti)
										local vremya		= get_af_transform_param("vremya", recepti_est[info], recepti)
										local remove_anomaly	= get_af_transform_param("remove_anomaly", recepti_est[info], recepti)
										local remove_anomaly_id = anom_id
										local komp		= recepti_est[info]["komp"]
										local result, udacha 	= af_select_result(v_udachi, v_virogd, virogd, cel, komp)
										local info_portion	= recepti_est[info]["info"]
										
										if cel == nil or v_udachi == nil or v_virogd == nil
											or virogd == nil or vremya == nil or remove_anomaly == nil 
											or cel == nil and remove_anomaly == false
											or v_udachi + v_virogd > 100 then
											
											-- кривой рецепт  - вvходим
											finish = true
											break
										end
										
										-- неудача
										if udacha == false then
											remove_anomaly = false
											info_portion = nil
										end

										level.add_pp_effector("teleport.ppe", 1524, false)
										
										-- запускаем варку/мутациі
										as_start_universal_transform_timer(komp, result, obj_pos, vremya, gv, lv, info_portion, remove_anomaly, remove_anomaly_id)
										
										-- удаляем из игрv компонентv рецепта
										for k,v in pairs(komp) do
											alife():release(alife():object(v))
										end
										
										-- вvходим
										finish = true
										break
									end
								end
							end
						end
					end
					
					if finish then break end
				end
			end
			
			-- аномалия с рецептами найдена, все дела сделанv - вvходим
			break
		end
	end

end

function af_flash(af)
	level.add_pp_effector("teleport.ppe", 1524, false)
	amk.remove_item(af)
end

-- случайно вvбирает результат, возвра ает таблицу с секциями результатов
function af_select_result(v_udachi, v_virogd, virogd, cel, komp)
	local rnd=math_random(0,100)
	if rnd > v_udachi then --неудача
		if rnd > v_virogd + v_udachi then -- отторжение
			return komp, false
		else -- вvрождение
			return virogd, false
		end
	else -- удача
		return cel, true
	end
end

-- запускаем трансофрмациі 
-- результатv могут бvть многочисленнv (несколько целей, полное отторжение компонентов, несколько вvрождений)
function as_start_universal_transform_timer(komp, result, pos, vremya, gv, lv, info_portion, remove_anomaly, remove_anomaly_id)
	local t={} -- сохраняемvе даннvе
	t.result = result -- можно сохранять сразу таблицv
	t.pos = {}
		t.pos.x = pos.x
		t.pos.y = pos.y
		t.pos.z = pos.z
	t.gv=gv
	t.lv=lv
	t.info_portion = info_portion
	t.komp = komp -- можно сохранять сразу таблицv
	t.remove_anomaly = remove_anomaly
	t.remove_anomaly_id = remove_anomaly_id
	amk.g_start_timer("af_transform_universal", vremya[1], vremya[2], vremya[3], t)
end

-- старая фунция
function af_start_transform(v1,v2,af_from,af_target)
	local rnd=math_random(0,100)
	if rnd>v1 then
		if rnd>v2+v1 then
			return af_from
		else
			return "af_buliz"
		end
	else
		return af_target
	end
end

-- старая фунция
function af_start_transform_timer(af,pos,delay_d,delay_h,delay_m,af_sect)
	local t={}
	t.section=af
	t.pos={}
		t.pos.x=pos.x
		t.pos.y=pos.y
		t.pos.z=pos.z
	t.gv=gv
	t.lv=lv
	t.from_sect=af_sect
	amk.g_start_timer("af_transform",delay_d,delay_h,delay_m,t)
end

-- завершаем варку/мутациі
-- может бvть много результатов
function af_transform_universal_end(params)
	--get_console():execute("load ~#I#:"..string.format(" af_transform_universal_end "))
	-- если есть результатv
	local count = 0
	for k, v in pairs(params.result) do
		count = count + 1
	end
	if count > 0 then
		local anom_pos = vector():set(params.pos.x, params.pos.y, params.pos.z)
		if db.actor:position():distance_to(anom_pos) < 15 then
			level.add_pp_effector("teleport.ppe", 1524, false)
		end
		-- формируем строку с названиями компонентов
		local from_komp = ""
		for k,v in pairs(params.komp) do
			if k then
				from_komp = from_komp..game.translate_string(amk.get_inv_name(k))..", "
			end
		end
		-- отсекаем ", " в хвосте
		from_komp = string_sub(from_komp, 1, -2)
		
		-- спавним результат(v)
		for k,v in pairs(params.result) do
			local obj
			obj = amk.spawn_item(k, vector():set(params.pos.x,params.pos.y+10,params.pos.z), params.gv, params.lv)
	                local sobj = alife():object( obj.id )
                        alife():use_ai_locations(sobj, false)
			amk.add_spot_on_map(obj.id, "red_location", game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_komp)
		end
	
		amk.send_tip(game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_komp)
	end
	
	-- даїм инфопорциі, если есть
	if params.info_portion and db.actor:dont_has_info(params.info_portion) then
		db.actor:give_info_portion(params.info_portion)
	end
	
	-- удаляем аномалии, если нужно и она не в исклічениях
	-- код взят из amk_anoms.turn_off_all()
	if params.remove_anomaly then
		local sobj = alife():object(params.remove_anomaly_id)
		if sobj and game_graph():valid_vertex_id(sobj.m_game_vertex_id) then
			local map = alife():level_name(game_graph():vertex(sobj.m_game_vertex_id):level_id())
local obj_name=sobj:name()
	--		if not amk_anoms.check_exclusion(sobj, map) then 
				local status = amk_anoms.get_anomaly_status(sobj)
				if status=="" or status == "on" then
					amk_anoms.set_anomaly_status(sobj, "del")
			end
				alife():release(sobj, true)
	--		end
		end
	end
end

-- старая функция
function af_transform_end(params)
	local from_sect="\""..params.from_sect.."\""
	local obj
        obj=amk.spawn_item(params.section,vector():set(params.pos.x,params.pos.y+10,params.pos.z),params.gv,params.lv)
	local sobj = alife():object( obj.id )
    alife():use_ai_locations(sobj, false)
	amk.add_spot_on_map(obj.id,"red_location",game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_sect)
	amk.send_tip(game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_sect)
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **    AMK_MUSIC     **   **   **   **   **    **   **   **   **
--'*******************************************************************************

local last_update=0
local inert = 1000
local clicks_prev = 200

music_section=""
music_previous_section=""
music_next_section_start_time=0
music_stop_previous=0
music=false
music_init = 0
music_themes = {}
music_phases={}
musicflag=1
local music_objs={[1]=nil,[2]=nil}
local music_stor={
	enemy_see_actor=0,
	actor_see_enemy=0,
	enemy_hit_actor=0,
	actor_hit_enemy=0
}
music_lo_lvl=7
music_hi_lvl=17
local music_graph={}

function build_music_graph()
	local skip = false
	local lname = level.name()
	local sini = ini_file("scripts\\amk\\music\\music.ltx")
	if sini and sini:section_exist("music_themes") then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("music_themes")-1 do
			result, id, value = sini:r_line("music_themes",a,"","")
			if id~=nil and amk.trim(id)~="" and amk.trim(id)~=nil then
				id=amk.trim(id)
				value1 = amk.str_explode("|", amk.trim(value), true)
				value={}
				for k,v in pairs(value1) do
					local tmp = amk.str_explode("=", v, true)
					value[tmp[1]]=tmp[2]
				end
				
				if value.map then
					local t = amk.str_explode(",", value.map, true)
					for kk,vv in pairs(t)do
						skip = skip or vv==lname
					end
					skip = not skip
				else
					skip = false
				end
				
				if not skip then
					table.insert(music_themes, id)
					local t = amk.parse_ini_section_to_array(sini,id.."_music_files")
					t.null = ""
					for k,v in pairs(t) do
						music_phases[id.."_"..k]=v
						if not music_graph[id.."_"..k] then music_graph[id.."_"..k] = {} end
						local tt = amk.parse_ini_section_to_array(sini,id.."_graph_"..k)
						for kk,vv in pairs(tt) do
							local tmp = amk.str_explode(",",vv,true)
							local lvl = tmp[1]
							lvl = amk_mod["music_"..lvl.."_lvl"]
							music_graph[id.."_"..k][id.."_"..kk] = {lvl,tmp[2]}
						end
					end
				end
			end
		end
		if table.getn(music_themes)>0 then return true else return false end
	end
	return false
end

function music_start(sound)
	if not music then
		if music_objs[1]==nil then
			music_objs[1]=amk_music.amk_music()
		end
		if music_objs[2]==nil then
			music_objs[2]=amk_music.amk_music()
		end

		music_objs[musicflag]:initialize(music_phases[sound])
		music_next_section_start_time=music_objs[musicflag]:play()-200
		music_previous_section=music_section
		musicflag=3-musicflag
	end
	music = true
end

function music_change(sound)
	if music then
		music_objs[musicflag]:initialize(music_phases[sound])
		music_next_section_start_time=music_objs[musicflag]:play_at_time(music_next_section_start_time+200)-200
		musicflag=3-musicflag
		music_previous_section=music_section
	end
end

function interactive_music()

if (game_options.AmkMus == false or amk_music==nil) then return end 
	if music_init==-1 then return end

	if music_init==0 then
		if build_music_graph() then
			music_init=1
		else
			music_init=-1
			return
		end
	end

	if not music then
		if time_global() - last_update > inert then
			music_select_section(inert)
			last_update = time_global()
		end
	end
	
	if not music and music_previous_section=="" and music_section~="" then
		music_start(music_section)
	end
	if music and music_previous_section~="" and music_section=="" then
		music_previous_section=""
	end

	if music then
		music_objs[1]:update()
		music_objs[2]:update()
		
		if time_global() > music_next_section_start_time then
			music_select_section(music_objs[musicflag]:length())
			if music_section~="" then
				music_change(music_section)
			else
				music=false
			end
		end
		
	end

end

function reset_music_cntrs(c)
	music_stor.actor_see_enemy=music_stor.actor_see_enemy-2*c
	music_stor.enemy_see_actor=music_stor.enemy_see_actor-2*c
	music_stor.actor_hit_enemy=music_stor.actor_hit_enemy-8*c
	music_stor.enemy_hit_actor=music_stor.enemy_hit_actor-4*c
	
	if music_stor.actor_see_enemy<0 then 
		music_stor.actor_see_enemy=0 
	elseif music_stor.actor_see_enemy>music_lo_lvl then 
		music_stor.actor_see_enemy=music_lo_lvl
	end
	if music_stor.enemy_see_actor<0 then 
		music_stor.enemy_see_actor=0 
	elseif music_stor.enemy_see_actor>music_lo_lvl then 
		music_stor.enemy_see_actor=music_lo_lvl 
	end
	if music_stor.actor_hit_enemy<0 then 
		music_stor.actor_hit_enemy=0 
	elseif music_stor.actor_hit_enemy>music_hi_lvl then 
		music_stor.actor_hit_enemy=music_hi_lvl
	end
	if music_stor.enemy_hit_actor<0 then 
		music_stor.enemy_hit_actor=0 
	elseif music_stor.enemy_hit_actor>music_hi_lvl then 
		music_stor.enemy_hit_actor=music_hi_lvl
	end
	
end

function calc_adrenaline(act,obj,typ)
	local dist = obj:position():distance_to(db.actor:position())
	if act=="actor_see_enemy" then
		music_stor.actor_see_enemy=music_stor.actor_see_enemy+10/dist
	elseif act=="enemy_see_actor" then
		music_stor.enemy_see_actor=music_stor.enemy_see_actor+20/dist
	elseif act=="actor_hit_enemy" then
		music_stor.actor_hit_enemy=music_stor.actor_hit_enemy+0.2
	elseif act=="enemy_hit_actor" then
		music_stor.enemy_hit_actor=music_stor.enemy_hit_actor+4
	end
end

function music_select_section(time)
	reset_music_cntrs(time/inert)
	local cs = music_section
	
	local eseen = music_stor.enemy_see_actor
	if eseen >= music_lo_lvl then 
		eseen = music_lo_lvl
	end
	
	local aseen = music_stor.actor_see_enemy
	if aseen >= music_lo_lvl then 
		aseen = music_lo_lvl
	end
	
	local ehits = music_stor.enemy_hit_actor
	if ehits >= music_hi_lvl then 
		ehits = music_hi_lvl 
	end
	
	local ahits = music_stor.actor_hit_enemy
	if ahits >= music_hi_lvl then 
		ahits = music_hi_lvl 
	end
	
	local lvl = aseen + eseen
	if lvl>music_hi_lvl*0.75 then lvl=music_hi_lvl*0.75 end
	
	lvl = ehits + lvl + ahits
	if music_section=="" then 
		music_section=music_themes[math.random(table.getn(music_themes))].."_null" 
	end
	
	local last_sel_max=0
	local last_sel_min=1000
	for k,v in pairs(music_graph[music_section]) do

		if v[2]=="<" and v[1]<last_sel_min then
			if v[1]>lvl then 
				music_section=k 
				last_sel_min=v[1]
			end
		end
		if v[2]==">" and v[1]>=last_sel_max then
			if v[1]<=lvl then 
				music_section=k
				last_sel_max=v[1] 
			end
		end
	end
	
	if string.find(music_section,"null") then music_section="" end
	if music and music_previous_section~="" and music_section=="" then
		music_previous_section=""
	end
	
	local l=0
	if music and music_objs[musicflag]~=nil then l=music_objs[musicflag]:length() end
end

--'****************************************************************************
--'   **   **   **   **   **    **   **   **   **      BLOWOUT        **   **
--'****************************************************************************


local blowout_phantoms_subscribed

function blowout_phantoms()
  local blow = amk.load_variable( "blowout", -1 )
  if blowout_type() < 2 and blow > 1 and blow < 4 then
    local lname    = level.name()
    local phantoms = amk_hideouts.blowouts_phantoms[ lname ]
    if phantoms and phantoms.count > 0 then
      if blowout_phantoms_subscribed then
        ogse_signals.get_mgr():reschedule( 1000 )
        if not in_hide then
          if math.random() < phantoms.probability then
            if phantom_manager:phantom_count() < phantoms.count then
              local yaw = math_pi * 2.0 * math.random()
              local radius = phantoms.radius * ( math.random() / 2.0 + 0.5 )
              local height = phantoms.height * math.random()
              local a_pos  = db.actor:position()
              local pos    = vector():set(
                math.sin( yaw ) * radius + a_pos.x,
                a_pos.y + height,
                math.cos( yaw ) * radius + a_pos.z
              )
              phantom_manager.spawn_phantom( pos )
            end
          end
        end
      else
        blowout_phantoms_subscribed = {
          signal = "on_update", fun = this.blowout_phantoms,
          script_name = script_name(),
        }
        ogse_signals.get_mgr():subscribe( blowout_phantoms_subscribed )
      end
    end
  elseif blowout_phantoms_subscribed then
    ogse_signals.get_mgr():unsubscribe( blowout_phantoms_subscribed )
    blowout_phantoms_subscribed = nil
  end
end


function blowout_scary_sounds()
	local blow=amk.load_variable("blowout",-1)
	if blow>0 and blow<4 then
                local snd_obj = xr_sound.get_safe_sound_object(amk_hideouts.blowout_sounds[math_random(#amk_hideouts.blowout_sounds)])
                local a=vector():set( 0, 0, 0 )
                a.x=math_random(0,10)
                a.y=math_random(0,10)
                a.z=math_random(0,10)
                snd_obj:play_at_pos(db.actor, db.actor:position():add(a))
                amk.start_timer("blowout_ss",math_random(10,30),0)
        end
end

function blowout_psy_sound(action)
	if action=="start" then
		snd_obj_eq = sound_object([[ambient\earthquake]],sound_object.looped+sound_object.s2d)
    snd_obj_eq:play(db.actor, 4, sound_object.looped+sound_object.s2d)
	end
	if action == "stop" then
		if snd_obj_eq then snd_obj_eq:stop() end
	end
	
	local lname=level.name()
	if not amk_hideouts.blowouts_phantoms[lname] then return end
	local psy_sound=amk_hideouts.blowouts_phantoms[lname].psy_sounds or false	
	if not psy_sound then return end

	if action=="start" then
		local level_vol=amk_hideouts.blowouts_phantoms[lname].level_vol or 1				
		sound_obj_right, sound_obj_left = xr_sound.get_sound_object("psy_voices", "random")
		sound_obj_left:play_at_pos (db.actor, vector():set(-1, 0, 1), 0, sound_object.s2d + sound_object.looped)
		sound_obj_right:play_at_pos(db.actor, vector():set( 1, 0, 1), 0, sound_object.s2d + sound_object.looped)
		snd_volume	= level.get_snd_volume()
		level.set_snd_volume( level_vol )
	end
	if action == "stop" then
		if sound_obj_left then sound_obj_left:stop() end
		if sound_obj_right then sound_obj_right:stop() end
		if snd_volume then level.set_snd_volume(snd_volume) end
	end	
end

function Blowout_pp(phase)
---------------------------------------------------
--' TimeFactor = 5
--' GameMin = 12 RealSec
--' TimeBlowout = 184 RealSec

--' начало (Timer = 36 sec)
--' первая фаза (Timer = 36 sec)
--' вторая фаза (Timer = 36 sec)
--' Tретья фаза (Timer = 36 sec)
--' четвертая фаза (Timer = 60 sec)
--' конечная фаза (Timer = 0 sec)
---------------------------------------------------

	amk.mylog("blowout "..phase)
local basis = game_options.blow_phase_basis
local shift = game_options.blow_phase_shift
local max = game_options.blow_phase_max
local resuls = basis + (math_random()*shift) - (shift/2)
if resuls < 1 then resuls = 1 elseif resuls > max then resuls = max end
local blow = amk.load_variable("blowout", 0)
local bt=blowout_type()
if blow > 0 and blow < 4 and bt == 2 then amk.g_start_timer("blowout", 0, 0, 3, 4) end
        if phase==0 then
                db.actor.blowout_outside = true
                amk_anoms.pre_blow_off()
		if bt<1 then
			level.set_weather("pre_blow",true)
			level.set_weather_fx("amk_surge_day")
		end 
amk.g_start_timer("blowout", 0, 0, resuls, 1)
                elseif phase==1 then
                local snd_obj = xr_sound.get_safe_sound_object([[ambient\earthquake]])
                snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0)
                level.add_cam_effector("camera_effects\\earthquake.anm", 2002, true, "")
                snd_obj = xr_sound.get_safe_sound_object([[anomaly\blowout]])
                snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0)
                blowout_psy_sound("start")
                if bt < 1 then
                        level.add_pp_effector("vibros.ppe", 2001, true)
                end
                in_hide=false
amk.g_start_timer("blowout", 0, 0, resuls, 2)
                amk.save_variable("blowout",2)  
        elseif phase==2 then
                amk.g_start_timer("blowout",0,0,3,3)
        elseif phase==3 then
                amk_anoms.after_blow_on()
                amk_anoms.off_testobj()
		amk.save_variable("blowout",3)
		local h = hit()
		local cr
		h.type = hit.strike
		h.power = 1000
		h.impulse = 1000
                for a, sobj in alife():objects() do
                        cr=level.object_by_id(a)
                        if cr~=nil and cr:section()=="m_crow" and math_random(0,100)<70 then
                                h.draftsman = cr
                                h.direction = cr:direction()
                                cr:hit(h)
                        end
                end
amk.g_start_timer("blowout", 0, 0, resuls, 4)
        elseif phase==4 then
                amk.save_variable("blowout",4)
                level.remove_cam_effector(2002)
                if bt<1 then
                        level.remove_pp_effector(2001)
                        level.add_pp_effector("monolith_off.ppe", 2003, false)
                end
                blowout_psy_sound("stop")
                amk.start_timer("blowout",5,5)
        elseif phase==5 then
                level.set_weather(amk.load_variable("weather","default1"))
                if bt<1 then
                        local snd_obj = xr_sound.get_safe_sound_object([[anomaly\teleport_work2]])
                        snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0)
                end
                amk.del_variable("blowout")
        if game_options.zombie_team == 1 then
            tag_spb.zombie_team()
        end 
        end
end


local blowout_hit_subscribed

function on_blowout_hit_actor()
  local blow = amk.load_variable( "blowout", -1 )
  if blowout_type() == 0 and blow > 1 and blow < 4 then
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():reschedule( 1000 )
      on_blowout_hit( db.actor )
    else
      blowout_hit_subscribed = {
        signal = "on_update", fun = this.on_blowout_hit_actor,
        script_name = script_name(),
      }
      ogse_signals.get_mgr():subscribe( blowout_hit_subscribed )
    end
  else
    in_hide = true
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():unsubscribe( blowout_hit_subscribed )
      blowout_hit_subscribed = nil
    end
  end
end


function on_blowout_hit( npc, hide )
	local bt=blowout_type()
	if bt>0 or amk.load_variable("blowout",-1)~=3 then 
    if npc:id()==db.actor:id() then in_hide = true end
		return false
	end
	
	local lname=level.name()
	local need_hit
	need_hit=true
	local khit=1
	if hide and hide.zone then
		need_hit = not check_npc_in_hideout(npc,hide)
		if not need_hit then
			if hide.defence then 
				khit=hide.defence
			else
				khit=0
			end
		end
	else
		local hides=amk_hideouts.hide[lname]
		local tmp
		if hides then
			for i,o in ipairs(hides) do
				if o.zone then
					for j,v in ipairs(o.zone) do
						if v.p3 then
							tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
						else
							tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
						end
						need_hit = need_hit and not tmp
						if tmp then
							if o.defence then 
								khit=o.defence
							else
								khit=0
							end
						end
					end
				end
			end
		end
	end

    if npc:id()==db.actor:id() then
                if not need_hit then
                        db.actor.blowout_outside = nil
                end
                if outfit_hideout() then -- защита от выброса броником
                        need_hit = false
                        khit = 0
                else
                        khit = khit+khit*level.get_game_difficulty()/6  -- усиление хита для актора, чтобы вне укрытия не пережил
                end
                in_hide = not need_hit
        end
    if (need_hit or khit>0) and amk.load_variable("blowout",-1)==3 and not (hide and hide.hidden) then
		local h = hit()
    	h.power = (amk_hideouts.blowout_damages[lname] or 0.01)*khit
    	h.impulse = 0
		h.draftsman = npc
		h.direction = vector():set(0,0,0)
                h:bone("bip01_spine") -- чтобv учитvвалась броня
        h.type = hit.strike
                npc:hit(h)
        h.type = hit.telepatic
                npc:hit(h)
        h.type = hit.radiation
                npc:hit(h)
    end
    return need_hit or khit>0
end


function outfit_hideout()
        local outfits = {
                ["nano_outfit"] = true
        }
        return db.actor:item_in_slot(6) and outfits[db.actor:item_in_slot(6):section()]
end

function check_npc_in_hideout(npc,hide)
	local not_in_zone=true
	if hide and hide.zone then
		for k,v in pairs(hide.zone) do
			if v.p3 then 
				not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
			else
				not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
			end
		end
	end
	return not not_in_zone
end

function initial_spawn(action)
	local fr=0
	for i=0,amk_hideouts.anom_count-1,1 do
		local sobj = alife():story_object(amk_hideouts.anom_sid0+i)
		if not sobj then 
			alife():create(i+amk_hideouts.anom_num0) 
			fr=1
		end
	end
	if fr==1 then create_anoms() end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       ANOMS SPAWN        **   **   **   **   **    **   **   **   
--'*******************************************************************************
anomalies_state={}

function remove_anoms()
        amk.save_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
	update_anoms()
end

function create_anoms()
	anomalies_state={}
	for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
                anomalies_state[i]=math_random(0,1)==1
	end
	local str=pack_anoms(anomalies_state)
	amk.save_variable("blowout_anoms",str)
	update_anoms()
end

function update_anoms()
        local anoms=amk.load_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
	anomalies_state=unpack_anoms(anoms)
	for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
		local sobj=alife():story_object(i)
		if sobj then
			local obj=level.object_by_id(sobj.id)
			if obj then
				if anomalies_state[i] then
					obj:enable_anomaly()
				else
					obj:disable_anomaly()
				end
			end
		end
    end
end

-- anom_state[sid]==true для активнvх аномалий
function pack_anoms(anom_state)
	local str=""
	for i=0,amk_hideouts.anom_count-1,7 do
		local cval=128
		local mul=1
		for j=0,6,1 do
			if anom_state[i+j+amk_hideouts.anom_sid0] then
				cval=cval+mul
			end
		mul=mul*2
		end
    str=str..string.char(cval)
	end
	return str
end

function unpack_anoms(str)
	local anom={}
	for i=1,string.len(str),1 do
                local cval=string.byte(string_sub(str,i,i))
		local mul=1
		for j=0,6,1 do
			anom[(i-1)*7+j+amk_hideouts.anom_sid0]=bit_and(mul,cval)~=0
			mul=mul*2
		end
	end
	return anom
end

function blowout_type()
	local lname=level.name()
local blow_type = amk_hideouts.blowout_types[lname]
return blow_type or 0
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **    **      RECEPTS       **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function check_usable_item(obj)
	local info=nil
	if obj:section()=="vehicle_btr" then
		db.actor:kill(db.actor)
	end
	if obj:name()=="mil_stalker0012" then
		info="info_amk_recipt_stone_dikoobraz"
	elseif level.name()=="l01_escape" and obj:section()=="amk_zapiska" then
		info="info_amk_recipt_shkura"
		amk.drop_item(db.actor,obj)
		amk.remove_item(obj)
	elseif level.name()=="l04u_labx18" and obj:section()=="amk_zapiska" then
		info="info_amk_recipt_simbion"
		amk.drop_item(db.actor,obj)
		amk.remove_item(obj)
	elseif level.name()=="l08u_brainlab" and obj:section()=="amk_zapiska" then
		info="info_amk_recipt_dummy"
		amk.drop_item(db.actor,obj)
		amk.remove_item(obj)
	else
		local recipes=amk.load_table("amk_body_recipe")
		info=recipes[obj:id()]
	end  
	if db.actor==nil or info==nil or db.actor:has_info(info) then
		return
	end
	db.actor:give_info_portion(info)
	amk_dialogs.info_received()
end

function generate_recipe(obj)
	if IsMonster(obj) then
		return
	end
	local info=nil
	local prop=100
  if level.name()=="l07_military" and obj.character_community and
          obj:character_community()=="killer" then
		info="info_amk_recipt_titan_kolobok"
		prob=3
  elseif level.name()=="l10_radar" and obj.character_community and
          obj:character_community()=="monolith" then
		info="info_amk_recipt_controller_skalp"
		prob=1  
	end
	if not info then return end
	local recipes=amk.load_table("amk_body_recipe")
	-- Проверим не генерился ли уже этот рецепт
	for k,v in pairs(recipes) do
		if v==info then
			return
		end
	end
	-- Сгенерим рецепт
	if math.random(100)<=prob then
		recipes[obj:id()]=info
		amk.save_table("amk_body_recipe",recipes)
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **     SPAWN_OBJ        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************
function spawn_fuel()
	local ballons = {
	{108.16, -6.30, -18.17, 412158, 115},
	{370.12, 15.06, -39.48, 594401, 0},
	{58.30, 19.36, 156.50, 345136, 97},
	{-92.21, -1.18, -212.66, 115177, 268},
	{-74.17, 1.80, 8.45, 127766, 329},
	{3.18, 1.24, 42.48, 243919, 490},
	{15.35, -1.90, 2.40, 255433, 479},
	{77.54, 0.30, -108.47, 312366, 427},
	{-145.54, -0.00, -199.61, 92520, 650},
	{-130.08, 10.00, -196.67, 109214, 629},
	{-140.13, 10.00, -197.94, 98647, 629},
	{37.28, 1.02, -49.90, 220638, 1084},
	{476.68, -46.94, -0.23, 155714, 1919},
	{76.80, -2.54, -23.93, 36304, 1970},
	{94.78, 0.03, -6.88, 88986, 1514},
	{-3.24, -11.75, -263.07, 33794, 1448}
	}
	local kanisters = {
	{-293.80, -14.18, -15.36, 15703, 67},
	{-16.57, 2.48, 58.82, 260308, 88},
	{-74.81, -1.30, 160.52, 196218, 163},
	{-69.94, 0.97, 6.51, 131411, 329},
	{64.01, 0.60, 148.46, 235341, 364},
	{63.29, -0.20, 5.10, 299326, 461},
	{-28.52, -1.04, -181.84, 211644, 676},
	{2.93, -1.88, -13.30, 176553, 1047},
	{41.71, 4.54, -86.36, 227110, 1100},
	{7.90, 1.41, -71.93, 183138, 1041},
	{158.71, -0.76, -259.73, 358950, 962},
	{-342.92, -13.60, 390.01, 11235, 1847},
	{305.22, -36.99, -24.40, 68330, 1930},
	{55.02, 1.17, 40.35, 68094, 1511},
	{-114.14, -0.00, 121.75, 43453, 1315},
	{31.33, 5.60, -13.51, 4683, 1538}
	}
        for k,v in pairs(ballons) do
                if #v == 5 then
                        local obj = alife():create("amk_ballon",vector():set(v[1], v[2], v[3]), v[4], v[5])
                end
        end
        for k,v in pairs(kanisters) do
                if #v == 5 then
                        local obj = alife():create("amk_kanistra",vector():set(v[1], v[2], v[3]), v[4], v[5])
                end
        end
end

-- БТР на блокпосту
function spawn_military_btr()
	spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-168.11, -29.71, -303.21),81808,38 ) ,"vehicle_btr")
	spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-237.85, -26.23, -378.81),17147,14 ) ,"vehicle_btr")
	spawn_military_tech_pack( alife():create("helicopter",vector():set(-150.0,-40.0,-620.0),128298,11 ) ,"helicopter")
end

function spawn_military_tech_pack(obj, spawn_item)	
	local packet = net_packet()
	obj:STATE_Write(packet)

	-- свойства cse_alife_object
	local game_vertex_id = packet:r_u16()
	local cse_alife_object__unk1_f32 = packet:r_float()
	local cse_alife_object__unk2_s32 = packet:r_s32()
	local level_vertex_id = packet:r_s32()
	local object_flags = packet:r_s32()
	local custom_data = packet:r_stringZ()
	local story_id = packet:r_s32()
	local cse_alife_object__unk3_s32 = packet:r_s32()

	-- свойства cse_visual
	local model_visual = packet:r_stringZ()
	local cse_visual__unk1_u8 = packet:r_u8()
	local motion_name
	if spawn_item == "helicopter" then
		-- свойства cse_motion
		motion_name = packet:r_stringZ()
	end

	-- свойства cse_ph_skeleton
	local skeleton_name = packet:r_stringZ()
	local cse_ph_skeleton__unk1_u8 = packet:r_u8()
	local cse_ph_skeleton__unk2_u16 = packet:r_u16()
	local health 
	local cse_alife_helicopter__unk1_sz 
	local engine_sound 
		
	if spawn_item == "helicopter" then
		-- свойства cse_alife_helicopter
		cse_alife_helicopter__unk1_sz = packet:r_stringZ()
		engine_sound = packet:r_stringZ()
	elseif	spawn_item == "vehicle_btr" then
		health = packet:r_float()
	end
	
	-- теперь заполняем нужные параметры
	-- свойства cse_alife_object
	packet:w_begin(game_vertex_id)
	packet:w_float(cse_alife_object__unk1_f32)
	packet:w_s32(cse_alife_object__unk2_s32)
	packet:w_s32(level_vertex_id)
	object_flags = bit_not(5)	-- ~5 = 0xfffffffa
	packet:w_s32(object_flags)
	if spawn_item == "helicopter" then
		packet:w_stringZ("[logic]\ncfg = scripts\\esc\\esc_blockpost_heli.ltx")
	elseif	spawn_item == "vehicle_btr" then
		packet:w_stringZ("[logic]\ncfg = scripts\\esc\\esc_blockpost_btr.ltx")
	end
	packet:w_s32(-1)
	packet:w_s32(cse_alife_object__unk3_s32)

	-- свойства cse_visual
	packet:w_stringZ(model_visual)
	packet:w_u8(cse_visual__unk1_u8)
	
	if spawn_item == "helicopter" then
		packet:w_stringZ(motion_name)		
	end 
	
	-- свойства cse_ph_skeleton
	skeleton_name = "idle"
	packet:w_stringZ(skeleton_name)
	packet:w_u8(cse_ph_skeleton__unk1_u8)
	packet:w_u16(cse_ph_skeleton__unk2_u16)

	if spawn_item == "helicopter" then
		-- свойства cse_alife_helicopter
		cse_alife_helicopter__unk1_sz = "idle"
		engine_sound = "alexmx\\helicopter"
		packet:w_stringZ(cse_alife_helicopter__unk1_sz)
		packet:w_stringZ(engine_sound)
	elseif  spawn_item == "vehicle_btr" then
		health = 1
		packet:w_float(health)
	end	
	-- считываем скорректированные параметры
	packet:r_seek(0)
	obj:STATE_Read(packet, packet:w_tell())
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       AMK_RESPAWNS     **   **   **   **   **    **   **   **   
--'*******************************************************************************
function switch_monster_online(obj)
	se_monster.need_be_online[obj.id]=true
end

function switch_monster_offline(obj)
	se_monster.need_be_online[obj.id]=false
end

function respawned(obj,respawner)
	if IsMonster(obj) then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			local t = amk.read_monster_params(obj)
			t.custom = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx"
			amk.write_monster_params(t, obj)
		end
	elseif IsStalker(obj) then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			local t = amk.read_stalker_params(obj)
			t.custom = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx"
			amk.write_stalker_params(t, obj)
		end
	end	
end

local respawners={}

function spawn_unspawned_respawners()

	for a=1,65534 do
		local obj = alife():object(a)
		if obj then
			local oini = obj:spawn_ini()
			if oini:line_exist ("respawn", "amk_name") == true then
				local amk_name = utils.cfg_get_string(oini, "respawn", "amk_name", false, false, false, false)
				if amk_name then respawners[amk_name]=true end
			end
		end
	end

	local sini = ini_file("scripts\\amk\\amk_respawns.ltx")
	
	local dv={}
	if sini:section_exist("default_values") then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("default_values")-1 do
			result, id, value = sini:r_line("default_values",a,"","")
			if id~=nil and amk.trim(id)~="" and amk.trim(id)~=nil then
				dv[amk.trim(id)]=amk.trim(value)
			end
		end
	end

	if sini:section_exist("amk_respawns") then
		local tmp={}
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("amk_respawns")-1 do
			result, id, value = sini:r_line("amk_respawns",a,"","")
			if id~=nil and amk.trim(id)~="" and amk.trim(id)~=nil then
				table.insert(tmp, amk.trim(id))
			end
		end
		
		for k,v in pairs(tmp) do
			local flag = utils.cfg_get_bool(sini, "amk_respawns", v, true, false, false)
			if not respawners[v] and flag==true then
				local t = amk.parse_ini_section_to_array(sini, v)
				local xyzlg = amk.str_explode(",",t.xyzlg,true)
				local pos = vector():set(tonumber(xyzlg[1]),tonumber(xyzlg[2]),tonumber(xyzlg[3]))
				local respawner = amk.spawn_item("respawn",pos,tonumber(xyzlg[5]),tonumber(xyzlg[4]))
				local tbl = amk.get_spawner_data(respawner)
				t.xyzlg = nil
				t.amk_name = v

				for kkk,vvv in pairs(dv) do
					if t[kkk]==nil then
						t[kkk]=vvv
					end
				end

				tbl.custom = amk.gen_custom_data({respawn=t})
				amk.set_spawner_data(tbl, respawner)
				se_respawn.reinit_spawner_params(respawner:name())
			end
			if flag==false then
				local o = se_respawn.get_respawner_by_name(v)
				if o then
					alife():release(o)
				end
			end
		end
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **          OTHER        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************

local last_armor_id=0
local last_condition=0

function repair_armor(val)
	local armor = db.actor:item_in_slot(6)
	if armor then
		last_armor_id=armor:id()
		last_condition=val
		armor:set_condition(val)
	end
end

function dezombify(id,v)
	local npc=level.object_by_id(id)
	if npc then
		if npc:alive()==false then
			return true
		end
		local sobj=alife():object(id)
		if sobj then
			npc:set_character_community(v.comm,0,0)
			npc:set_goodwill(v.gw,db.actor)
			local orgtbl=amk.read_stalker_params(sobj)
			orgtbl.profile=string.gsub(orgtbl.profile,"(.*)_zombi","%1")
			-- amk.mylog("dezombified "..npc:name().." profile "..orgtbl.profile)
			amk.write_stalker_params(orgtbl,sobj)
			return true
		end    
	end
	return false
end
btrs_friends={}

function build_btrs_table(obj)
        if obj and (IAmAStalker[obj:clsid()] and obj:character_community()=="military" and obj:alive()) or obj:section()=="vehicle_btr" then
                        btrs_friends[obj:id()] = obj:section()
        end
end

function zomby_blow(obj)
	if obj:object("wpn_flame") then
		amk_particle.amk_particle({
				particle="explosions\\explosion_fuelcan",
				pos=obj:position(),
				sound=[[weapons\t_rgd5_explosion]]
			})
		local dist = db.actor:position():distance_to(obj:position())
		if dist < 10 and db.actor:see(obj) then
			local h = hit()
			h.impulse = 0
			h.draftsman = db.actor
			h.direction = vector():set(0,0,0)
                        h:bone("bip01_spine") -- чтобv учитvвалась броня
			h.power = 1/dist
			h.type = hit.strike --chemical_burn
			db.actor:hit(h)
			h.power = 15/dist
			h.type = hit.chemical_burn
			db.actor:hit(h)
		end
		alife():release(alife():object(obj:id()))
		return
	end

	if obj:section()=="zombie_blow" then
		amk_particle.amk_particle({
                        particle="monsters\\polter_death_00",
                        pos=obj:bone_position("bip01_head"),
                        sound="anomaly\\anomaly_gravy_hit1"
			})
                local dist = db.actor:position():distance_to(obj:position())
                if dist < 20 and db.actor:see(obj) then
                        local h = hit()
                        h.impulse = 0
                        h.draftsman = db.actor
                        h.direction = vector():set(0,0,0)
                        h:bone("bip01_spine")
                        h.power = 1/dist
                        h.type = hit.burn
                        db.actor:hit(h)
                        h.power = 15/dist
                        h.type = hit.burn
                        db.actor:hit(h)
--            level.add_pp_effector("amk_shoot.ppe", 2016, false)
            local snd_obj = xr_sound.get_safe_sound_object([[monsters\zombie\zombie_take_damage_]]..tostring(math.random(1,6)))
                        snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0)
                        alife():release(alife():object(obj:id()))
                end
        end
end

function repair_weapon (st)
        local arr = amk.unpack_array_from_string(st)
        local oid = arr[1]
        local repbox_health = arr[2]
        local slot = arr[3]
        if alife():object(oid)==nil then
                local repair_coef = 0                                   
                local item_in_slot = db.actor:item_in_slot(slot)  
                if repbox_health==1 then                                 
                        repair_coef=0.25                                           
                elseif repbox_health<1 then                       
                        repair_coef=0.2                                         
                elseif repbox_health<0.8 then                       
                        repair_coef=0.15                                            
                elseif repbox_health<0.6 then                        
                        repair_coef=0.1                                         
                elseif repbox_health<0.4 then                        
                        repair_coef=0.05         
                end      
                --------------------------------------------------------------------------- 
                local rem
                
                if item_in_slot == nil then
                        amk.send_tip(game.translate_string("rep_no_weapon_in_slot"),nil,nil,5)
                        rem = amk.spawn_item_in_inv("repbox_s"..slot)
                        amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health} )
                else
                        if item_in_slot:condition()>0.95 then
                                amk.send_tip(game.translate_string("rep_not_need"),nil,nil,5)
                                rem = amk.spawn_item_in_inv("repbox_s"..slot)
                                amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health} )
                        else 
                                if item_in_slot:condition()>=0.7 then
                                        item_in_slot:set_condition(item_in_slot:condition() + repair_coef)
                                        if repbox_health>0.3 then
                                                rem = amk.spawn_item_in_inv("repbox_s"..slot)
                                                amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health-0.2} )
                                        end
                                else
                                        amk.send_tip(game.translate_string("rep_need_big"),nil,nil,5)
                                        rem = amk.spawn_item_in_inv("repbox_s"..slot)
                                        amk.start_timer("repbox_cond",0.1, {rem.id, repbox_health} )
                                end
                        end
                end
        end

end

function after_repair_weapon (st)
        local arr = amk.unpack_array_from_string(st)
        local oid = arr[1]
        local repbox_health = arr[2]
        local lobj = level.object_by_id(oid)
        if lobj then
                lobj:set_condition(repbox_health)
        end
end

function get_state(se_obj)
	local packet = net_packet()
	se_obj:STATE_Write(packet)
	local st = {}
	st.game_vertex_id	= packet:r_u16()
	st.distance		= packet:r_float()
	st.direct_control	= packet:r_s32()
	st.level_vertex_id	= packet:r_s32()
	st.object_flags		= packet:r_s32()
	st.custom_data		= packet:r_stringZ()
	st.story_id		= packet:r_s32()
	st.spawn_story_id	= packet:r_s32()
	st.visual_name		= packet:r_stringZ()
	st.visual_flags		= packet:r_u8()
	st.condition		= packet:r_float()
	st.ammo_current		= packet:r_u16()
	st.ammo_elapsed		= packet:r_u16()
	st.weapon_state		= packet:r_u8()
	st.addon_flags		= packet:r_u8()
	st.ammo_type		= packet:r_u8()
	return st
end

function get_update(se_obj)
	local packet = net_packet()
	se_obj:UPDATE_Write(packet)
	local st = {}
	st.grenade_mode		= packet:r_u8()
	st.num_items		= packet:r_u8()		-- !!! warning !!!
	st.condition		= packet:r_u8()
	st.weapon_flags		= packet:r_u8()
	st.ammo_elapsed		= packet:r_u16()
	st.addon_flags		= packet:r_u8()
	st.ammo_type		= packet:r_u8()
	st.weapon_state		= packet:r_u8()
	st.weapon_zoom		= packet:r_u8()
	st.current_fire_mode	= packet:r_u8()
	return st
end

function read_if_exist_num(ltx, section, value, default)
	if ltx:line_exist(section,value) then
		return ltx:r_u32(section,value)
	else
		return default
	end
end

function read_if_exist_str(ltx, section, value, default)
	if ltx:line_exist(section,value) then
		return ltx:r_string(section,value)
	else
		return default
	end
end
