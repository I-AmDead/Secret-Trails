-- -*- mode: lua; coding: windows-1251-dos -*-

in_hide = false

function attach( sm )
  sm:subscribe({ signal = "on_drop",         fun = this.check_for_af_drop })
  sm:subscribe({ signal = "on_use",          fun = this.treasure_create   })
  sm:subscribe({ signal = "on_npc_use",      fun = this.check_usable_item })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_actor_spawn    })
  sm:subscribe({ signal = "on_npc_spawn",    fun = this.build_btrs_table  })
  sm:subscribe({ signal = "on_ph_spawn",     fun = this.build_btrs_table  })
end

function on_actor_spawn()
	if db.actor:has_info( "blowout" ) then
		on_blowout_hit_actor()
		blowout_phantoms()
	end
end

function treasure_create(obj)
	local section = obj:section()
	if section=="treasure_item" then
		local sobj = alife():create("m_inventory_box", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
		sobj = alife():object( sobj.id )
		sobj.custom_data = "[logic]\ncfg = scripts\\treasure_inventory_box.ltx\n"
		sobj:used_ai_locations( false )
	end
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        FIRST_RUN          **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function first_run() 
	-- На момент вызова этой функции актор уже доступен - переделано на поршень.
	if has_alife_info( "x_first_run" ) then return end
  
	ogse.spawn_item_in_inv("matras")

	alife():create("x18_zapiska_ruk",vector():set( 21.6, -3.94, -18.28 ), 1140, 5991 )
	alife():create("x16_zapiska_ruk",vector():set( -128.0, 22.5, -30.0), 1543, 7083 )

	local obj = alife():story_object(830)
	if obj then
		alife():release(obj)
		alife():create(6132)
	end

	spawn_military_btr()	
	spawn_fuel()

	local obj = alife():story_object( 6002 )
	if objt then
		alife():release(objt)
	end
	
	dsh_alife.invalidate_items()

	db.actor:give_info_portion( "x_first_run" )
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **        CHECK_SPAWN          **   *
--'****************************************************************************

function check_spawn()
	spawn_unspawned_respawners() 

	local obj = alife():story_object(6001)
	if obj then
		level.map_add_object_spot(obj.id, "level_changer", "to_pripyat")
	end

	local obj = alife():story_object(6002)
	if obj then
		level.map_add_object_spot(obj.id, "level_changer", "to_darkvalley")
	end

	local obj = alife():story_object(6000)
	if not obj then
		alife():create(6520)
		obj = alife():story_object(6000)
	end
 
	braad_test.delete_new_lc(833,"info_way_pripyat")
	braad_test.delete_new_lc(1007,"info_way_radar")
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      AF_TRANSFORM         **   **   **   **   **    **   **   **
--'*******************************************************************************

-- проверка на упавший предмет/артефакт
function check_for_af_drop(obj)
	local is_komponent = get_bool(obj:section(), "is_komponent", false)
	-- проверка не один ли это из компонентов
	if not is_komponent then return end
	local hasanom, anom_id, anom_pos, cls, dist, anom_radius, sect_anom = ogse_anomaly.get_nearest_anomaly_by_point(db.actor:position())
	if not ( anom_id and dist < 3 ) then return end
	local lv = level.object_by_id(anom_id):level_vertex_id()
	local gv = level.object_by_id(anom_id):game_vertex_id()
	
	if gv == 65535 then
		gv = obj:game_vertex_id()
	end
	
	if gv == 65535 then
		gv = db.actor:game_vertex_id()
	end
	
	if gv == 65535 then return end -- похоже, что рядом нету вертекса

	-- предмет подходит - отправляем его на экспертизу
	-- узнаем не съели ли его или вvложили в нvчку
	local tbl = {}
	tbl.obj_id = obj:id()
	tbl.anom_id = anom_id
	tbl.anom_radius = anom_radius
	tbl.lv = lv
	tbl.gv = gv
	dsh.start_timer("timer_drop_obj_varka", 0.2, "amk_mod.timer_drop_varka", tbl)
end

-- проверка: является ли компонентом для варки
-- параметр - название секции
function timer_drop_varka(tbl)
	local sobj = alife():object(tbl.obj_id)
	if sobj and sobj.parent_id == 65535 then
		local obj = level.object_by_id(tbl.obj_id)
		local anom = level.object_by_id(tbl.anom_id)
		if obj and anom then
			local obj_sect = obj:section()
			local obj_pos = obj:position()
			local anom_sect = anom:section()
			local anom_pos = anom:position()
			check_af_transform(obj, obj_sect, obj_pos, tbl.anom_id, anom_sect, anom_pos, tbl.anom_radius, tbl.lv, tbl.gv)
		end
	end
end


-- проверяет рецептv и компонетv
-- если всї в порядке - запускает варку/мутациі
function check_af_transform(af, af_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv)
	local actor = db.actor
	
	--поиск по аномалиям
	local is_anomaly = get_bool(anom_sect, "is_anomaly", false)
	if not is_anomaly then return end

	local recept_podhodit = false

	-- собираем рецептv, в которvх участвует даннvй компонент
	local count = 0
	local komponent_sect_string = nil
	local lucky_sect_string = nil
	local lucky_num = nil
	local bad_num = nil
	local bad_sect_string = nil
	local time_vector = nil
	local anomaly_remove_bool = nil
	
	for info, recept in pairs(split_comma_separated_list(get_string(anom_sect, "anomaly_recipes"))) do
		komponent_sect_string = get_string("transform_"..recept, "komp")
		if actor:has_info(recept) and komponent_sect_string == af_sect then --есть рецепт и этот компонент в нїм участвует
			recept_podhodit = true
			lucky_sect_string = get_string("transform_"..recept, "cel")
			lucky_num = get_u32("transform_"..recept, "v_udachi")
			bad_num = get_u32("transform_"..recept, "v_virogd")
			bad_sect_string = get_string("transform_"..recept, "virogd")
			time_vector = get_vector("transform_"..recept, "vremya")
			anomaly_remove_bool = get_bool("transform_"..recept, "remove_anomaly")
			count = count + 1
			if recept_podhodit then
				break
			end
		end
	end
			
	if recept_podhodit then
		if af and not af:parent() and af:position():distance_to(anom_pos) < 3 then

			-- если компонент есть в рецепте
			if komponent_sect_string == af:section() then
				-- уменьшаем количество компонентов в рецепте
				count = count - 1

				-- если рецепт пуст, то он сработал
				if count == 0 then
					-- устанавливаем все параметрv для рецепта, возможно из умолчаний
					local result_sect, luck = af_select_result(lucky_num, bad_num, bad_sect_string, lucky_sect_string, komponent_sect_string)
							
					if not lucky_sect_string or not lucky_num or not bad_num
					or not bad_sect_string or not time_vector or anomaly_remove_bool == nil
					or (not lucky_sect_string and not anomaly_remove_bool)
					or lucky_num + bad_num > 100 then
						-- кривой рецепт  - выходим
						return
					end
							
					-- неудача
					if luck == false then
						anomaly_remove_bool = false
					end

					-- запускаем варку/мутацию
					local t = { } -- сохраняемые данные
					t.komp   = komponent_sect_string
					t.result = result_sect
					t.pos    = {}
					t.pos.x  = obj_pos.x
					t.pos.y  = obj_pos.y
					t.pos.z  = obj_pos.z
					t.gv     = gv
					t.lv     = lv
					t.remove_anomaly    = anomaly_remove_bool
					t.remove_anomaly_id = anom_id
					dsh.start_gtimerDHMS("af_transform", time_vector.x, time_vector.y, time_vector.z, 0, "amk_mod.af_transform_universal_end", t)

					-- удаляем из игры компоненты рецепта
					alife():release(alife():object(af:id()))

					level.add_pp_effector("teleport.ppe", 1524, false)
				end
			end
		end
	end
end

-- случайно выбирает результат, возвращает таблицу с секциями результатов
function af_select_result(v_udachi, v_virogd, virogd, cel, komp)
	local rnd = math.random(0,100)
	if rnd > v_udachi then -- неудача
		if rnd > v_virogd + v_udachi then -- отторжение
			return komp, false
		else -- вырождение
			return virogd, false
		end
	else -- удача
		return cel, true
	end
end

-- завершаем варку/мутации
-- может быть много результатов
function af_transform_universal_end( params )

	-- для совместимости со старыми варками
	local count = 0
	for k, v in pairs(split_comma_separated_list(params.result)) do
		count = count + 1
	end
	
	if count > 0 then
		local anom_pos = vector():set(params.pos.x, params.pos.y, params.pos.z)
		if db.actor:position():distance_to(anom_pos) < 15 then
			level.add_pp_effector("teleport.ppe", 1524, false)
		end
		
		-- формируем строку с названиями компонентов
		local from_komp = ""
		for k,v in pairs(split_comma_separated_list(params.komp)) do
			if k then
				from_komp = from_komp..game.translate_string(news_manager.get_inv_name(v))
			end
		end
		
		-- спавним результат(v)
		for k,v in pairs(split_comma_separated_list(params.result)) do
			local sobj = alife():create(v, vector():set( params.pos.x, params.pos.y + 1, params.pos.z ), params.lv, params.gv)
			level.map_add_object_spot(sobj.id, "red_location", game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_komp)
		end
		news_manager.send_tip(db.actor, game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_komp)
	end
	
	-- удаляем аномалии, если нужно и она не в исклічениях
	-- код взят из turn_off_all()
	if params.remove_anomaly then
		local sobj = alife():object( params.remove_anomaly_id )
		if sobj and game_graph():valid_vertex_id( sobj.m_game_vertex_id ) then
			if is_generated_anomaly( sobj ) then
				dsh_anomaly_detector.remove_restriction( sobj.id )
			end
		end
	end
	return af_sobj
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **   **      BLOWOUT        **   **
--'****************************************************************************
local blowout_phantoms_subscribed

function blowout_phantoms()
  local blow = ogse.load_var("blowout", -1)
  if amk_hideouts.blowout_type() < 2 and blow > 1 and blow < 4 then
    local lname    = level.name()
    local phantoms = amk_hideouts.blowouts_phantoms[ lname ]
    if phantoms and phantoms.count > 0 then
      if blowout_phantoms_subscribed then
        ogse_signals.get_mgr():reschedule( 1000 )
        if not in_hide then
          if math.random() < phantoms.probability then
            if phantom_manager:phantom_count() < phantoms.count then
              local yaw = math.pi * 2.0 * math.random()
              local radius = phantoms.radius * ( math.random() / 2.0 + 0.5 )
              local height = phantoms.height * math.random()
              local a_pos  = db.actor:position()
              local pos    = vector():set(
                math.sin( yaw ) * radius + a_pos.x,
                a_pos.y + height,
                math.cos( yaw ) * radius + a_pos.z
              )
              phantom_manager.spawn_phantom( pos )
            end
          end
        end
      else
        blowout_phantoms_subscribed = {
          signal = "on_update", fun = this.blowout_phantoms,
          script_name = script_name(),
        }
        ogse_signals.get_mgr():subscribe( blowout_phantoms_subscribed )
      end
    end
  elseif blowout_phantoms_subscribed then
    ogse_signals.get_mgr():unsubscribe( blowout_phantoms_subscribed )
    blowout_phantoms_subscribed = nil
  end
end

local blowout_hit_subscribed

function on_blowout_hit_actor()
  local blow = ogse.load_var("blowout", -1)
  if amk_hideouts.blowout_type() == 0 and blow > 1 and blow < 4 then
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():reschedule( 1000 )
      on_blowout_hit( db.actor )
    else
      blowout_hit_subscribed = {
        signal = "on_update", fun = this.on_blowout_hit_actor,
        script_name = script_name(),
      }
      ogse_signals.get_mgr():subscribe( blowout_hit_subscribed )
    end
  else
    in_hide = true
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():unsubscribe( blowout_hit_subscribed )
      blowout_hit_subscribed = nil
    end
  end
end


function on_blowout_hit( npc, hide )
	local bt = amk_hideouts.blowout_type()
	if bt>0 or ogse.load_var("blowout", -1) ~=3 then 
    	if npc:id()==db.actor:id() then in_hide = true end
		return false
	end
	
	local lname=level.name()
	local need_hit
	need_hit=true
	local khit=1
	if hide and hide.zone then
		need_hit = not check_npc_in_hideout(npc,hide)
		if not need_hit then
			if hide.defence then 
				khit=hide.defence
			else
				khit=0
			end
		end
	else
		local hides=amk_hideouts.hide[lname]
		local tmp
		if hides then
			for i,o in ipairs(hides) do
				if o.zone then
					for j,v in ipairs(o.zone) do
						if v.p3 then
							tmp = ogse.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
						else
							tmp = ogse.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
						end
						need_hit = need_hit and not tmp
						if tmp then
							if o.defence then 
								khit=o.defence
							else
								khit=0
							end
						end
					end
				end
			end
		end
	end

    if npc:id()==db.actor:id() then
                if not need_hit then
                        db.actor.blowout_outside = nil
                end
                if outfit_hideout() then -- защита от выброса броником
                        need_hit = false
                        khit = 0
                else
                        khit = khit+khit*level.get_game_difficulty()/6  -- усиление хита для актора, чтобы вне укрытия не пережил
                end
                in_hide = not need_hit
        end
    if (need_hit or khit>0) and ogse.load_var("blowout", -1) == 3 and not (hide and hide.hidden) then
		local h = hit()
    	h.power = (amk_hideouts.blowout_damages[lname] or 0.01)*khit
    	h.impulse = 0
		h.draftsman = npc
		h.direction = vector():set(0,0,0)
                h:bone("bip01_spine") -- чтобv учитvвалась броня
        h.type = hit.strike
                npc:hit(h)
        h.type = hit.telepatic
                npc:hit(h)
        h.type = hit.radiation
                npc:hit(h)
    end
    return need_hit or khit>0
end


function outfit_hideout()
        local outfits = {
                ["nano_outfit"] = true
        }
        return db.actor:item_in_slot(6) and outfits[db.actor:item_in_slot(6):section()]
end

function check_npc_in_hideout(npc,hide)
        local not_in_zone=true
        if hide and hide.zone then
                for k,v in pairs(hide.zone) do
                        if v.p3 then 
                                not_in_zone = not_in_zone and not ogse.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
                        else
                                not_in_zone = not_in_zone and not ogse.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
                        end
                end
        end
        return not not_in_zone
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **    **      RECEPTS       **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function check_usable_item(obj)
	if obj:name()=="mil_stalker0012" then
		db.actor:give_info_portion("info_amk_recipt_stone_dikoobraz")
	elseif obj:section()=="amk_zapiska" then
		if level.name()=="l01_escape" then
			db.actor:give_info_portion("info_amk_recipt_shkura")
			ogse.remove_inv_items_by_section(obj)
		elseif level.name()=="l04u_labx18" then
			db.actor:give_info_portion("info_amk_recipt_simbion")
			ogse.remove_inv_items_by_section(obj)
		elseif level.name()=="l08u_brainlab" then
			db.actor:give_info_portion("info_amk_recipt_dummy")
			ogse.remove_inv_items_by_section(obj)
		end
	end
	level.map_remove_object_spot(obj:id(), "red_location")
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **     SPAWN_OBJ        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************
function spawn_fuel()
	local ballons = {
		{108.16, -6.30, -18.17, 412158, 115},
		{370.12, 15.06, -39.48, 594401, 0},
		{58.30, 19.36, 156.50, 345136, 97},
		{-92.21, -1.18, -212.66, 115177, 268},
		{-74.17, 1.80, 8.45, 127766, 329},
		{3.18, 1.24, 42.48, 243919, 490},
		{15.35, -1.90, 2.40, 255433, 479},
		{77.54, 0.30, -108.47, 312366, 427},
		{-145.54, -0.00, -199.61, 92520, 650},
		{-130.08, 10.00, -196.67, 109214, 629},
		{-140.13, 10.00, -197.94, 98647, 629},
		{37.28, 1.02, -49.90, 220638, 1084},
		{476.68, -46.94, -0.23, 155714, 1919},
		{76.80, -2.54, -23.93, 36304, 1970},
		{94.78, 0.03, -6.88, 88986, 1514},
		{-3.24, -11.75, -263.07, 33794, 1448}
	}

	local kanisters = {
		{-293.80, -14.18, -15.36, 15703, 67},
		{-16.57, 2.48, 58.82, 260308, 88},
		{-74.81, -1.30, 160.52, 196218, 163},
		{-69.94, 0.97, 6.51, 131411, 329},
		{64.01, 0.60, 148.46, 235341, 364},
		{63.29, -0.20, 5.10, 299326, 461},
		{-28.52, -1.04, -181.84, 211644, 676},
		{2.93, -1.88, -13.30, 176553, 1047},
		{41.71, 4.54, -86.36, 227110, 1100},
		{7.90, 1.41, -71.93, 183138, 1041},
		{158.71, -0.76, -259.73, 358950, 962},
		{-342.92, -13.60, 390.01, 11235, 1847},
		{305.22, -36.99, -24.40, 68330, 1930},
		{55.02, 1.17, 40.35, 68094, 1511},
		{-114.14, -0.00, 121.75, 43453, 1315},
		{31.33, 5.60, -13.51, 4683, 1538}
	}

        for k,v in pairs(ballons) do
                if #v == 5 then
                        local obj = alife():create("amk_ballon",vector():set(v[1], v[2], v[3]), v[4], v[5])
                end
        end

        for k,v in pairs(kanisters) do
                if #v == 5 then
                        local obj = alife():create("amk_kanistra",vector():set(v[1], v[2], v[3]), v[4], v[5])
                end
        end
end

-- БТР на блокпосту
function spawn_military_btr()
	spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-168.11, -29.71, -303.21),81808,38 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
	spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-237.85, -26.23, -378.81),17147,14 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
	spawn_military_tech_pack( alife():create("helicopter",vector():set(-150.0,-40.0,-620.0),128298,11 ) ,"helicopter", "scripts\\esc\\esc_blockpost_heli.ltx")
end

function spawn_military_tech_pack( obj, spawn_item, spawn_item_logic )
  local pk   = get_netpk( obj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", obj:name() )
  local data = pk:get()
  data.custom_data:setString( "[logic]\ncfg = " .. spawn_item_logic )
  if spawn_item == "helicopter" then
    data.engine_sound = "alexmx\\helicopter"
  elseif spawn_item == "vehicle_btr" then
    data.health       = 1
  end
  pk:set( data )
  return obj
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       AMK_RESPAWNS     **   **   **   **   **    **   **   **   
--'*******************************************************************************
function switch_monster_online(obj)
	se_monster.need_be_online[obj.id]=true
end

function switch_monster_offline(obj)
	se_monster.need_be_online[obj.id]=false
end

function respawned(obj,respawner)
	if IsMonster(obj) then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			obj.custom_data = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx"
		end
	elseif IsStalker(obj) then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			obj.custom_data = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx"
		end
	end	
end

local respawners={}

function spawn_unspawned_respawners()

	for a=1,65534 do
		local obj = alife():object(a)
		if obj then
			local oini = obj:spawn_ini()
			if oini:line_exist ("respawn", "amk_name") == true then
				local amk_name = utils.cfg_get_string(oini, "respawn", "amk_name", false, false, false, false)
				if amk_name then respawners[amk_name]=true end
			end
		end
	end

	local sini = ini_file("scripts\\amk\\amk_respawns.ltx")
	
	local dv={}
	if sini:section_exist("default_values") then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("default_values")-1 do
			result, id, value = sini:r_line("default_values",a,"","")
			if id~=nil and xrs_utils.trim(id)~="" and xrs_utils.trim(id)~=nil then
				dv[xrs_utils.trim(id)]=xrs_utils.trim(value)
			end
		end
	end

	if sini:section_exist("amk_respawns") then
		local tmp={}
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("amk_respawns")-1 do
			result, id, value = sini:r_line("amk_respawns",a,"","")
			if id~=nil and xrs_utils.trim(id)~="" and xrs_utils.trim(id)~=nil then
				table.insert(tmp, xrs_utils.trim(id))
			end
		end
		
		for k,v in pairs(tmp) do
			local flag = utils.cfg_get_bool(sini, "amk_respawns", v, true, false, false)
			if not respawners[v] and flag==true then
				local t = xrs_utils.parse_ini_section_to_array(sini, v)
				local xyzlg = xrs_utils.str_explode(",",t.xyzlg,true)
				local pos = vector():set(tonumber(xyzlg[1]),tonumber(xyzlg[2]),tonumber(xyzlg[3]))
				local respawner = alife():create("respawn",pos,tonumber(xyzlg[4]),tonumber(xyzlg[5]))
				local tbl = xrs_utils.get_spawner_data(respawner)
				t.xyzlg = nil
				t.amk_name = v

				for kkk,vvv in pairs(dv) do
					if t[kkk]==nil then
						t[kkk]=vvv
					end
				end

				tbl.custom = xrs_utils.gen_custom_data({respawn=t})
				xrs_utils.set_spawner_data(tbl, respawner)
				se_respawn.reinit_spawner_params(respawner:name())
			end
			if flag==false then
				local o = se_respawn.get_respawner_by_name(v)
				if o then
					alife():release(o)
				end
			end
		end
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **          OTHER        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************

btrs_friends={}

function build_btrs_table(obj)
	if obj and (obj:is_stalker() and obj:character_community()=="military" and obj:alive()) or obj:section()=="vehicle_btr" then
		btrs_friends[obj:id()] = obj:section()
	end
end