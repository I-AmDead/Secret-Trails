-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- File:  amk_mod .script
-- copyright © AMK TEAM 2007-2008
--
-- добавлена  fenechka by TAG

function attach( sm )
  sm:subscribe({ signal = "on_drop",         fun = this.check_for_af_drop })
  sm:subscribe({ signal = "on_use",          fun = this.treasure_create   })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_actor_spawn    })
end

function on_actor_spawn()
  if db.actor:has_info( "blowout" ) then
    on_blowout_hit_actor()
    blowout_phantoms()
  end
  if level.name() == "l10_radar" then
    if not has_alife_info( "esc_serious_talk" ) then
      ogse_signals.get_mgr():subscribe({
        signal = "on_update", fun = this.check_radar_off,
        script_name = script_name(),
      })
    end
  end
end


function treasure_create(obj)
	local section = obj:section()
	if section=="treasure_item" then
        if news_main then
            news_main.create_treasurebox()
        end
	end
end


local afs = {}
-- аномалия "узнаётся" по части названия!
-- komp - компонентv
-- удача v_udachi + вvрождение в булvжник v_virogd <= 100 !!!
-- отторжение v_ottorg = 100 - (v_udachi + v_virogd) посему и не нужно прописvвать в таблицу
-- cel - цель (может бvть одновременно несколько целей)
-- info - инфопорция, которая будет вvдана после L-L+=+Ј варки
-- virogd - во что вvрождается (может бvть одновременно несколько вvрождений)
-- vremya = {дни, часы, минуты} - время варки/мутации
-- remove_anomaly - удалить ли аномалию (можно комбинировать вместе с варкой/мутацией)
-- not_for_mutator - рецепт никогда не попадёт в трансмутатор
anom_recept_komp = {}


local math_random = math.random
local math_floor = math.floor
local math_pi = math.pi
local math_sin = math.sin
local math_cos = math.cos
local math_ceil = math.ceil
local string_find = string.find
local string_sub = string.sub

local nrg,med,cnt,gv,lv,w
in_hide=false
local sound_obj_right,sound_obj_left,snd_volume,snd_obj_eq
local dynlasthour
zombied={}

local weather_types={
        l01_escape=1,
        l02_garbage=1,
        l03_agroprom=1,
        l03u_agr_underground=1,
        l04_darkvalley=1,
        l04u_labx18=1,
        l05_bar=1,
        l06_rostok=1,
        l07_military=1,
        l08_yantar=1,
        l08u_brainlab=1,
        l10_radar=1,
        l10u_bunker=1,
        l11_pripyat=1,
        l12_stancia=1,
        l12_stancia_2=1,
        l12u_control_monolith=1,
        l12u_sarcofag=1
}

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        FIRST_RUN          **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
-- Эта функция вызывается первой. Онлайновые объекты недоступны! db.actor недоступен!
function on_game_start()
	math.randomseed (device ():time_global ())
end


function first_run() 
  -- На момент вызова этой функции актор уже доступен - переделано на поршень.
  if has_alife_info( "x_first_run" ) then return end
  
  amk.spawn_item_in_inv("matras")

  amk.spawn_item("x18_zapiska_ruk",vector():set( 21.6, -3.94, -18.28 ), 1140, 5991 )
  amk.spawn_item("x16_zapiska_ruk",vector():set( -128.0, 22.5, -30.0), 1543, 7083 )

  local obj = alife():story_object(830)
  if obj then
  	alife():release(obj)
  	alife():create(6132)
  end

  amk_anoms.pre_blow_off()
  amk_anoms.after_blow_on()
  spawn_military_btr()	
  spawn_fuel()

  local objt = alife():story_object( 6002 )
  if objt then
    alife():release( objt )
  end
  dsh_alife.invalidate_items()

  db.actor:give_info_portion( "x_first_run" )
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **        CHECK_SPAWN          **   *
--'****************************************************************************

local weather_on_load

function check_spawn()
  amk_anoms.init()
  spawn_unspawned_respawners() 
  news_main.init()
  amk_offline_alife.update_trade()
  amk_offline_alife.update_npc_tables()

  -- level_changers section
  local lname = level.name()
  local sname = amk.load_variable( "level_on_save", "" )
  if lname == "l01_escape" and sname == "l04_darkvalley" then
    local obj = alife():story_object( 6002 )
    if not obj then
      obj = alife():create( 111 )
    end
  end
  if sname == "l01_escape" and lname == "l04_darkvalley" then
    db.actor:set_actor_position( vector():set( -44.38, 0.43, -541.47 ) )
  end

  obj = alife():story_object(6001)
  if obj then
  	level.map_add_object_spot(obj.id, "level_changer", "to_pripyat")
  end

  obj = alife():story_object(6002)
  if obj then
  	level.map_add_object_spot(obj.id, "level_changer", "to_darkvalley")
  end
  
  if (amk_offline_alife) then
  	amk_offline_alife.init()
  end

  if (amk_corpses) then
  	amk_corpses.init()
  end

  if (amk_objects) then
  	amk_objects.init()
  end

  local obj = alife():story_object(6000)
  if not obj then
  	alife():create(6520)
  	obj = alife():story_object(6000)
  end

  if (amk_corpses) then
  	amk_corpses.update_all_corpses()
  end
  if lname ~= sname and amk_objects then 
  	amk_objects.update() 
  end

  if amk.load_variable("freeplay",0)==1 then
  	amk.save_variable("freeplay",2)
  elseif amk.load_variable("freeplay",0)==2 and (not has_alife_info("cit_fail_first_task")) then
  	db.actor:give_info_portion("cit_fail_first_task")
  end
 
  braad_test.delete_new_lc(833,"info_way_pripyat")
  braad_test.delete_new_lc(1007,"info_way_radar")

  restore_sun()
end


function restore_sun()
  -- level.set_weather( weather_on_load, true )
  local lname = level.name()
  local sname = amk.load_variable( "level_on_save", "" )
  amk.save_variable( "level_on_save", lname )
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **         FREEPLAY           **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function freeplay()
	amk.save_variable("freeplay",1)
	
	local obj = alife():story_object(6001)
	if not obj then
		alife():create(6304)
	end

	for a=1,5 do
		amk_anoms.after_blow_on()
	end
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **      RADAR_FIX         **   **   *
--'****************************************************************************


function check_radar_off()
	ogse_signals.get_mgr():reschedule( 1000 )
	if not has_alife_info("esc_serious_talk") then
		local pos = db.actor:position()
    	if pos.z > 65 and pos.x > 350 and pos.x < 410 then
      		if not ogse.var_exists("radar_fix") then
        		level.add_pp_effector( "fire_hit.ppe", 1523, true )
        		level.set_pp_effector_factor( 1523, 0.5 )
        		ogse.save_var("radar_fix", true)
				ogse_st_mgr.start_timer("radar_fix", 5, "amk_mod.radar_fix")
			end
		end
	end
end

function radar_fix()
	level.remove_pp_effector( 1523 )
	local pos = db.actor:position()
	if pos.z > 65 and pos.x > 350 and pos.x < 410 then
		db.actor:kill( db.actor )
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      AF_TRANSFORM         **   **   **   **   **    **   **   **
--'*******************************************************************************
local cur_level=nil
local havegoodart=false

-- список компонентов
-- желательно добавлять в алфавитном порядке
local afs={
["af_ameba_mica"] = true,
["af_ameba_slime"] = true,
["af_ameba_slug"] = true,
["af_armor_1"] = true,
["af_armor_2"] = true,
["af_armor_3"] = true,
["af_babka_1"] = true,
["af_babka_2"] = true,
["af_babka_3"] = true,
["af_blood"] = true,
["af_buliz"] = true,
["af_cristall"] = true,
["af_cristall_flower"] = true,
["af_cry_1"] = true,
["af_cry_2"] = true,
["af_cry_3"] = true,
["af_dik_1"] = true,
["af_dik_2"] = true,
["af_dik_3"] = true,
["af_drops"] = true,
["af_dummy_battery"] = true,
["af_dummy_battery_red"] = true,
["af_dummy_dummy"] = true,
["af_dummy_glassbeads"] = true,
["af_dummy_pellicle"] = true,
["af_dummy_pellicle_red"] = true,
["af_dummy_spring"] = true,
["af_dummy_spring_red"] = true,
["af_electra_flash"] = true,
["af_electra_moonlight"] = true,
["af_electra_sparkler"] = true,
["af_fireball"] = true,
["af_fuzz_kolobok"] = true,
["af_gold_fish"] = true,
["af_gravi"] = true,
["af_kamen_udachy"] = true,
["af_kol_1"] = true,
["af_kol_2"] = true,
["af_kol_3"] = true,
["af_medusa"] = true,
["af_mincer_meat"] = true,
["af_night_star"] = true,
["af_part_monolit2"] = true,
["af_pudd_1"] = true,
["af_pudd_2"] = true,
["af_pudd_3"] = true,
["af_rusty_kristall"] = true,
["af_rusty_sea-urchin"] = true,
["af_rusty_thorn"] = true,
["af_simbion"] = true,
["af_soul"] = true,
["af_spirit_1"] = true,
["af_spirit_2"] = true,
["af_spirit_3"] = true
}

-- проверка на упавший предмет/артефакт
function check_for_af_drop(obj)
  local obj_sect = obj:section()
	-- проверка не один ли это из компонентов
  if not is_komponent( obj_sect, obj:condition() ) then return end
  local anom_id, anom_pos, anom_radius, dist =
    amk_anoms.get_nearest_anomaly( db.actor )
  if not ( anom_id and dist < 3 ) then return end
  local lv = level.object_by_id(anom_id):level_vertex_id()
  local gv = level.object_by_id(anom_id):game_vertex_id()
  if gv == 65535 then gv = obj:game_vertex_id() end
  if gv == 65535 then gv = db.actor:game_vertex_id() end
  if gv == 65535 then return end -- похоже, что рядом нету вертекса
			
  -- предмет подходит - отправляем его на экспертизу
  -- узнаем не съели ли его или вvложили в нvчку
  local tbl		= {}
  tbl.obj_id		= obj:id()
  tbl.anom_id		= anom_id
  tbl.anom_radius	= anom_radius
  tbl.lv			= lv
  tbl.gv			= gv
  amk.start_timer("timer_drop_obj_varka", 0.2, tbl)
end

-- проверка: является ли компонентом для варки
-- параметр - название секции
function is_komponent(sect)
     return afs[sect]
end

-- аномали "узнаітся" по части названия!
-- komp - компонентv
-- удача v_udachi + вvрождение в булvжник v_virogd <= 100 !!!
-- отторжение v_ottorg = 100 - (v_udachi + v_virogd) посему и не нужно прописvвать в таблицу
-- cel - цель (может бvть одновременно несколько целей)
-- info - инфопорция, которая будет вvдана после L-L+=+Ј варки
-- virogd - во что вvрождается (может бvть одновременно несколько вvрождений)
-- vremya = {дни, часv, минутv} - время варки/мутации
-- remove_anomaly - удалить ли аномалиі (можно комбинировать вместе с варкой/мутацией)
-- not_for_mutator - рецепт никогда не попадїт в трансмутатор
-- ne_ugadat -  рецепт не угадvвается в трансмутаторе, но будет в нїм показан при наличии поршня
local anom_recept_komp = {
	-- умолчание, если нет даннvх ближе к рецепту
	default = {
		cel = {},
		v_udachi = 80,
		v_virogd = 17,
		virogd = {["af_buliz"]=true},
		vremya = {0,0,5},
		remove_anomaly = false
	},
	
	anomalii = {
		["_zharka"] = {
			-- умолчание, если нет даннvх ближе к рецепту,
			-- которое может переопределятья в рецепте
			name = "\"Жарка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_drops"] = {
					komp = {["af_soul"]=true},
					cel = {["af_spirit_1"]=true},
					vremya = {0,4,0}
				},


				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_fire"] = {
					komp = {["af_spirit_1"]=true},
					cel = {["af_spirit_2"]=true},
					vremya = {0,6,0}
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_cristal"] = {
					komp = {["af_spirit_2"]=true},
					cel = {["af_spirit_3"]=true},
					vremya = {0,10,0}
				},
				["info_amk_recipt_tears_fire"] = {
					komp = {["af_cry_1"]=true},
					cel = {["af_cry_2"]=true},
					vremya = {0,6,0}
				},
				["info_amk_recipt_dikoobraz"] = {
					komp = {["af_rusty_sea-urchin"]=true},
					cel = {["af_dik_1"]=true},
					vremya = {0,3,0}
				},
				["info_amk_recipt_giant_small_brother"] = {
					komp = {["af_kol_3"]=true},
					cel = {["af_kol_4"]=true},
					vremya = {0,3,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_controller_skalp"] = {
					komp = {["af_armor_3"]=true},
					cel = {["af_armor_4"]=true},
					vremya = {0,6,0},
					v_udachi = 100,
					v_virogd = 0
				}
			}
		},
		
		["_galant"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Электра\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_battery"] = { -- артефакт удалит аномалииі без результатов варки/мутации
					komp = {["af_dummy_battery_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_bengal"] = {
					komp = {["af_spirit_3"]=true},
					cel = {["af_spirit_4"]=true},
					vremya = {0,1,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_tears_electra"] = {
					komp = {["af_drops"]=true},
					cel = {["af_cry_1"]=true},
					vremya = {0,5,0}
				},
				["info_amk_recipt_grandmother_glassbeards"] = {
					komp = {["af_dummy_glassbeads"]=true},
					cel = {["af_babka_1"]=true},
					vremya = {0,5,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_fire"] = {
					komp = {["af_dummy_dummy"]=true},
					cel = {["af_pudd_1"]=true},
					vremya = {0,3,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_bright"] = {
					komp = {["af_pudd_1"]=true},
					cel = {["af_pudd_2"]=true},
					vremya = {0,6,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_moon"] = {
					komp = {["af_pudd_2"]=true},
					cel = {["af_pudd_3"]=true},
					vremya = {0,8,0}
				},
				["info_amk_recipt_electra_dikoobraz"] = {
					komp = {["af_dik_1"]=true},
					cel = {["af_dik_2"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["_buzz"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Холодец\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_amk_recipt_tears_chimaera"] = {
					komp = {["af_cry_2"]=true},
					cel = {["af_cry_3"]=true},
					vremya = {0,2,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_pra_grandmother_glassbeards"] = {
					komp = {["af_babka_1"]=true},
					cel = {["af_babka_2"]=true},
					vremya = {0,3,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_puding"] = {
					komp = {["af_pudd_3"]=true},
					cel = {["af_pudd_4"]=true},
					vremya = {0,12,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_sopl_dikoobraz"] = {
					komp = {["af_dik_2"]=true},
					cel = {["af_dik_3"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_almaz_kolobok"] = {
					komp = {["af_kol_2"]=true},
					cel = {["af_kol_3"]=true},
					vremya = {0,8,0}
				},
				["info_amk_recipt_pancir"] = {
					komp = {["af_armor_2"]=true},
					cel = {["af_armor_3"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_simbion"] = {
					komp = {["af_medusa"]=true,["af_drops"]=true,["af_blood"]=true,["af_rusty_thorn"]=true},
					cel = {["af_simbion"]=true},
					vremya = {0,4,0}
				}
			}
		},
		
		
		["_mincer"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Карусель\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_spring"] = { -- артефакт удалит аномалиі без результатов варки/мутации
					komp = {["af_dummy_spring_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["info_amk_recipt_burer_grandmother_glassbeards"] = {
					komp = {["af_babka_2"]=true},
					cel = {["af_babka_3"]=true},
					vremya = {0,0,10}
				},
				["info_amk_recipt_titan_kolobok"] = {
					komp = {["af_kol_1"]=true},
					cel = {["af_kol_2"]=true},
					vremya = {0,5,0}
				},
				["info_amk_recipt_cheshya"] = {
					komp = {["af_armor_1"]=true},
					cel = {["af_armor_2"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["_mosquito_bald"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Tрамплин\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_pellicle"] = { -- артефакт удалит аномалиі без результатов варки/мутации
					komp = {["af_dummy_pellicle_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["info_amk_recipt_stone_dikoobraz"] = {
					komp = {["af_dik_3"]=true},
					cel = {["af_dik_4"]=true},
					vremya = {0,9,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_steel_kolobok"] = {
					komp = {["af_fuzz_kolobok"]=true},
					cel = {["af_kol_1"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_shkura"] = {
					komp = {["af_dummy_pellicle"]=true},
					cel = {["af_armor_1"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["_gravi_zone"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Воронка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_battery"] = { -- артефакт удалит аномалиі без результатов варки/мутации
					komp = {["af_dummy_battery_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				}
			}
		},
		
		["_ice"] = {
			-- умолчание, если нет даннvх ближе к рецепту
			name = "\"Морозилка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_red_battery"] = {
					komp = {["af_dummy_battery"]=true},
					cel = {["af_dummy_battery_red"]=true}
				},
				["info_red_spring"] = {
					komp = {["af_dummy_spring"]=true},
					cel = {["af_dummy_spring_red"]=true}
				},
				["info_red_pellicle"] = {
					komp = {["af_dummy_pellicle"]=true},
					cel = {["af_dummy_pellicle_red"]=true}
				}
			}
		}
	}
}

-- возвра ает значение, возможно из умолчаний
local res2key = {
	[0] = "komp",	-- РѕС‚С‚РѕСЂР¶РµРЅРёРµ
	[1] = "virogd",	-- РІС‹СЂРѕР¶РґРµРЅРёРµ
	[2] = "cel"		-- СѓРґР°С‡Р°
}
function get_af_transform_param(name, recept, recepti)
	local result
	if recept[name] ~= nil then
		result = recept[name]
	elseif recepti["default"] ~= nil and recepti["default"][name] ~= nil then
		result = recepti["default"][name]
	elseif anom_recept_komp["default"] ~= nil and anom_recept_komp["default"][name] ~= nil then
		result = anom_recept_komp["default"][name]
	else
		-- нет информации!!!
		amk.send_tip("нет информации для "..name.."!","варка артефактов",0,15,"gen_info")
		result = nil
	end
	return result
end

-- іолучаем полнvй набор рецептов для аномалии anom_sect
function fill_recepti_est(anom_sect)
	local recepti_est = {} -- рецептv для заданной аномалии
	local anom_name = nil
	for anom, recepti in pairs(anom_recept_komp["anomalii"]) do
		if string_find(anom_sect, anom) ~= nil then --нашли в списке аномалиі.
			anom_name = anom_recept_komp["anomalii"][anom]["name"]
			if anom_recept_komp["anomalii"][anom]["recepti"] then
				for info, recept in pairs(recepti["recepti"]) do
					if not recept["not_for_mutator"] and not recept["remove_anomaly"] and (db.actor:has_info(info) or not recept["ne_ugadat"]) then
						recepti_est[info] = {}
						for k, v in pairs(recept) do
							if type(v) == "table" then
								recepti_est[info][k] = {}
								for i, j in pairs(v) do
									recepti_est[info][k][i] = j
								end
							else
								recepti_est[info][k] = v
							end
						end
					-- end
					end
				end
			end
		end
	end
	return recepti_est,anom_name
end

-- проверяет рецептv и компонетv
-- если всї в порядке - запускает варку/мутациі
function check_af_transform(af, af_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv)
	local actor = db.actor
	
	--поиск по аномалиям
	local finish = false -- флаг для вvхода из циклов
	for anom, recepti in pairs(anom_recept_komp["anomalii"]) do
		if string_find(anom_sect, anom) ~= nil then --нашли в списке аномалиі, возле которой стоим
			local recepti_est = {} -- рецептv в наличии у ++, в которvх участвует даннvй компонент
			local recept_podhodit = false
			
			-- собираем рецептv, в которvх участвует даннvй компонент
			for info, recept in pairs(recepti["recepti"]) do
				if actor:has_info(info) and recept["komp"][af_sect] == true then --есть рецепт и этот компонент в нїм участвует
					recept_podhodit = true
					-- копируем рецепт
					recepti_est[info] = {}
					for k, v in pairs(recept) do
						if type(v) == "table" then
							recepti_est[info][k] = {}
							for i, j in pairs(v) do
								recepti_est[info][k][i] = j
							end
						else
							recepti_est[info][k] = v
						end
					end
					-- так как table.getn() как и оператор # не работаіт с таблицами, у которvх не целочисельнvе индексv,
					-- то считаем количество в ручнуі
					local count = 0
					for k,v in pairs(recepti_est[info]["komp"]) do
						count = count + 1
					end
					recepti_est[info]["count"] = count
					--get_console():execute("load ~#I#:"..string.format("0 "..af_sect.." принят. Lном: "..anom.." рец. "..info.." "..recepti_est[info]["count"]))
				end
			end
			
			if recept_podhodit then -- если нашли хоть один имеіийся подходяий рецепт
				--amk.send_tip("іецепт подошел. anom_radius "..anom_radius," варка",0,15,"gen_info")
				--ием рядом другие компонентv
				--если находим их в вvбраннvх рецептах, то удаляем их из рецептов
				--как только какой-то рецепт остаїтся без компонентов - рецепт сработал
				local obj
				for i=1,65534 do
					obj = level.object_by_id(i)
					if obj and alife():object(i) then
						local dist = obj:position():distance_to(anom_pos)
						if obj:parent() == nil and ((anom_radius - obj:position():distance_to(anom_pos)) > -2) then
							local obj_sect = obj:section()
							--get_console():execute("load ~#I#:"..string.format(" obj_sect: "..obj_sect.." dist: "..dist))
							--проверяем отобраннvе рецептv
							for info, recept in pairs(recepti_est) do
								-- если компонент есть в рецепте
								if recepti_est[info]["komp"][obj_sect] == true then
									-- добавляем L- компонента для буду его удаления из игрv
									recepti_est[info]["komp"][obj_sect] = obj:id()
									-- уменьшаем количество компонентов в рецепте
									recepti_est[info]["count"] = recepti_est[info]["count"] - 1
									--amk.send_tip(obj_sect.." найден. Lном: "..anom.." рец. "..info.." "..recepti_est[info]["count"],"варка",0,15,"gen_info")
									--get_console():execute("load ~#I#:"..string.format(obj_sect.." найден. Lном: "..anom.." рец. "..info.." "..recepti_est[info]["count"]))
									
									-- если рецепт пуст, то он сработал
									if recepti_est[info]["count"] == 0 then
										--get_console():execute("load ~#I#:"..string.format(info.." сработал. Lном: "..anom))
										
										-- устанавливаем все параметрv для рецепта, возможно из умолчаний
										local cel		= get_af_transform_param("cel", recepti_est[info], recepti)
										local v_udachi		= get_af_transform_param("v_udachi", recepti_est[info], recepti)
										local v_virogd		= get_af_transform_param("v_virogd", recepti_est[info], recepti)
										local virogd		= get_af_transform_param("virogd", recepti_est[info], recepti)
										local vremya		= get_af_transform_param("vremya", recepti_est[info], recepti)
										local remove_anomaly	= get_af_transform_param("remove_anomaly", recepti_est[info], recepti)
										local remove_anomaly_id = anom_id
										local komp		= recepti_est[info]["komp"]
										local result, udacha 	= af_select_result(v_udachi, v_virogd, virogd, cel, komp)
										local info_portion	= recepti_est[info]["info"]
										
										if cel == nil or v_udachi == nil or v_virogd == nil
											or virogd == nil or vremya == nil or remove_anomaly == nil 
											or cel == nil and remove_anomaly == false
											or v_udachi + v_virogd > 100 then
											
											-- кривой рецепт  - вvходим
											finish = true
											break
										end
										
										-- неудача
										if udacha == false then
											remove_anomaly = false
											info_portion = nil
										end

										level.add_pp_effector("teleport.ppe", 1524, false)
										
										-- запускаем варку/мутациі
										as_start_universal_transform_timer(komp, result, obj_pos, vremya, gv, lv, info_portion, remove_anomaly, remove_anomaly_id)
										
										-- удаляем из игрv компонентv рецепта
										for k,v in pairs(komp) do
											alife():release(alife():object(v))
										end
										
										-- вvходим
										finish = true
										break
									end
								end
							end
						end
					end
					
					if finish then break end
				end
			end
			
			-- аномалия с рецептами найдена, все дела сделанv - вvходим
			break
		end
	end

end

function af_flash( obj )
  level.add_pp_effector( "teleport.ppe", 1524, false )
  amk.remove_item( obj )
end

-- случайно выбирает результат, возвращает таблицу с секциями результатов
function af_select_result( v_udachi, v_virogd, virogd, cel, komp )
  local rnd = math_random(0,100)
  if rnd > v_udachi then -- неудача
    if rnd > v_virogd + v_udachi then -- отторжение
      return komp, false
    else -- вырождение
      return virogd, false
    end
  else -- удача
    return cel, true
  end
end

-- запускаем трансофрмациі 
-- результатv могут бvть многочисленнv (несколько целей, полное отторжение компонентов, несколько вvрождений)
function as_start_universal_transform_timer(komp, result, pos, vremya, gv, lv, info_portion, remove_anomaly, remove_anomaly_id)
  local t = { } -- сохраняемvе даннvе
  t.result = result -- можно сохранять сразу таблицv
  t.pos    = {}
  t.pos.x  = pos.x
  t.pos.y  = pos.y
  t.pos.z  = pos.z
  t.gv     = gv
  t.lv     = lv
  t.info_portion = info_portion
  t.komp   = komp -- можно сохранять сразу таблицv
  t.remove_anomaly    = remove_anomaly
  t.remove_anomaly_id = remove_anomaly_id
  amk.g_start_timer("af_transform_universal", vremya[1], vremya[2], vremya[3], t)
end


-- старая фунция
function af_start_transform(v1,v2,af_from,af_target)
	local rnd=math_random(0,100)
	if rnd>v1 then
		if rnd>v2+v1 then
			return af_from
		else
			return "af_buliz"
		end
	else
		return af_target
	end
end

-- старая фунция
function af_start_transform_timer(af,pos,delay_d,delay_h,delay_m,af_sect)
	local t={}
	t.section=af
	t.pos={}
		t.pos.x=pos.x
		t.pos.y=pos.y
		t.pos.z=pos.z
	t.gv=gv
	t.lv=lv
	t.from_sect=af_sect
	amk.g_start_timer("af_transform",delay_d,delay_h,delay_m,t)
end


-- завершаем варку/мутации
-- может быть много результатов
function af_transform_universal_end( params )
  -- для совместимости со старыми варками
	local count = 0
	for k, v in pairs(params.result) do
		count = count + 1
	end
	if count > 0 then
		local anom_pos = vector():set(params.pos.x, params.pos.y, params.pos.z)
		if db.actor:position():distance_to(anom_pos) < 15 then
			level.add_pp_effector("teleport.ppe", 1524, false)
		end
		-- формируем строку с названиями компонентов
		local from_komp = ""
		for k,v in pairs(params.komp) do
			if k then
				from_komp = from_komp..game.translate_string(news_manager.get_inv_name(k))..", "
			end
		end
		-- отсекаем ", " в хвосте
		from_komp = string_sub(from_komp, 1, -2)
		
		-- спавним результат(v)
		for k,v in pairs(params.result) do
			af_sobj = amk.spawn_item(k, vector():set( params.pos.x, params.pos.y + 1, params.pos.z ), params.gv, params.lv)
			amk.add_spot_on_map(af_sobj.id, "red_location", game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_komp)
		end
		amk.send_tip(game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_komp)
	end
	
	-- даїм инфопорциі, если есть
	if params.info_portion and db.actor:dont_has_info(params.info_portion) then
		db.actor:give_info_portion(params.info_portion)
	end
	
	-- удаляем аномалии, если нужно и она не в исклічениях
	-- код взят из amk_anoms.turn_off_all()
	if params.remove_anomaly then
    local sobj = alife():object( params.remove_anomaly_id )
    if sobj and game_graph():valid_vertex_id( sobj.m_game_vertex_id ) then
      if is_generated_anomaly( sobj ) then
        dsh_anomaly_detector.remove_restriction( nil, sobj.id )
      end
    end
  end
  return af_sobj
end


-- старая функция
function af_transform_end(params)
	local from_sect="\""..params.from_sect.."\""
	local obj
        obj=amk.spawn_item(params.section,vector():set(params.pos.x,params.pos.y+10,params.pos.z),params.gv,params.lv)
	local sobj = alife():object( obj.id )
	alife():use_ai_locations(sobj, false)
	amk.add_spot_on_map(obj.id,"red_location",game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_sect)
	amk.send_tip(game.translate_string("trans_finished_title").."%c[255,255,0,0]"..from_sect)
end


--'****************************************************************************
--'   **   **   **   **   **    **   **   **   **      BLOWOUT        **   **
--'****************************************************************************
local blowout_phantoms_subscribed

function blowout_phantoms()
  local blow = amk.load_variable( "blowout", -1 )
  if blowout_type() < 2 and blow > 1 and blow < 4 then
    local lname    = level.name()
    local phantoms = amk_hideouts.blowouts_phantoms[ lname ]
    if phantoms and phantoms.count > 0 then
      if blowout_phantoms_subscribed then
        ogse_signals.get_mgr():reschedule( 1000 )
        if not in_hide then
          if math.random() < phantoms.probability then
            if phantom_manager:phantom_count() < phantoms.count then
              local yaw = math_pi * 2.0 * math.random()
              local radius = phantoms.radius * ( math.random() / 2.0 + 0.5 )
              local height = phantoms.height * math.random()
              local a_pos  = db.actor:position()
              local pos    = vector():set(
                math.sin( yaw ) * radius + a_pos.x,
                a_pos.y + height,
                math.cos( yaw ) * radius + a_pos.z
              )
              phantom_manager.spawn_phantom( pos )
            end
          end
        end
      else
        blowout_phantoms_subscribed = {
          signal = "on_update", fun = this.blowout_phantoms,
          script_name = script_name(),
        }
        ogse_signals.get_mgr():subscribe( blowout_phantoms_subscribed )
      end
    end
  elseif blowout_phantoms_subscribed then
    ogse_signals.get_mgr():unsubscribe( blowout_phantoms_subscribed )
    blowout_phantoms_subscribed = nil
  end
end

local blowout_hit_subscribed

function on_blowout_hit_actor()
  local blow = amk.load_variable( "blowout", -1 )
  if blowout_type() == 0 and blow > 1 and blow < 4 then
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():reschedule( 1000 )
      on_blowout_hit( db.actor )
    else
      blowout_hit_subscribed = {
        signal = "on_update", fun = this.on_blowout_hit_actor,
        script_name = script_name(),
      }
      ogse_signals.get_mgr():subscribe( blowout_hit_subscribed )
    end
  else
    in_hide = true
    if blowout_hit_subscribed then
      ogse_signals.get_mgr():unsubscribe( blowout_hit_subscribed )
      blowout_hit_subscribed = nil
    end
  end
end


function on_blowout_hit( npc, hide )
	local bt=blowout_type()
	if bt>0 or amk.load_variable("blowout",-1)~=3 then 
    if npc:id()==db.actor:id() then in_hide = true end
		return false
	end
	
	local lname=level.name()
	local need_hit
	need_hit=true
	local khit=1
	if hide and hide.zone then
		need_hit = not check_npc_in_hideout(npc,hide)
		if not need_hit then
			if hide.defence then 
				khit=hide.defence
			else
				khit=0
			end
		end
	else
		local hides=amk_hideouts.hide[lname]
		local tmp
		if hides then
			for i,o in ipairs(hides) do
				if o.zone then
					for j,v in ipairs(o.zone) do
						if v.p3 then
							tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
						else
							tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
						end
						need_hit = need_hit and not tmp
						if tmp then
							if o.defence then 
								khit=o.defence
							else
								khit=0
							end
						end
					end
				end
			end
		end
	end

    if npc:id()==db.actor:id() then
                if not need_hit then
                        db.actor.blowout_outside = nil
                end
                if outfit_hideout() then -- защита от выброса броником
                        need_hit = false
                        khit = 0
                else
                        khit = khit+khit*level.get_game_difficulty()/6  -- усиление хита для актора, чтобы вне укрытия не пережил
                end
                in_hide = not need_hit
        end
    if (need_hit or khit>0) and amk.load_variable("blowout",-1)==3 and not (hide and hide.hidden) then
		local h = hit()
    	h.power = (amk_hideouts.blowout_damages[lname] or 0.01)*khit
    	h.impulse = 0
		h.draftsman = npc
		h.direction = vector():set(0,0,0)
                h:bone("bip01_spine") -- чтобv учитvвалась броня
        h.type = hit.strike
                npc:hit(h)
        h.type = hit.telepatic
                npc:hit(h)
        h.type = hit.radiation
                npc:hit(h)
    end
    return need_hit or khit>0
end


function outfit_hideout()
        local outfits = {
                ["nano_outfit"] = true
        }
        return db.actor:item_in_slot(6) and outfits[db.actor:item_in_slot(6):section()]
end

function check_npc_in_hideout(npc,hide)
        local not_in_zone=true
        if hide and hide.zone then
                for k,v in pairs(hide.zone) do
                        if v.p3 then 
                                not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
                        else
                                not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
                        end
                end
        end
        return not not_in_zone
end

function initial_spawn(action)
	local fr=0
	for i=0,amk_hideouts.anom_count-1,1 do
		local sobj = alife():story_object(amk_hideouts.anom_sid0+i)
		if not sobj then 
			alife():create(i+amk_hideouts.anom_num0) 
			fr=1
		end
	end
	if fr==1 then create_anoms() end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       ANOMS SPAWN        **   **   **   **   **    **   **   **   
--'*******************************************************************************
anomalies_state={}

function remove_anoms()
        amk.save_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
	update_anoms()
end

function create_anoms()
	anomalies_state={}
	for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
                anomalies_state[i]=math_random(0,1)==1
	end
	local str=pack_anoms(anomalies_state)
	amk.save_variable("blowout_anoms",str)
	update_anoms()
end

function update_anoms()
        local anoms=amk.load_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
	anomalies_state=unpack_anoms(anoms)
	for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
		local sobj = alife():story_object(i)
		if sobj then
			local obj=level.object_by_id(sobj.id)
			if obj then
				if anomalies_state[i] then
					obj:enable_anomaly()
				else
					obj:disable_anomaly()
				end
			end
		end
    end
end

-- anom_state[sid]==true для активнvх аномалий
function pack_anoms(anom_state)
	local str=""
	for i=0,amk_hideouts.anom_count-1,7 do
		local cval=128
		local mul=1
		for j=0,6,1 do
			if anom_state[i+j+amk_hideouts.anom_sid0] then
				cval=cval+mul
			end
		mul=mul*2
		end
    str=str..string.char(cval)
	end
	return str
end

function unpack_anoms(str)
	local anom={}
	for i=1,string.len(str),1 do
                local cval=string.byte(string_sub(str,i,i))
		local mul=1
		for j=0,6,1 do
			anom[(i-1)*7+j+amk_hideouts.anom_sid0]=bit_and(mul,cval)~=0
			mul=mul*2
		end
	end
	return anom
end

function blowout_type()
	local lname=level.name()
local blow_type = amk_hideouts.blowout_types[lname]
return blow_type or 0
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **    **      RECEPTS       **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function check_usable_item(obj)
	local info=nil
	if obj:section()=="vehicle_btr" then
		db.actor:kill(db.actor)
	end
	if obj:name()=="mil_stalker0012" then
		info="info_amk_recipt_stone_dikoobraz"
	elseif level.name()=="l01_escape" and obj:section()=="amk_zapiska" then
		info="info_amk_recipt_shkura"
		amk.drop_item(db.actor,obj)
		amk.remove_item(obj)
	elseif level.name()=="l04u_labx18" and obj:section()=="amk_zapiska" then
		info="info_amk_recipt_simbion"
		amk.drop_item(db.actor,obj)
		amk.remove_item(obj)
	elseif level.name()=="l08u_brainlab" and obj:section()=="amk_zapiska" then
		info="info_amk_recipt_dummy"
		amk.drop_item(db.actor,obj)
		amk.remove_item(obj)
	else
		local recipes=amk.load_table("amk_body_recipe")
		info=recipes[obj:id()]
	end  
	if db.actor==nil or info==nil or db.actor:has_info(info) then
		return
	end
	db.actor:give_info_portion(info)
	amk_dialogs.info_received()
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **     SPAWN_OBJ        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************
function spawn_fuel()
	local ballons = {
	{108.16, -6.30, -18.17, 412158, 115},
	{370.12, 15.06, -39.48, 594401, 0},
	{58.30, 19.36, 156.50, 345136, 97},
	{-92.21, -1.18, -212.66, 115177, 268},
	{-74.17, 1.80, 8.45, 127766, 329},
	{3.18, 1.24, 42.48, 243919, 490},
	{15.35, -1.90, 2.40, 255433, 479},
	{77.54, 0.30, -108.47, 312366, 427},
	{-145.54, -0.00, -199.61, 92520, 650},
	{-130.08, 10.00, -196.67, 109214, 629},
	{-140.13, 10.00, -197.94, 98647, 629},
	{37.28, 1.02, -49.90, 220638, 1084},
	{476.68, -46.94, -0.23, 155714, 1919},
	{76.80, -2.54, -23.93, 36304, 1970},
	{94.78, 0.03, -6.88, 88986, 1514},
	{-3.24, -11.75, -263.07, 33794, 1448}
	}
	local kanisters = {
	{-293.80, -14.18, -15.36, 15703, 67},
	{-16.57, 2.48, 58.82, 260308, 88},
	{-74.81, -1.30, 160.52, 196218, 163},
	{-69.94, 0.97, 6.51, 131411, 329},
	{64.01, 0.60, 148.46, 235341, 364},
	{63.29, -0.20, 5.10, 299326, 461},
	{-28.52, -1.04, -181.84, 211644, 676},
	{2.93, -1.88, -13.30, 176553, 1047},
	{41.71, 4.54, -86.36, 227110, 1100},
	{7.90, 1.41, -71.93, 183138, 1041},
	{158.71, -0.76, -259.73, 358950, 962},
	{-342.92, -13.60, 390.01, 11235, 1847},
	{305.22, -36.99, -24.40, 68330, 1930},
	{55.02, 1.17, 40.35, 68094, 1511},
	{-114.14, -0.00, 121.75, 43453, 1315},
	{31.33, 5.60, -13.51, 4683, 1538}
	}
        for k,v in pairs(ballons) do
                if #v == 5 then
                        local obj = alife():create("amk_ballon",vector():set(v[1], v[2], v[3]), v[4], v[5])
                end
        end
        for k,v in pairs(kanisters) do
                if #v == 5 then
                        local obj = alife():create("amk_kanistra",vector():set(v[1], v[2], v[3]), v[4], v[5])
                end
        end
end

-- БТР на блокпосту
function spawn_military_btr()
	spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-168.11, -29.71, -303.21),81808,38 ) ,"vehicle_btr")
	spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-237.85, -26.23, -378.81),17147,14 ) ,"vehicle_btr")
	spawn_military_tech_pack( alife():create("helicopter",vector():set(-150.0,-40.0,-620.0),128298,11 ) ,"helicopter")
end

function spawn_military_tech_pack(obj, spawn_item)	
	local packet = net_packet()
	obj:STATE_Write(packet)

	-- свойства cse_alife_object
	local game_vertex_id = packet:r_u16()
	local cse_alife_object__unk1_f32 = packet:r_float()
	local cse_alife_object__unk2_s32 = packet:r_s32()
	local level_vertex_id = packet:r_s32()
	local object_flags = packet:r_s32()
	local custom_data = packet:r_stringZ()
	local story_id = packet:r_s32()
	local cse_alife_object__unk3_s32 = packet:r_s32()

	-- свойства cse_visual
	local model_visual = packet:r_stringZ()
	local cse_visual__unk1_u8 = packet:r_u8()
	local motion_name
	if spawn_item == "helicopter" then
		-- свойства cse_motion
		motion_name = packet:r_stringZ()
	end

	-- свойства cse_ph_skeleton
	local skeleton_name = packet:r_stringZ()
	local cse_ph_skeleton__unk1_u8 = packet:r_u8()
	local cse_ph_skeleton__unk2_u16 = packet:r_u16()
	local health 
	local cse_alife_helicopter__unk1_sz 
	local engine_sound 
		
	if spawn_item == "helicopter" then
		-- свойства cse_alife_helicopter
		cse_alife_helicopter__unk1_sz = packet:r_stringZ()
		engine_sound = packet:r_stringZ()
	elseif	spawn_item == "vehicle_btr" then
		health = packet:r_float()
	end
	
	-- теперь заполняем нужные параметры
	-- свойства cse_alife_object
	packet:w_begin(game_vertex_id)
	packet:w_float(cse_alife_object__unk1_f32)
	packet:w_s32(cse_alife_object__unk2_s32)
	packet:w_s32(level_vertex_id)
	object_flags = bit_not(5)	-- ~5 = 0xfffffffa
	packet:w_s32(object_flags)
	if spawn_item == "helicopter" then
		packet:w_stringZ("[logic]\ncfg = scripts\\esc\\esc_blockpost_heli.ltx")
	elseif	spawn_item == "vehicle_btr" then
		packet:w_stringZ("[logic]\ncfg = scripts\\esc\\esc_blockpost_btr.ltx")
	end
	packet:w_s32(-1)
	packet:w_s32(cse_alife_object__unk3_s32)

	-- свойства cse_visual
	packet:w_stringZ(model_visual)
	packet:w_u8(cse_visual__unk1_u8)
	
	if spawn_item == "helicopter" then
		packet:w_stringZ(motion_name)		
	end 
	
	-- свойства cse_ph_skeleton
	skeleton_name = "idle"
	packet:w_stringZ(skeleton_name)
	packet:w_u8(cse_ph_skeleton__unk1_u8)
	packet:w_u16(cse_ph_skeleton__unk2_u16)

	if spawn_item == "helicopter" then
		-- свойства cse_alife_helicopter
		cse_alife_helicopter__unk1_sz = "idle"
		engine_sound = "alexmx\\helicopter"
		packet:w_stringZ(cse_alife_helicopter__unk1_sz)
		packet:w_stringZ(engine_sound)
	elseif  spawn_item == "vehicle_btr" then
		health = 1
		packet:w_float(health)
	end	
	-- считываем скорректированные параметры
	packet:r_seek(0)
	obj:STATE_Read(packet, packet:w_tell())
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       AMK_RESPAWNS     **   **   **   **   **    **   **   **   
--'*******************************************************************************
function switch_monster_online(obj)
	se_monster.need_be_online[obj.id]=true
end

function switch_monster_offline(obj)
	se_monster.need_be_online[obj.id]=false
end

function respawned(obj,respawner)
	if IsMonster(obj) then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			obj.custom_data = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx"
		end
	elseif IsStalker(obj) then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			obj.custom_data = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx"
		end
	end	
end

local respawners={}

function spawn_unspawned_respawners()

	for a=1,65534 do
		local obj = alife():object(a)
		if obj then
			local oini = obj:spawn_ini()
			if oini:line_exist ("respawn", "amk_name") == true then
				local amk_name = utils.cfg_get_string(oini, "respawn", "amk_name", false, false, false, false)
				if amk_name then respawners[amk_name]=true end
			end
		end
	end

	local sini = ini_file("scripts\\amk\\amk_respawns.ltx")
	
	local dv={}
	if sini:section_exist("default_values") then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("default_values")-1 do
			result, id, value = sini:r_line("default_values",a,"","")
			if id~=nil and xrs_utils.trim(id)~="" and xrs_utils.trim(id)~=nil then
				dv[xrs_utils.trim(id)]=xrs_utils.trim(value)
			end
		end
	end

	if sini:section_exist("amk_respawns") then
		local tmp={}
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count("amk_respawns")-1 do
			result, id, value = sini:r_line("amk_respawns",a,"","")
			if id~=nil and xrs_utils.trim(id)~="" and xrs_utils.trim(id)~=nil then
				table.insert(tmp, xrs_utils.trim(id))
			end
		end
		
		for k,v in pairs(tmp) do
			local flag = utils.cfg_get_bool(sini, "amk_respawns", v, true, false, false)
			if not respawners[v] and flag==true then
				local t = xrs_utils.parse_ini_section_to_array(sini, v)
				local xyzlg = xrs_utils.str_explode(",",t.xyzlg,true)
				local pos = vector():set(tonumber(xyzlg[1]),tonumber(xyzlg[2]),tonumber(xyzlg[3]))
				local respawner = amk.spawn_item("respawn",pos,tonumber(xyzlg[5]),tonumber(xyzlg[4]))
				local tbl = xrs_utils.get_spawner_data(respawner)
				t.xyzlg = nil
				t.amk_name = v

				for kkk,vvv in pairs(dv) do
					if t[kkk]==nil then
						t[kkk]=vvv
					end
				end

				tbl.custom = xrs_utils.gen_custom_data({respawn=t})
				xrs_utils.set_spawner_data(tbl, respawner)
				se_respawn.reinit_spawner_params(respawner:name())
			end
			if flag==false then
				local o = se_respawn.get_respawner_by_name(v)
				if o then
					alife():release(o)
				end
			end
		end
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **          OTHER        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************

local last_armor_id=0
local last_condition=0

function repair_armor(val)
	local armor = db.actor:item_in_slot(6)
	if armor then
		last_armor_id=armor:id()
		last_condition=val
		armor:set_condition(val)
	end
end

btrs_friends={}

function build_btrs_table(obj)
        if obj and (IAmAStalker[obj:clsid()] and obj:character_community()=="military" and obj:alive()) or obj:section()=="vehicle_btr" then
                        btrs_friends[obj:id()] = obj:section()
        end
end