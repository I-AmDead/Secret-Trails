function attach(sm)
    sm:subscribe({signal = "on_first_update",       fun = this.on_first_update})
    sm:subscribe({signal = "on_key_down",           fun = this.on_key_down})
    sm:subscribe({signal = "on_key_up",             fun = this.on_key_up})
    sm:subscribe({signal = "on_item_before_pickup", fun = this.on_item_before_pickup})
    sm:subscribe({signal = "on_update",             fun = this.on_sprint})
end

--------------------------------------------------------------
-- Trigger
--------------------------------------------------------------
local mc_anm_state = 1
local snd_gasmask = sound_object('interface\\item_usage\\gasmask_swipe')
local snd_torch = sound_object('interface\\item_usage\\headflash_switch')
local snd_pickup = sound_object('interface\\item_usage\\pickup')
local snd_case = sound_object('interface\\item_usage\\container_case_open')
local snd_inventory = sound_object('interface\\item_usage\\container_pouch_open')
local snd_harvest = sound_object('interface\\item_usage\\harvest_use')
local snd_loot = sound_object('interface\\item_usage\\harvest_loot')
local hide_hand_speed = 1.5
local anim_plays
local speed_k = 1.0
local key_release = false

local lowered_anm_kinds = {
    ["w_sniper"] = true,
    ["w_rifle"] = true,
    ["w_smg"] = true,
    ["w_shotgun"] = true
}

local lowered_anm_classes = {
    ["WP_VAL"] = true,
    ["WP_AK74"] = true,
    ["WP_LR300"] = true,
    ["WP_BM16"] = true,
    ["WP_SVD"] = true,
    ["WP_SVU"] = true,
    ["WP_GROZA"] = true,
    ["WP_SHOTG"] = true,
    ["WP_RG6"] = true,
    ["WP_RPG7"] = true,
    ["D_PDA"] = true
}

function allow_animation()
    local active_item = db.actor:active_item()
    local allow_all = game.hud_motion_allowed() and not level.only_allow_movekeys()
    if active_item then
        local aim_allow = active_item:is_weapon_magazined() and not ogse_wpn_utils.is_aiming_complete(active_item)
        return active_item:get_hud_item_state() == 0 and (aim_allow or not active_item:is_weapon_magazined()) and allow_all
    else
        return allow_all
    end
end

function on_key_down(key, bind)
    if level.main_input_receiver() or not db.actor:alive() or not allow_animation() or get_actor_obj():is_actor_sprinting() then return end

    local torch = db.actor:item_in_slot(9)
    local pnv = db.actor:item_in_slot(11)

    if bind == key_bindings.kSWIPE_MASK then
        if get_con_string("r2_rain_drops_control") == "off" then return end
        swipe_mask()
    elseif torch and bind == key_bindings.kHEADLAMP then
        torch_and_nvg_switch(false)
    elseif pnv and bind == key_bindings.kNIGHT_VISION and not ogsr_night_vision.nvg_distortion_timer then
        torch_and_nvg_switch(true)
    elseif bind == key_bindings.kWATCH then
        key_release = false
        watch_wide()
    end
end

function on_key_up(key, bind)
    if level.main_input_receiver() or not db.actor:alive() then return end

    if bind == key_bindings.kWATCH then
        key_release = true
    end
end

function get_anm_settings(def_name, def_length, name, length)
    local anm_name = def_name
    local anm_additional_length = def_length
    local itm = db.actor:active_item()

    if itm then
        local kind = get_string(itm:section(), "kind")
        local class = get_string(itm:section(), "class")
        if ((kind and lowered_anm_kinds[kind]) or (class and lowered_anm_classes[class])) then
            anm_name = name
            anm_additional_length = length
        end
    end

    return anm_name, anm_additional_length
end

-- EMULATION SWIPE RAIN DROPS
function swipe_mask()
    local anm_sec = "anim_mask_clean"
    local anm_name, anm_additional_length = get_anm_settings("script\\gasmask.anm", 0.45, "script\\lower.anm", 0.75)

    local anm_time_1 = game.play_hud_motion(1, anm_sec, "anm_hide_hand", true, hide_hand_speed)
    local anm_time_2 = game.get_motion_length(anm_sec, "anm_wipe", 0.8)
    game.play_hud_anm(anm_name, 0, 1, 1, false)
    local new_speed = game.set_hud_anm_time(anm_name, (anm_time_1 + anm_time_2) / 1000 + anm_additional_length)
    animation_on()

    dsh.timeout(anm_time_1, 
    function()
        game.play_hud_motion(db.actor:active_item() and 1 or 2, anm_sec, "anm_wipe", false, 0.8)
        snd_gasmask:play(db.actor, 0, sound_object.s2d)
        snd_gasmask.frequency = 0.8
        level.add_cam_effector("camera_effects\\weapon\\gasmask_swipe1.anm", 7538, false, "", 0, false)
        dsh.timeout(anm_time_2 - 400, 
        function()
            if new_speed then
                game.play_hud_anm(anm_name, 2, new_speed, 1, false, true)
            end
            rain_drops_restart()
            dsh.timeout(anm_time_2 + anm_additional_length, animation_off)
        end)
    end)
end

-- EMULATION TORCH AND NVG SWITCH
function torch_and_nvg_switch(nvg)
    local anm_sec = "anim_headlamp"
    local anm_name, anm_additional_length = get_anm_settings("script\\headlamp.anm", 0.45, "script\\headlamp.anm", 0.75)

    local torch_anm_time_1 = game.get_motion_length(anm_sec, "anm_switch", 1.2)
    animation_on()
    game.play_hud_anm(anm_name, 0, 1, 1, false)
    local new_speed = game.set_hud_anm_time(anm_name, (torch_anm_time_1 / 1000) + anm_additional_length)
    game.play_hud_motion(db.actor:active_item() and 1 or 2, anm_sec, "anm_switch", false, 1.4)
    snd_torch:play(db.actor, 0, sound_object.s2d)
    level.add_cam_effector("camera_effects\\headlamp.anm", 7539, false, "", 0, false)
    timer_sub = nvg and 1000 or 800
    dsh.timeout(torch_anm_time_1 - timer_sub, 
    function()
        if nvg then
            ogsr_night_vision.call_pnv()
        else
            ogse_torch.on_switch()
        end
        dsh.timeout(torch_anm_time_1 - 750, 
        function()
            if new_speed then
                game.play_hud_anm(anm_name, 2, new_speed, 1, false, true)
            end
        end)
        dsh.timeout(torch_anm_time_1, animation_off)
    end)
end

-- EMULATION PICKUP
function on_item_before_pickup(obj)
    if not allow_animation() or get_actor_obj():is_actor_sprinting() then return end

    local pickup_anm_sec = "anim_pickup"
    local cam_pos = device().cam_pos
    local cam_pos_y = cam_pos.y - 0.7
    local obj_pos = obj:position()
    local anm_name = "camera_effects\\weapon\\two_handed_weapon_effect.anm"
    if not anim_plays then
        animation_on()
        local pickup_anm_time = game.play_hud_motion(1, pickup_anm_sec, "anm_take", true, 1.4)
        game.play_hud_anm(anm_name, 0, 1.4, 1, false)
        if obj_pos.y <= cam_pos_y then
            toggle_force_crouch()
            dsh.timeout(pickup_anm_time - 100, function() toggle_force_crouch() end)
        end
        dsh.timeout(pickup_anm_time - 300, function() take_delay(obj) end)
        anim_plays = true
    end
end

-- EMULATION HARVEST
function harvest(on_take)
    if not allow_animation() or get_actor_obj():is_actor_sprinting() then return end

    local harvest_anm_sec = "anim_harvest"
    local loot_anm_sec = "anim_loot"

    local prev_slot = db.actor:active_slot()
    db.actor:activate_slot(255)

    dsh.wait_condition(function() return not db.actor:active_item() end, 
    function()
        speed_k = has_alife_info("acv_gvdr") and 1.2 or 1.0
        level.add_cam_effector("itemuse_anm_effects\\harvest_loot.anm", 8997, false, "")
        level.add_cam_effector("itemuse_anm_effects\\harvest_skin_use.anm", 8998, false, "")
        level.add_cam_effector("camera_effects\\weapon\\harvest_lean_down_main.anm", 8999, false, "")
        level.disable_input()
        animation_on()
        toggle_force_crouch()
        snd_harvest:play(db.actor, 0, sound_object.s2d)
        snd_harvest.frequency = speed_k
        local harvest_anm_time = game.play_hud_motion(2, harvest_anm_sec, "anm_harvest", true, speed_k)
        dsh.timeout(harvest_anm_time + 100, 
        function()
            level.add_cam_effector("script\\harvest_loot.anm", 9000, false, "")
            snd_loot:play(db.actor, 0, sound_object.s2d)
            snd_loot.frequency = speed_k
            local loot_anm_time = game.play_hud_motion(2, loot_anm_sec, "anm_loot", true, speed_k)
            dsh.timeout(loot_anm_time - 500, 
            function()
                toggle_force_crouch()
                on_take()
                level.enable_input()
                archievements.acv_count_event("acv_gvdr", 100, game.translate_string("acv_gvdr"))
            end)
            dsh.timeout(loot_anm_time, 
            function()
                animation_off()
                db.actor:activate_slot(prev_slot)
            end)
        end)
    end)
end

function take_delay(obj)
    local actor = db.actor
    db.actor:transfer_item(obj, db.actor)
    multipickup(1.5, 0.75, actor)
    multipickup(1, 0.5, actor)
    multipickup(0.5, 0.25, actor)
    snd_pickup:play(db.actor, 0, sound_object.s2d)
    animation_off()
    anim_plays = nil
end

function multipickup(dist, radius, actor)
    local pos = device().cam_pos
    local dir = device().cam_dir
    pos = pos:add(dir:mul(dist))
    level.iterate_nearest(pos, dist, function(obj)
        if obj:get_inventory_item() and obj:actor_can_take() and pos:distance_to(obj:position()) <= radius then
            db.actor:transfer_item(obj, db.actor)
        end
    end)
    pos, dir = nil, nil
end

function animation_on()
    level.only_allow_movekeys(true)
    level.set_actor_allow_ladder(false)
end

function animation_off()
    level.only_allow_movekeys(false)
    level.set_actor_allow_ladder(true)
end

function on_first_update()
    animation_off()
    shader_set_custom_param("raindrop_restart", 0, 1, 0, 0)
end

local random_swear = 1

local function lcalls(count, radius, sub)
    local lcall
    local add = 0
    local cnt = count
    raindrop_timer = true
    lcall = level.add_call(
    function()
        cnt = cnt - 2.5
        add = sub and cnt or add + 2.5
        shader_set_custom_param("raindrop_restart", add / 100, random_swear, 0, 0)
        lcall:set_pause(1)
        return cnt == 0
    end, 
    function()
        raindrop_timer = nil
    end)
end

-- RAIN DROPS RESTART
function rain_drops_restart()
    level.only_allow_movekeys(false)
    cmd("r2_rain_drops_control off")
    if get_con_float("r2_rain_drops_factor") > 0.25 then
        random_swear = math.random(1, 4)
        lcalls(100, 1, true)
    end
    dsh.timeout(10, function() cmd("r2_rain_drops_control on") end)
end

local force_crouch = false
local force_crouch_subscribed = nil

function toggle_force_crouch()
    if force_crouch then
        ogsr_signals.get_mgr():unsubscribe(force_crouch_subscribed)
        force_crouch_subscribed = nil
        get_actor_obj():release_action(key_bindings.kCROUCH)
        force_crouch = false
    else
        force_crouch = true
        get_actor_obj():press_action(key_bindings.kCROUCH)
        force_crouch_subscribed = {
            signal = "on_update",
            fun = function()
                if force_crouch then
                    get_actor_obj():hold_action(key_bindings.kCROUCH)
                end
            end
        }
        ogsr_signals.get_mgr():subscribe(force_crouch_subscribed)
    end
end

-- EMULATION SWIPE RAIN DROPS
function watch_wide()
    if not allow_animation() or get_actor_obj():is_actor_sprinting() then return end

    local anm_name, anm_additional_length = get_anm_settings("script\\gasmask.anm", 0.45, "script\\gasmask.anm", 0.75)
    local watch_anm_sec = "anim_watch"
    local outfit = db.actor:item_in_slot(6)
    if outfit and get_bool(outfit:section(), "exo", false) then
        watch_anm_sec = "anim_exo_watch"
    end

    local watch_anm_time = game.play_hud_motion(1, watch_anm_sec, "anm_in", true, 1)
    game.play_hud_anm(anm_name, 0, 0.5, 1, false)
    animation_on()
    ui_minimap_bioradar.hud_hide()
    dsh.timeout(watch_anm_time, function()
        game.set_hud_anm_time(anm_name, 10000000)
        game.play_hud_motion(db.actor:active_item() and 1 or 2, watch_anm_sec, "anm_idle", true, 1)
        dsh.wait_condition(function() return key_release end, 
        function()
            game.stop_hud_motion()
            watch_anm_time = game.play_hud_motion(db.actor:active_item() and 1 or 2, watch_anm_sec, "anm_out", true, 1)
            game.set_hud_anm_time(anm_name, (watch_anm_time + 200) / 1000)
            ui_minimap_bioradar.hud_show()
            dsh.timeout(watch_anm_time, function() animation_off() end)
        end)
    end)
end

local sprint_anim = false
function on_sprint()
    if allow_animation() and not sprint_anim then
        if db.actor:active_item() or not get_actor_obj():is_actor_sprinting() then return end
        game.play_hud_motion(2, "anim_sprint_no_hand", "anm_sprint", true, 1)
        --animation_on()
        sprint_anim = true
    end

    if sprint_anim and (db.actor:active_item() or not get_actor_obj():is_actor_sprinting()) then
        game.stop_hud_motion()
        --animation_off()
        sprint_anim = false
    end
end